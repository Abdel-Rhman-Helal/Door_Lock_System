
Control_ECU.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003a08  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000011e  00800060  00003a08  00003a9c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000005  0080017e  0080017e  00003bba  2**0
                  ALLOC
  3 .stab         00003a2c  00000000  00000000  00003bbc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002afb  00000000  00000000  000075e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001a0  00000000  00000000  0000a0e3  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001f2  00000000  00000000  0000a283  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000240b  00000000  00000000  0000a475  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001386  00000000  00000000  0000c880  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000011d6  00000000  00000000  0000dc06  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001c0  00000000  00000000  0000eddc  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002f6  00000000  00000000  0000ef9c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000096e  00000000  00000000  0000f292  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0000fc00  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 f1 09 	jmp	0x13e2	; 0x13e2 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 be 09 	jmp	0x137c	; 0x137c <__vector_9>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e0       	ldi	r30, 0x08	; 8
      68:	fa e3       	ldi	r31, 0x3A	; 58
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ae 37       	cpi	r26, 0x7E	; 126
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	11 e0       	ldi	r17, 0x01	; 1
      78:	ae e7       	ldi	r26, 0x7E	; 126
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 38       	cpi	r26, 0x83	; 131
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 7b 0f 	call	0x1ef6	; 0x1ef6 <main>
      8a:	0c 94 02 1d 	jmp	0x3a04	; 0x3a04 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 cb 1c 	jmp	0x3996	; 0x3996 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a0 e6       	ldi	r26, 0x60	; 96
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 e7 1c 	jmp	0x39ce	; 0x39ce <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 d7 1c 	jmp	0x39ae	; 0x39ae <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 f3 1c 	jmp	0x39e6	; 0x39e6 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 d7 1c 	jmp	0x39ae	; 0x39ae <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 f3 1c 	jmp	0x39e6	; 0x39e6 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 cb 1c 	jmp	0x3996	; 0x3996 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	80 e6       	ldi	r24, 0x60	; 96
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 e7 1c 	jmp	0x39ce	; 0x39ce <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 d3 1c 	jmp	0x39a6	; 0x39a6 <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	60 e6       	ldi	r22, 0x60	; 96
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 ef 1c 	jmp	0x39de	; 0x39de <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 d7 1c 	jmp	0x39ae	; 0x39ae <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 f3 1c 	jmp	0x39e6	; 0x39e6 <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 d7 1c 	jmp	0x39ae	; 0x39ae <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 f3 1c 	jmp	0x39e6	; 0x39e6 <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 d7 1c 	jmp	0x39ae	; 0x39ae <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 f3 1c 	jmp	0x39e6	; 0x39e6 <__epilogue_restores__+0x18>

000008aa <__fixsfsi>:
     8aa:	ac e0       	ldi	r26, 0x0C	; 12
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 db 1c 	jmp	0x39b6	; 0x39b6 <__prologue_saves__+0x20>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	ce 01       	movw	r24, r28
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	be 01       	movw	r22, r28
     8c4:	6b 5f       	subi	r22, 0xFB	; 251
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     8cc:	8d 81       	ldd	r24, Y+5	; 0x05
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	61 f1       	breq	.+88     	; 0x92a <__fixsfsi+0x80>
     8d2:	82 30       	cpi	r24, 0x02	; 2
     8d4:	50 f1       	brcs	.+84     	; 0x92a <__fixsfsi+0x80>
     8d6:	84 30       	cpi	r24, 0x04	; 4
     8d8:	21 f4       	brne	.+8      	; 0x8e2 <__fixsfsi+0x38>
     8da:	8e 81       	ldd	r24, Y+6	; 0x06
     8dc:	88 23       	and	r24, r24
     8de:	51 f1       	breq	.+84     	; 0x934 <__fixsfsi+0x8a>
     8e0:	2e c0       	rjmp	.+92     	; 0x93e <__fixsfsi+0x94>
     8e2:	2f 81       	ldd	r18, Y+7	; 0x07
     8e4:	38 85       	ldd	r19, Y+8	; 0x08
     8e6:	37 fd       	sbrc	r19, 7
     8e8:	20 c0       	rjmp	.+64     	; 0x92a <__fixsfsi+0x80>
     8ea:	6e 81       	ldd	r22, Y+6	; 0x06
     8ec:	2f 31       	cpi	r18, 0x1F	; 31
     8ee:	31 05       	cpc	r19, r1
     8f0:	1c f0       	brlt	.+6      	; 0x8f8 <__fixsfsi+0x4e>
     8f2:	66 23       	and	r22, r22
     8f4:	f9 f0       	breq	.+62     	; 0x934 <__fixsfsi+0x8a>
     8f6:	23 c0       	rjmp	.+70     	; 0x93e <__fixsfsi+0x94>
     8f8:	8e e1       	ldi	r24, 0x1E	; 30
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	82 1b       	sub	r24, r18
     8fe:	93 0b       	sbc	r25, r19
     900:	29 85       	ldd	r18, Y+9	; 0x09
     902:	3a 85       	ldd	r19, Y+10	; 0x0a
     904:	4b 85       	ldd	r20, Y+11	; 0x0b
     906:	5c 85       	ldd	r21, Y+12	; 0x0c
     908:	04 c0       	rjmp	.+8      	; 0x912 <__fixsfsi+0x68>
     90a:	56 95       	lsr	r21
     90c:	47 95       	ror	r20
     90e:	37 95       	ror	r19
     910:	27 95       	ror	r18
     912:	8a 95       	dec	r24
     914:	d2 f7       	brpl	.-12     	; 0x90a <__fixsfsi+0x60>
     916:	66 23       	and	r22, r22
     918:	b1 f0       	breq	.+44     	; 0x946 <__fixsfsi+0x9c>
     91a:	50 95       	com	r21
     91c:	40 95       	com	r20
     91e:	30 95       	com	r19
     920:	21 95       	neg	r18
     922:	3f 4f       	sbci	r19, 0xFF	; 255
     924:	4f 4f       	sbci	r20, 0xFF	; 255
     926:	5f 4f       	sbci	r21, 0xFF	; 255
     928:	0e c0       	rjmp	.+28     	; 0x946 <__fixsfsi+0x9c>
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	09 c0       	rjmp	.+18     	; 0x946 <__fixsfsi+0x9c>
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	3f ef       	ldi	r19, 0xFF	; 255
     938:	4f ef       	ldi	r20, 0xFF	; 255
     93a:	5f e7       	ldi	r21, 0x7F	; 127
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__fixsfsi+0x9c>
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	40 e0       	ldi	r20, 0x00	; 0
     944:	50 e8       	ldi	r21, 0x80	; 128
     946:	b9 01       	movw	r22, r18
     948:	ca 01       	movw	r24, r20
     94a:	2c 96       	adiw	r28, 0x0c	; 12
     94c:	e2 e0       	ldi	r30, 0x02	; 2
     94e:	0c 94 f7 1c 	jmp	0x39ee	; 0x39ee <__epilogue_restores__+0x20>

00000952 <__floatunsisf>:
     952:	a8 e0       	ldi	r26, 0x08	; 8
     954:	b0 e0       	ldi	r27, 0x00	; 0
     956:	ef ea       	ldi	r30, 0xAF	; 175
     958:	f4 e0       	ldi	r31, 0x04	; 4
     95a:	0c 94 d3 1c 	jmp	0x39a6	; 0x39a6 <__prologue_saves__+0x10>
     95e:	7b 01       	movw	r14, r22
     960:	8c 01       	movw	r16, r24
     962:	61 15       	cp	r22, r1
     964:	71 05       	cpc	r23, r1
     966:	81 05       	cpc	r24, r1
     968:	91 05       	cpc	r25, r1
     96a:	19 f4       	brne	.+6      	; 0x972 <__floatunsisf+0x20>
     96c:	82 e0       	ldi	r24, 0x02	; 2
     96e:	89 83       	std	Y+1, r24	; 0x01
     970:	60 c0       	rjmp	.+192    	; 0xa32 <__floatunsisf+0xe0>
     972:	83 e0       	ldi	r24, 0x03	; 3
     974:	89 83       	std	Y+1, r24	; 0x01
     976:	8e e1       	ldi	r24, 0x1E	; 30
     978:	c8 2e       	mov	r12, r24
     97a:	d1 2c       	mov	r13, r1
     97c:	dc 82       	std	Y+4, r13	; 0x04
     97e:	cb 82       	std	Y+3, r12	; 0x03
     980:	ed 82       	std	Y+5, r14	; 0x05
     982:	fe 82       	std	Y+6, r15	; 0x06
     984:	0f 83       	std	Y+7, r16	; 0x07
     986:	18 87       	std	Y+8, r17	; 0x08
     988:	c8 01       	movw	r24, r16
     98a:	b7 01       	movw	r22, r14
     98c:	0e 94 22 05 	call	0xa44	; 0xa44 <__clzsi2>
     990:	fc 01       	movw	r30, r24
     992:	31 97       	sbiw	r30, 0x01	; 1
     994:	f7 ff       	sbrs	r31, 7
     996:	3b c0       	rjmp	.+118    	; 0xa0e <__floatunsisf+0xbc>
     998:	22 27       	eor	r18, r18
     99a:	33 27       	eor	r19, r19
     99c:	2e 1b       	sub	r18, r30
     99e:	3f 0b       	sbc	r19, r31
     9a0:	57 01       	movw	r10, r14
     9a2:	68 01       	movw	r12, r16
     9a4:	02 2e       	mov	r0, r18
     9a6:	04 c0       	rjmp	.+8      	; 0x9b0 <__floatunsisf+0x5e>
     9a8:	d6 94       	lsr	r13
     9aa:	c7 94       	ror	r12
     9ac:	b7 94       	ror	r11
     9ae:	a7 94       	ror	r10
     9b0:	0a 94       	dec	r0
     9b2:	d2 f7       	brpl	.-12     	; 0x9a8 <__floatunsisf+0x56>
     9b4:	40 e0       	ldi	r20, 0x00	; 0
     9b6:	50 e0       	ldi	r21, 0x00	; 0
     9b8:	60 e0       	ldi	r22, 0x00	; 0
     9ba:	70 e0       	ldi	r23, 0x00	; 0
     9bc:	81 e0       	ldi	r24, 0x01	; 1
     9be:	90 e0       	ldi	r25, 0x00	; 0
     9c0:	a0 e0       	ldi	r26, 0x00	; 0
     9c2:	b0 e0       	ldi	r27, 0x00	; 0
     9c4:	04 c0       	rjmp	.+8      	; 0x9ce <__floatunsisf+0x7c>
     9c6:	88 0f       	add	r24, r24
     9c8:	99 1f       	adc	r25, r25
     9ca:	aa 1f       	adc	r26, r26
     9cc:	bb 1f       	adc	r27, r27
     9ce:	2a 95       	dec	r18
     9d0:	d2 f7       	brpl	.-12     	; 0x9c6 <__floatunsisf+0x74>
     9d2:	01 97       	sbiw	r24, 0x01	; 1
     9d4:	a1 09       	sbc	r26, r1
     9d6:	b1 09       	sbc	r27, r1
     9d8:	8e 21       	and	r24, r14
     9da:	9f 21       	and	r25, r15
     9dc:	a0 23       	and	r26, r16
     9de:	b1 23       	and	r27, r17
     9e0:	00 97       	sbiw	r24, 0x00	; 0
     9e2:	a1 05       	cpc	r26, r1
     9e4:	b1 05       	cpc	r27, r1
     9e6:	21 f0       	breq	.+8      	; 0x9f0 <__floatunsisf+0x9e>
     9e8:	41 e0       	ldi	r20, 0x01	; 1
     9ea:	50 e0       	ldi	r21, 0x00	; 0
     9ec:	60 e0       	ldi	r22, 0x00	; 0
     9ee:	70 e0       	ldi	r23, 0x00	; 0
     9f0:	4a 29       	or	r20, r10
     9f2:	5b 29       	or	r21, r11
     9f4:	6c 29       	or	r22, r12
     9f6:	7d 29       	or	r23, r13
     9f8:	4d 83       	std	Y+5, r20	; 0x05
     9fa:	5e 83       	std	Y+6, r21	; 0x06
     9fc:	6f 83       	std	Y+7, r22	; 0x07
     9fe:	78 87       	std	Y+8, r23	; 0x08
     a00:	8e e1       	ldi	r24, 0x1E	; 30
     a02:	90 e0       	ldi	r25, 0x00	; 0
     a04:	8e 1b       	sub	r24, r30
     a06:	9f 0b       	sbc	r25, r31
     a08:	9c 83       	std	Y+4, r25	; 0x04
     a0a:	8b 83       	std	Y+3, r24	; 0x03
     a0c:	12 c0       	rjmp	.+36     	; 0xa32 <__floatunsisf+0xe0>
     a0e:	30 97       	sbiw	r30, 0x00	; 0
     a10:	81 f0       	breq	.+32     	; 0xa32 <__floatunsisf+0xe0>
     a12:	0e 2e       	mov	r0, r30
     a14:	04 c0       	rjmp	.+8      	; 0xa1e <__floatunsisf+0xcc>
     a16:	ee 0c       	add	r14, r14
     a18:	ff 1c       	adc	r15, r15
     a1a:	00 1f       	adc	r16, r16
     a1c:	11 1f       	adc	r17, r17
     a1e:	0a 94       	dec	r0
     a20:	d2 f7       	brpl	.-12     	; 0xa16 <__floatunsisf+0xc4>
     a22:	ed 82       	std	Y+5, r14	; 0x05
     a24:	fe 82       	std	Y+6, r15	; 0x06
     a26:	0f 83       	std	Y+7, r16	; 0x07
     a28:	18 87       	std	Y+8, r17	; 0x08
     a2a:	ce 1a       	sub	r12, r30
     a2c:	df 0a       	sbc	r13, r31
     a2e:	dc 82       	std	Y+4, r13	; 0x04
     a30:	cb 82       	std	Y+3, r12	; 0x03
     a32:	1a 82       	std	Y+2, r1	; 0x02
     a34:	ce 01       	movw	r24, r28
     a36:	01 96       	adiw	r24, 0x01	; 1
     a38:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     a3c:	28 96       	adiw	r28, 0x08	; 8
     a3e:	ea e0       	ldi	r30, 0x0A	; 10
     a40:	0c 94 ef 1c 	jmp	0x39de	; 0x39de <__epilogue_restores__+0x10>

00000a44 <__clzsi2>:
     a44:	ef 92       	push	r14
     a46:	ff 92       	push	r15
     a48:	0f 93       	push	r16
     a4a:	1f 93       	push	r17
     a4c:	7b 01       	movw	r14, r22
     a4e:	8c 01       	movw	r16, r24
     a50:	80 e0       	ldi	r24, 0x00	; 0
     a52:	e8 16       	cp	r14, r24
     a54:	80 e0       	ldi	r24, 0x00	; 0
     a56:	f8 06       	cpc	r15, r24
     a58:	81 e0       	ldi	r24, 0x01	; 1
     a5a:	08 07       	cpc	r16, r24
     a5c:	80 e0       	ldi	r24, 0x00	; 0
     a5e:	18 07       	cpc	r17, r24
     a60:	88 f4       	brcc	.+34     	; 0xa84 <__clzsi2+0x40>
     a62:	8f ef       	ldi	r24, 0xFF	; 255
     a64:	e8 16       	cp	r14, r24
     a66:	f1 04       	cpc	r15, r1
     a68:	01 05       	cpc	r16, r1
     a6a:	11 05       	cpc	r17, r1
     a6c:	31 f0       	breq	.+12     	; 0xa7a <__clzsi2+0x36>
     a6e:	28 f0       	brcs	.+10     	; 0xa7a <__clzsi2+0x36>
     a70:	88 e0       	ldi	r24, 0x08	; 8
     a72:	90 e0       	ldi	r25, 0x00	; 0
     a74:	a0 e0       	ldi	r26, 0x00	; 0
     a76:	b0 e0       	ldi	r27, 0x00	; 0
     a78:	17 c0       	rjmp	.+46     	; 0xaa8 <__clzsi2+0x64>
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	90 e0       	ldi	r25, 0x00	; 0
     a7e:	a0 e0       	ldi	r26, 0x00	; 0
     a80:	b0 e0       	ldi	r27, 0x00	; 0
     a82:	12 c0       	rjmp	.+36     	; 0xaa8 <__clzsi2+0x64>
     a84:	80 e0       	ldi	r24, 0x00	; 0
     a86:	e8 16       	cp	r14, r24
     a88:	80 e0       	ldi	r24, 0x00	; 0
     a8a:	f8 06       	cpc	r15, r24
     a8c:	80 e0       	ldi	r24, 0x00	; 0
     a8e:	08 07       	cpc	r16, r24
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	18 07       	cpc	r17, r24
     a94:	28 f0       	brcs	.+10     	; 0xaa0 <__clzsi2+0x5c>
     a96:	88 e1       	ldi	r24, 0x18	; 24
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	a0 e0       	ldi	r26, 0x00	; 0
     a9c:	b0 e0       	ldi	r27, 0x00	; 0
     a9e:	04 c0       	rjmp	.+8      	; 0xaa8 <__clzsi2+0x64>
     aa0:	80 e1       	ldi	r24, 0x10	; 16
     aa2:	90 e0       	ldi	r25, 0x00	; 0
     aa4:	a0 e0       	ldi	r26, 0x00	; 0
     aa6:	b0 e0       	ldi	r27, 0x00	; 0
     aa8:	20 e2       	ldi	r18, 0x20	; 32
     aaa:	30 e0       	ldi	r19, 0x00	; 0
     aac:	40 e0       	ldi	r20, 0x00	; 0
     aae:	50 e0       	ldi	r21, 0x00	; 0
     ab0:	28 1b       	sub	r18, r24
     ab2:	39 0b       	sbc	r19, r25
     ab4:	4a 0b       	sbc	r20, r26
     ab6:	5b 0b       	sbc	r21, r27
     ab8:	04 c0       	rjmp	.+8      	; 0xac2 <__clzsi2+0x7e>
     aba:	16 95       	lsr	r17
     abc:	07 95       	ror	r16
     abe:	f7 94       	ror	r15
     ac0:	e7 94       	ror	r14
     ac2:	8a 95       	dec	r24
     ac4:	d2 f7       	brpl	.-12     	; 0xaba <__clzsi2+0x76>
     ac6:	f7 01       	movw	r30, r14
     ac8:	e8 59       	subi	r30, 0x98	; 152
     aca:	ff 4f       	sbci	r31, 0xFF	; 255
     acc:	80 81       	ld	r24, Z
     ace:	28 1b       	sub	r18, r24
     ad0:	31 09       	sbc	r19, r1
     ad2:	41 09       	sbc	r20, r1
     ad4:	51 09       	sbc	r21, r1
     ad6:	c9 01       	movw	r24, r18
     ad8:	1f 91       	pop	r17
     ada:	0f 91       	pop	r16
     adc:	ff 90       	pop	r15
     ade:	ef 90       	pop	r14
     ae0:	08 95       	ret

00000ae2 <__pack_f>:
     ae2:	df 92       	push	r13
     ae4:	ef 92       	push	r14
     ae6:	ff 92       	push	r15
     ae8:	0f 93       	push	r16
     aea:	1f 93       	push	r17
     aec:	fc 01       	movw	r30, r24
     aee:	e4 80       	ldd	r14, Z+4	; 0x04
     af0:	f5 80       	ldd	r15, Z+5	; 0x05
     af2:	06 81       	ldd	r16, Z+6	; 0x06
     af4:	17 81       	ldd	r17, Z+7	; 0x07
     af6:	d1 80       	ldd	r13, Z+1	; 0x01
     af8:	80 81       	ld	r24, Z
     afa:	82 30       	cpi	r24, 0x02	; 2
     afc:	48 f4       	brcc	.+18     	; 0xb10 <__pack_f+0x2e>
     afe:	80 e0       	ldi	r24, 0x00	; 0
     b00:	90 e0       	ldi	r25, 0x00	; 0
     b02:	a0 e1       	ldi	r26, 0x10	; 16
     b04:	b0 e0       	ldi	r27, 0x00	; 0
     b06:	e8 2a       	or	r14, r24
     b08:	f9 2a       	or	r15, r25
     b0a:	0a 2b       	or	r16, r26
     b0c:	1b 2b       	or	r17, r27
     b0e:	a5 c0       	rjmp	.+330    	; 0xc5a <__pack_f+0x178>
     b10:	84 30       	cpi	r24, 0x04	; 4
     b12:	09 f4       	brne	.+2      	; 0xb16 <__pack_f+0x34>
     b14:	9f c0       	rjmp	.+318    	; 0xc54 <__pack_f+0x172>
     b16:	82 30       	cpi	r24, 0x02	; 2
     b18:	21 f4       	brne	.+8      	; 0xb22 <__pack_f+0x40>
     b1a:	ee 24       	eor	r14, r14
     b1c:	ff 24       	eor	r15, r15
     b1e:	87 01       	movw	r16, r14
     b20:	05 c0       	rjmp	.+10     	; 0xb2c <__pack_f+0x4a>
     b22:	e1 14       	cp	r14, r1
     b24:	f1 04       	cpc	r15, r1
     b26:	01 05       	cpc	r16, r1
     b28:	11 05       	cpc	r17, r1
     b2a:	19 f4       	brne	.+6      	; 0xb32 <__pack_f+0x50>
     b2c:	e0 e0       	ldi	r30, 0x00	; 0
     b2e:	f0 e0       	ldi	r31, 0x00	; 0
     b30:	96 c0       	rjmp	.+300    	; 0xc5e <__pack_f+0x17c>
     b32:	62 81       	ldd	r22, Z+2	; 0x02
     b34:	73 81       	ldd	r23, Z+3	; 0x03
     b36:	9f ef       	ldi	r25, 0xFF	; 255
     b38:	62 38       	cpi	r22, 0x82	; 130
     b3a:	79 07       	cpc	r23, r25
     b3c:	0c f0       	brlt	.+2      	; 0xb40 <__pack_f+0x5e>
     b3e:	5b c0       	rjmp	.+182    	; 0xbf6 <__pack_f+0x114>
     b40:	22 e8       	ldi	r18, 0x82	; 130
     b42:	3f ef       	ldi	r19, 0xFF	; 255
     b44:	26 1b       	sub	r18, r22
     b46:	37 0b       	sbc	r19, r23
     b48:	2a 31       	cpi	r18, 0x1A	; 26
     b4a:	31 05       	cpc	r19, r1
     b4c:	2c f0       	brlt	.+10     	; 0xb58 <__pack_f+0x76>
     b4e:	20 e0       	ldi	r18, 0x00	; 0
     b50:	30 e0       	ldi	r19, 0x00	; 0
     b52:	40 e0       	ldi	r20, 0x00	; 0
     b54:	50 e0       	ldi	r21, 0x00	; 0
     b56:	2a c0       	rjmp	.+84     	; 0xbac <__pack_f+0xca>
     b58:	b8 01       	movw	r22, r16
     b5a:	a7 01       	movw	r20, r14
     b5c:	02 2e       	mov	r0, r18
     b5e:	04 c0       	rjmp	.+8      	; 0xb68 <__pack_f+0x86>
     b60:	76 95       	lsr	r23
     b62:	67 95       	ror	r22
     b64:	57 95       	ror	r21
     b66:	47 95       	ror	r20
     b68:	0a 94       	dec	r0
     b6a:	d2 f7       	brpl	.-12     	; 0xb60 <__pack_f+0x7e>
     b6c:	81 e0       	ldi	r24, 0x01	; 1
     b6e:	90 e0       	ldi	r25, 0x00	; 0
     b70:	a0 e0       	ldi	r26, 0x00	; 0
     b72:	b0 e0       	ldi	r27, 0x00	; 0
     b74:	04 c0       	rjmp	.+8      	; 0xb7e <__pack_f+0x9c>
     b76:	88 0f       	add	r24, r24
     b78:	99 1f       	adc	r25, r25
     b7a:	aa 1f       	adc	r26, r26
     b7c:	bb 1f       	adc	r27, r27
     b7e:	2a 95       	dec	r18
     b80:	d2 f7       	brpl	.-12     	; 0xb76 <__pack_f+0x94>
     b82:	01 97       	sbiw	r24, 0x01	; 1
     b84:	a1 09       	sbc	r26, r1
     b86:	b1 09       	sbc	r27, r1
     b88:	8e 21       	and	r24, r14
     b8a:	9f 21       	and	r25, r15
     b8c:	a0 23       	and	r26, r16
     b8e:	b1 23       	and	r27, r17
     b90:	00 97       	sbiw	r24, 0x00	; 0
     b92:	a1 05       	cpc	r26, r1
     b94:	b1 05       	cpc	r27, r1
     b96:	21 f0       	breq	.+8      	; 0xba0 <__pack_f+0xbe>
     b98:	81 e0       	ldi	r24, 0x01	; 1
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	a0 e0       	ldi	r26, 0x00	; 0
     b9e:	b0 e0       	ldi	r27, 0x00	; 0
     ba0:	9a 01       	movw	r18, r20
     ba2:	ab 01       	movw	r20, r22
     ba4:	28 2b       	or	r18, r24
     ba6:	39 2b       	or	r19, r25
     ba8:	4a 2b       	or	r20, r26
     baa:	5b 2b       	or	r21, r27
     bac:	da 01       	movw	r26, r20
     bae:	c9 01       	movw	r24, r18
     bb0:	8f 77       	andi	r24, 0x7F	; 127
     bb2:	90 70       	andi	r25, 0x00	; 0
     bb4:	a0 70       	andi	r26, 0x00	; 0
     bb6:	b0 70       	andi	r27, 0x00	; 0
     bb8:	80 34       	cpi	r24, 0x40	; 64
     bba:	91 05       	cpc	r25, r1
     bbc:	a1 05       	cpc	r26, r1
     bbe:	b1 05       	cpc	r27, r1
     bc0:	39 f4       	brne	.+14     	; 0xbd0 <__pack_f+0xee>
     bc2:	27 ff       	sbrs	r18, 7
     bc4:	09 c0       	rjmp	.+18     	; 0xbd8 <__pack_f+0xf6>
     bc6:	20 5c       	subi	r18, 0xC0	; 192
     bc8:	3f 4f       	sbci	r19, 0xFF	; 255
     bca:	4f 4f       	sbci	r20, 0xFF	; 255
     bcc:	5f 4f       	sbci	r21, 0xFF	; 255
     bce:	04 c0       	rjmp	.+8      	; 0xbd8 <__pack_f+0xf6>
     bd0:	21 5c       	subi	r18, 0xC1	; 193
     bd2:	3f 4f       	sbci	r19, 0xFF	; 255
     bd4:	4f 4f       	sbci	r20, 0xFF	; 255
     bd6:	5f 4f       	sbci	r21, 0xFF	; 255
     bd8:	e0 e0       	ldi	r30, 0x00	; 0
     bda:	f0 e0       	ldi	r31, 0x00	; 0
     bdc:	20 30       	cpi	r18, 0x00	; 0
     bde:	a0 e0       	ldi	r26, 0x00	; 0
     be0:	3a 07       	cpc	r19, r26
     be2:	a0 e0       	ldi	r26, 0x00	; 0
     be4:	4a 07       	cpc	r20, r26
     be6:	a0 e4       	ldi	r26, 0x40	; 64
     be8:	5a 07       	cpc	r21, r26
     bea:	10 f0       	brcs	.+4      	; 0xbf0 <__pack_f+0x10e>
     bec:	e1 e0       	ldi	r30, 0x01	; 1
     bee:	f0 e0       	ldi	r31, 0x00	; 0
     bf0:	79 01       	movw	r14, r18
     bf2:	8a 01       	movw	r16, r20
     bf4:	27 c0       	rjmp	.+78     	; 0xc44 <__pack_f+0x162>
     bf6:	60 38       	cpi	r22, 0x80	; 128
     bf8:	71 05       	cpc	r23, r1
     bfa:	64 f5       	brge	.+88     	; 0xc54 <__pack_f+0x172>
     bfc:	fb 01       	movw	r30, r22
     bfe:	e1 58       	subi	r30, 0x81	; 129
     c00:	ff 4f       	sbci	r31, 0xFF	; 255
     c02:	d8 01       	movw	r26, r16
     c04:	c7 01       	movw	r24, r14
     c06:	8f 77       	andi	r24, 0x7F	; 127
     c08:	90 70       	andi	r25, 0x00	; 0
     c0a:	a0 70       	andi	r26, 0x00	; 0
     c0c:	b0 70       	andi	r27, 0x00	; 0
     c0e:	80 34       	cpi	r24, 0x40	; 64
     c10:	91 05       	cpc	r25, r1
     c12:	a1 05       	cpc	r26, r1
     c14:	b1 05       	cpc	r27, r1
     c16:	39 f4       	brne	.+14     	; 0xc26 <__pack_f+0x144>
     c18:	e7 fe       	sbrs	r14, 7
     c1a:	0d c0       	rjmp	.+26     	; 0xc36 <__pack_f+0x154>
     c1c:	80 e4       	ldi	r24, 0x40	; 64
     c1e:	90 e0       	ldi	r25, 0x00	; 0
     c20:	a0 e0       	ldi	r26, 0x00	; 0
     c22:	b0 e0       	ldi	r27, 0x00	; 0
     c24:	04 c0       	rjmp	.+8      	; 0xc2e <__pack_f+0x14c>
     c26:	8f e3       	ldi	r24, 0x3F	; 63
     c28:	90 e0       	ldi	r25, 0x00	; 0
     c2a:	a0 e0       	ldi	r26, 0x00	; 0
     c2c:	b0 e0       	ldi	r27, 0x00	; 0
     c2e:	e8 0e       	add	r14, r24
     c30:	f9 1e       	adc	r15, r25
     c32:	0a 1f       	adc	r16, r26
     c34:	1b 1f       	adc	r17, r27
     c36:	17 ff       	sbrs	r17, 7
     c38:	05 c0       	rjmp	.+10     	; 0xc44 <__pack_f+0x162>
     c3a:	16 95       	lsr	r17
     c3c:	07 95       	ror	r16
     c3e:	f7 94       	ror	r15
     c40:	e7 94       	ror	r14
     c42:	31 96       	adiw	r30, 0x01	; 1
     c44:	87 e0       	ldi	r24, 0x07	; 7
     c46:	16 95       	lsr	r17
     c48:	07 95       	ror	r16
     c4a:	f7 94       	ror	r15
     c4c:	e7 94       	ror	r14
     c4e:	8a 95       	dec	r24
     c50:	d1 f7       	brne	.-12     	; 0xc46 <__pack_f+0x164>
     c52:	05 c0       	rjmp	.+10     	; 0xc5e <__pack_f+0x17c>
     c54:	ee 24       	eor	r14, r14
     c56:	ff 24       	eor	r15, r15
     c58:	87 01       	movw	r16, r14
     c5a:	ef ef       	ldi	r30, 0xFF	; 255
     c5c:	f0 e0       	ldi	r31, 0x00	; 0
     c5e:	6e 2f       	mov	r22, r30
     c60:	67 95       	ror	r22
     c62:	66 27       	eor	r22, r22
     c64:	67 95       	ror	r22
     c66:	90 2f       	mov	r25, r16
     c68:	9f 77       	andi	r25, 0x7F	; 127
     c6a:	d7 94       	ror	r13
     c6c:	dd 24       	eor	r13, r13
     c6e:	d7 94       	ror	r13
     c70:	8e 2f       	mov	r24, r30
     c72:	86 95       	lsr	r24
     c74:	49 2f       	mov	r20, r25
     c76:	46 2b       	or	r20, r22
     c78:	58 2f       	mov	r21, r24
     c7a:	5d 29       	or	r21, r13
     c7c:	b7 01       	movw	r22, r14
     c7e:	ca 01       	movw	r24, r20
     c80:	1f 91       	pop	r17
     c82:	0f 91       	pop	r16
     c84:	ff 90       	pop	r15
     c86:	ef 90       	pop	r14
     c88:	df 90       	pop	r13
     c8a:	08 95       	ret

00000c8c <__unpack_f>:
     c8c:	fc 01       	movw	r30, r24
     c8e:	db 01       	movw	r26, r22
     c90:	40 81       	ld	r20, Z
     c92:	51 81       	ldd	r21, Z+1	; 0x01
     c94:	22 81       	ldd	r18, Z+2	; 0x02
     c96:	62 2f       	mov	r22, r18
     c98:	6f 77       	andi	r22, 0x7F	; 127
     c9a:	70 e0       	ldi	r23, 0x00	; 0
     c9c:	22 1f       	adc	r18, r18
     c9e:	22 27       	eor	r18, r18
     ca0:	22 1f       	adc	r18, r18
     ca2:	93 81       	ldd	r25, Z+3	; 0x03
     ca4:	89 2f       	mov	r24, r25
     ca6:	88 0f       	add	r24, r24
     ca8:	82 2b       	or	r24, r18
     caa:	28 2f       	mov	r18, r24
     cac:	30 e0       	ldi	r19, 0x00	; 0
     cae:	99 1f       	adc	r25, r25
     cb0:	99 27       	eor	r25, r25
     cb2:	99 1f       	adc	r25, r25
     cb4:	11 96       	adiw	r26, 0x01	; 1
     cb6:	9c 93       	st	X, r25
     cb8:	11 97       	sbiw	r26, 0x01	; 1
     cba:	21 15       	cp	r18, r1
     cbc:	31 05       	cpc	r19, r1
     cbe:	a9 f5       	brne	.+106    	; 0xd2a <__unpack_f+0x9e>
     cc0:	41 15       	cp	r20, r1
     cc2:	51 05       	cpc	r21, r1
     cc4:	61 05       	cpc	r22, r1
     cc6:	71 05       	cpc	r23, r1
     cc8:	11 f4       	brne	.+4      	; 0xcce <__unpack_f+0x42>
     cca:	82 e0       	ldi	r24, 0x02	; 2
     ccc:	37 c0       	rjmp	.+110    	; 0xd3c <__unpack_f+0xb0>
     cce:	82 e8       	ldi	r24, 0x82	; 130
     cd0:	9f ef       	ldi	r25, 0xFF	; 255
     cd2:	13 96       	adiw	r26, 0x03	; 3
     cd4:	9c 93       	st	X, r25
     cd6:	8e 93       	st	-X, r24
     cd8:	12 97       	sbiw	r26, 0x02	; 2
     cda:	9a 01       	movw	r18, r20
     cdc:	ab 01       	movw	r20, r22
     cde:	67 e0       	ldi	r22, 0x07	; 7
     ce0:	22 0f       	add	r18, r18
     ce2:	33 1f       	adc	r19, r19
     ce4:	44 1f       	adc	r20, r20
     ce6:	55 1f       	adc	r21, r21
     ce8:	6a 95       	dec	r22
     cea:	d1 f7       	brne	.-12     	; 0xce0 <__unpack_f+0x54>
     cec:	83 e0       	ldi	r24, 0x03	; 3
     cee:	8c 93       	st	X, r24
     cf0:	0d c0       	rjmp	.+26     	; 0xd0c <__unpack_f+0x80>
     cf2:	22 0f       	add	r18, r18
     cf4:	33 1f       	adc	r19, r19
     cf6:	44 1f       	adc	r20, r20
     cf8:	55 1f       	adc	r21, r21
     cfa:	12 96       	adiw	r26, 0x02	; 2
     cfc:	8d 91       	ld	r24, X+
     cfe:	9c 91       	ld	r25, X
     d00:	13 97       	sbiw	r26, 0x03	; 3
     d02:	01 97       	sbiw	r24, 0x01	; 1
     d04:	13 96       	adiw	r26, 0x03	; 3
     d06:	9c 93       	st	X, r25
     d08:	8e 93       	st	-X, r24
     d0a:	12 97       	sbiw	r26, 0x02	; 2
     d0c:	20 30       	cpi	r18, 0x00	; 0
     d0e:	80 e0       	ldi	r24, 0x00	; 0
     d10:	38 07       	cpc	r19, r24
     d12:	80 e0       	ldi	r24, 0x00	; 0
     d14:	48 07       	cpc	r20, r24
     d16:	80 e4       	ldi	r24, 0x40	; 64
     d18:	58 07       	cpc	r21, r24
     d1a:	58 f3       	brcs	.-42     	; 0xcf2 <__unpack_f+0x66>
     d1c:	14 96       	adiw	r26, 0x04	; 4
     d1e:	2d 93       	st	X+, r18
     d20:	3d 93       	st	X+, r19
     d22:	4d 93       	st	X+, r20
     d24:	5c 93       	st	X, r21
     d26:	17 97       	sbiw	r26, 0x07	; 7
     d28:	08 95       	ret
     d2a:	2f 3f       	cpi	r18, 0xFF	; 255
     d2c:	31 05       	cpc	r19, r1
     d2e:	79 f4       	brne	.+30     	; 0xd4e <__unpack_f+0xc2>
     d30:	41 15       	cp	r20, r1
     d32:	51 05       	cpc	r21, r1
     d34:	61 05       	cpc	r22, r1
     d36:	71 05       	cpc	r23, r1
     d38:	19 f4       	brne	.+6      	; 0xd40 <__unpack_f+0xb4>
     d3a:	84 e0       	ldi	r24, 0x04	; 4
     d3c:	8c 93       	st	X, r24
     d3e:	08 95       	ret
     d40:	64 ff       	sbrs	r22, 4
     d42:	03 c0       	rjmp	.+6      	; 0xd4a <__unpack_f+0xbe>
     d44:	81 e0       	ldi	r24, 0x01	; 1
     d46:	8c 93       	st	X, r24
     d48:	12 c0       	rjmp	.+36     	; 0xd6e <__unpack_f+0xe2>
     d4a:	1c 92       	st	X, r1
     d4c:	10 c0       	rjmp	.+32     	; 0xd6e <__unpack_f+0xe2>
     d4e:	2f 57       	subi	r18, 0x7F	; 127
     d50:	30 40       	sbci	r19, 0x00	; 0
     d52:	13 96       	adiw	r26, 0x03	; 3
     d54:	3c 93       	st	X, r19
     d56:	2e 93       	st	-X, r18
     d58:	12 97       	sbiw	r26, 0x02	; 2
     d5a:	83 e0       	ldi	r24, 0x03	; 3
     d5c:	8c 93       	st	X, r24
     d5e:	87 e0       	ldi	r24, 0x07	; 7
     d60:	44 0f       	add	r20, r20
     d62:	55 1f       	adc	r21, r21
     d64:	66 1f       	adc	r22, r22
     d66:	77 1f       	adc	r23, r23
     d68:	8a 95       	dec	r24
     d6a:	d1 f7       	brne	.-12     	; 0xd60 <__unpack_f+0xd4>
     d6c:	70 64       	ori	r23, 0x40	; 64
     d6e:	14 96       	adiw	r26, 0x04	; 4
     d70:	4d 93       	st	X+, r20
     d72:	5d 93       	st	X+, r21
     d74:	6d 93       	st	X+, r22
     d76:	7c 93       	st	X, r23
     d78:	17 97       	sbiw	r26, 0x07	; 7
     d7a:	08 95       	ret

00000d7c <__fpcmp_parts_f>:
     d7c:	1f 93       	push	r17
     d7e:	dc 01       	movw	r26, r24
     d80:	fb 01       	movw	r30, r22
     d82:	9c 91       	ld	r25, X
     d84:	92 30       	cpi	r25, 0x02	; 2
     d86:	08 f4       	brcc	.+2      	; 0xd8a <__fpcmp_parts_f+0xe>
     d88:	47 c0       	rjmp	.+142    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d8a:	80 81       	ld	r24, Z
     d8c:	82 30       	cpi	r24, 0x02	; 2
     d8e:	08 f4       	brcc	.+2      	; 0xd92 <__fpcmp_parts_f+0x16>
     d90:	43 c0       	rjmp	.+134    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d92:	94 30       	cpi	r25, 0x04	; 4
     d94:	51 f4       	brne	.+20     	; 0xdaa <__fpcmp_parts_f+0x2e>
     d96:	11 96       	adiw	r26, 0x01	; 1
     d98:	1c 91       	ld	r17, X
     d9a:	84 30       	cpi	r24, 0x04	; 4
     d9c:	99 f5       	brne	.+102    	; 0xe04 <__fpcmp_parts_f+0x88>
     d9e:	81 81       	ldd	r24, Z+1	; 0x01
     da0:	68 2f       	mov	r22, r24
     da2:	70 e0       	ldi	r23, 0x00	; 0
     da4:	61 1b       	sub	r22, r17
     da6:	71 09       	sbc	r23, r1
     da8:	3f c0       	rjmp	.+126    	; 0xe28 <__fpcmp_parts_f+0xac>
     daa:	84 30       	cpi	r24, 0x04	; 4
     dac:	21 f0       	breq	.+8      	; 0xdb6 <__fpcmp_parts_f+0x3a>
     dae:	92 30       	cpi	r25, 0x02	; 2
     db0:	31 f4       	brne	.+12     	; 0xdbe <__fpcmp_parts_f+0x42>
     db2:	82 30       	cpi	r24, 0x02	; 2
     db4:	b9 f1       	breq	.+110    	; 0xe24 <__fpcmp_parts_f+0xa8>
     db6:	81 81       	ldd	r24, Z+1	; 0x01
     db8:	88 23       	and	r24, r24
     dba:	89 f1       	breq	.+98     	; 0xe1e <__fpcmp_parts_f+0xa2>
     dbc:	2d c0       	rjmp	.+90     	; 0xe18 <__fpcmp_parts_f+0x9c>
     dbe:	11 96       	adiw	r26, 0x01	; 1
     dc0:	1c 91       	ld	r17, X
     dc2:	11 97       	sbiw	r26, 0x01	; 1
     dc4:	82 30       	cpi	r24, 0x02	; 2
     dc6:	f1 f0       	breq	.+60     	; 0xe04 <__fpcmp_parts_f+0x88>
     dc8:	81 81       	ldd	r24, Z+1	; 0x01
     dca:	18 17       	cp	r17, r24
     dcc:	d9 f4       	brne	.+54     	; 0xe04 <__fpcmp_parts_f+0x88>
     dce:	12 96       	adiw	r26, 0x02	; 2
     dd0:	2d 91       	ld	r18, X+
     dd2:	3c 91       	ld	r19, X
     dd4:	13 97       	sbiw	r26, 0x03	; 3
     dd6:	82 81       	ldd	r24, Z+2	; 0x02
     dd8:	93 81       	ldd	r25, Z+3	; 0x03
     dda:	82 17       	cp	r24, r18
     ddc:	93 07       	cpc	r25, r19
     dde:	94 f0       	brlt	.+36     	; 0xe04 <__fpcmp_parts_f+0x88>
     de0:	28 17       	cp	r18, r24
     de2:	39 07       	cpc	r19, r25
     de4:	bc f0       	brlt	.+46     	; 0xe14 <__fpcmp_parts_f+0x98>
     de6:	14 96       	adiw	r26, 0x04	; 4
     de8:	8d 91       	ld	r24, X+
     dea:	9d 91       	ld	r25, X+
     dec:	0d 90       	ld	r0, X+
     dee:	bc 91       	ld	r27, X
     df0:	a0 2d       	mov	r26, r0
     df2:	24 81       	ldd	r18, Z+4	; 0x04
     df4:	35 81       	ldd	r19, Z+5	; 0x05
     df6:	46 81       	ldd	r20, Z+6	; 0x06
     df8:	57 81       	ldd	r21, Z+7	; 0x07
     dfa:	28 17       	cp	r18, r24
     dfc:	39 07       	cpc	r19, r25
     dfe:	4a 07       	cpc	r20, r26
     e00:	5b 07       	cpc	r21, r27
     e02:	18 f4       	brcc	.+6      	; 0xe0a <__fpcmp_parts_f+0x8e>
     e04:	11 23       	and	r17, r17
     e06:	41 f0       	breq	.+16     	; 0xe18 <__fpcmp_parts_f+0x9c>
     e08:	0a c0       	rjmp	.+20     	; 0xe1e <__fpcmp_parts_f+0xa2>
     e0a:	82 17       	cp	r24, r18
     e0c:	93 07       	cpc	r25, r19
     e0e:	a4 07       	cpc	r26, r20
     e10:	b5 07       	cpc	r27, r21
     e12:	40 f4       	brcc	.+16     	; 0xe24 <__fpcmp_parts_f+0xa8>
     e14:	11 23       	and	r17, r17
     e16:	19 f0       	breq	.+6      	; 0xe1e <__fpcmp_parts_f+0xa2>
     e18:	61 e0       	ldi	r22, 0x01	; 1
     e1a:	70 e0       	ldi	r23, 0x00	; 0
     e1c:	05 c0       	rjmp	.+10     	; 0xe28 <__fpcmp_parts_f+0xac>
     e1e:	6f ef       	ldi	r22, 0xFF	; 255
     e20:	7f ef       	ldi	r23, 0xFF	; 255
     e22:	02 c0       	rjmp	.+4      	; 0xe28 <__fpcmp_parts_f+0xac>
     e24:	60 e0       	ldi	r22, 0x00	; 0
     e26:	70 e0       	ldi	r23, 0x00	; 0
     e28:	cb 01       	movw	r24, r22
     e2a:	1f 91       	pop	r17
     e2c:	08 95       	ret

00000e2e <UART_init>:
 * Functional responsible for Initialize the UART device by:
 * 1. Setup the Frame format like number of data bits, parity bit type and number of stop bits.
 * 2. Enable the UART.
 * 3. Setup the UART baud rate.
 */
void UART_init(const UART_ConfigType *Config_Ptr) {
     e2e:	df 93       	push	r29
     e30:	cf 93       	push	r28
     e32:	00 d0       	rcall	.+0      	; 0xe34 <UART_init+0x6>
     e34:	00 d0       	rcall	.+0      	; 0xe36 <UART_init+0x8>
     e36:	cd b7       	in	r28, 0x3d	; 61
     e38:	de b7       	in	r29, 0x3e	; 62
     e3a:	9c 83       	std	Y+4, r25	; 0x04
     e3c:	8b 83       	std	Y+3, r24	; 0x03
	uint16 ubrr_value = 0;
     e3e:	1a 82       	std	Y+2, r1	; 0x02
     e40:	19 82       	std	Y+1, r1	; 0x01

	/* U2X = 1 for double transmission speed */
	UCSRA.Bits.U2X = 1;
     e42:	eb e2       	ldi	r30, 0x2B	; 43
     e44:	f0 e0       	ldi	r31, 0x00	; 0
     e46:	80 81       	ld	r24, Z
     e48:	82 60       	ori	r24, 0x02	; 2
     e4a:	80 83       	st	Z, r24
	 * RXEN  = 1 Receiver Enable
	 * RXEN  = 1 Transmitter Enable
	 * UCSZ2 = 0 For 8-bit data mode
	 * RXB8 & TXB8 not used for 8-bit data mode
	 ***********************************************************************/
	UCSRB.Bits.RXEN = 1;
     e4c:	ea e2       	ldi	r30, 0x2A	; 42
     e4e:	f0 e0       	ldi	r31, 0x00	; 0
     e50:	80 81       	ld	r24, Z
     e52:	80 61       	ori	r24, 0x10	; 16
     e54:	80 83       	st	Z, r24
	UCSRB.Bits.TXEN = 1;
     e56:	ea e2       	ldi	r30, 0x2A	; 42
     e58:	f0 e0       	ldi	r31, 0x00	; 0
     e5a:	80 81       	ld	r24, Z
     e5c:	88 60       	ori	r24, 0x08	; 8
     e5e:	80 83       	st	Z, r24
	UCSRB.Bits.UCSZ2 = (((Config_Ptr->bit_data) & 0x04) >> 2);
     e60:	aa e2       	ldi	r26, 0x2A	; 42
     e62:	b0 e0       	ldi	r27, 0x00	; 0
     e64:	eb 81       	ldd	r30, Y+3	; 0x03
     e66:	fc 81       	ldd	r31, Y+4	; 0x04
     e68:	80 81       	ld	r24, Z
     e6a:	88 2f       	mov	r24, r24
     e6c:	90 e0       	ldi	r25, 0x00	; 0
     e6e:	84 70       	andi	r24, 0x04	; 4
     e70:	90 70       	andi	r25, 0x00	; 0
     e72:	95 95       	asr	r25
     e74:	87 95       	ror	r24
     e76:	95 95       	asr	r25
     e78:	87 95       	ror	r24
     e7a:	81 70       	andi	r24, 0x01	; 1
     e7c:	81 70       	andi	r24, 0x01	; 1
     e7e:	98 2f       	mov	r25, r24
     e80:	99 0f       	add	r25, r25
     e82:	99 0f       	add	r25, r25
     e84:	8c 91       	ld	r24, X
     e86:	8b 7f       	andi	r24, 0xFB	; 251
     e88:	89 2b       	or	r24, r25
     e8a:	8c 93       	st	X, r24
	 * UCSZ1:0 = 11 For 8-bit data mode
	 * UCPOL   = 0 Used with the Synchronous operation only
	 * 011
	 *
	 ***********************************************************************/
	UCSRC.Bits.URSEL = 1;
     e8c:	e0 e4       	ldi	r30, 0x40	; 64
     e8e:	f0 e0       	ldi	r31, 0x00	; 0
     e90:	80 81       	ld	r24, Z
     e92:	80 68       	ori	r24, 0x80	; 128
     e94:	80 83       	st	Z, r24
	UCSRC.Bits.UCSZ01 = ((Config_Ptr->bit_data) & (0x03));
     e96:	a0 e4       	ldi	r26, 0x40	; 64
     e98:	b0 e0       	ldi	r27, 0x00	; 0
     e9a:	eb 81       	ldd	r30, Y+3	; 0x03
     e9c:	fc 81       	ldd	r31, Y+4	; 0x04
     e9e:	80 81       	ld	r24, Z
     ea0:	83 70       	andi	r24, 0x03	; 3
     ea2:	83 70       	andi	r24, 0x03	; 3
     ea4:	83 70       	andi	r24, 0x03	; 3
     ea6:	83 70       	andi	r24, 0x03	; 3
     ea8:	98 2f       	mov	r25, r24
     eaa:	99 0f       	add	r25, r25
     eac:	8c 91       	ld	r24, X
     eae:	89 7f       	andi	r24, 0xF9	; 249
     eb0:	89 2b       	or	r24, r25
     eb2:	8c 93       	st	X, r24
	UCSRC.Bits.USBS = Config_Ptr->stop_bit;
     eb4:	a0 e4       	ldi	r26, 0x40	; 64
     eb6:	b0 e0       	ldi	r27, 0x00	; 0
     eb8:	eb 81       	ldd	r30, Y+3	; 0x03
     eba:	fc 81       	ldd	r31, Y+4	; 0x04
     ebc:	82 81       	ldd	r24, Z+2	; 0x02
     ebe:	81 70       	andi	r24, 0x01	; 1
     ec0:	81 70       	andi	r24, 0x01	; 1
     ec2:	98 2f       	mov	r25, r24
     ec4:	99 0f       	add	r25, r25
     ec6:	99 0f       	add	r25, r25
     ec8:	99 0f       	add	r25, r25
     eca:	8c 91       	ld	r24, X
     ecc:	87 7f       	andi	r24, 0xF7	; 247
     ece:	89 2b       	or	r24, r25
     ed0:	8c 93       	st	X, r24
	UCSRC.Bits.UPM01 = Config_Ptr->parity;
     ed2:	a0 e4       	ldi	r26, 0x40	; 64
     ed4:	b0 e0       	ldi	r27, 0x00	; 0
     ed6:	eb 81       	ldd	r30, Y+3	; 0x03
     ed8:	fc 81       	ldd	r31, Y+4	; 0x04
     eda:	81 81       	ldd	r24, Z+1	; 0x01
     edc:	83 70       	andi	r24, 0x03	; 3
     ede:	83 70       	andi	r24, 0x03	; 3
     ee0:	98 2f       	mov	r25, r24
     ee2:	92 95       	swap	r25
     ee4:	90 7f       	andi	r25, 0xF0	; 240
     ee6:	8c 91       	ld	r24, X
     ee8:	8f 7c       	andi	r24, 0xCF	; 207
     eea:	89 2b       	or	r24, r25
     eec:	8c 93       	st	X, r24
	/* Calculate the UBRR register value */
	ubrr_value = (uint16) (((F_CPU / ((Config_Ptr->baud_rate) * 8UL))) - 1);
     eee:	eb 81       	ldd	r30, Y+3	; 0x03
     ef0:	fc 81       	ldd	r31, Y+4	; 0x04
     ef2:	83 81       	ldd	r24, Z+3	; 0x03
     ef4:	94 81       	ldd	r25, Z+4	; 0x04
     ef6:	cc 01       	movw	r24, r24
     ef8:	a0 e0       	ldi	r26, 0x00	; 0
     efa:	b0 e0       	ldi	r27, 0x00	; 0
     efc:	88 0f       	add	r24, r24
     efe:	99 1f       	adc	r25, r25
     f00:	aa 1f       	adc	r26, r26
     f02:	bb 1f       	adc	r27, r27
     f04:	88 0f       	add	r24, r24
     f06:	99 1f       	adc	r25, r25
     f08:	aa 1f       	adc	r26, r26
     f0a:	bb 1f       	adc	r27, r27
     f0c:	88 0f       	add	r24, r24
     f0e:	99 1f       	adc	r25, r25
     f10:	aa 1f       	adc	r26, r26
     f12:	bb 1f       	adc	r27, r27
     f14:	9c 01       	movw	r18, r24
     f16:	ad 01       	movw	r20, r26
     f18:	80 e0       	ldi	r24, 0x00	; 0
     f1a:	92 e1       	ldi	r25, 0x12	; 18
     f1c:	aa e7       	ldi	r26, 0x7A	; 122
     f1e:	b0 e0       	ldi	r27, 0x00	; 0
     f20:	bc 01       	movw	r22, r24
     f22:	cd 01       	movw	r24, r26
     f24:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__udivmodsi4>
     f28:	da 01       	movw	r26, r20
     f2a:	c9 01       	movw	r24, r18
     f2c:	01 97       	sbiw	r24, 0x01	; 1
     f2e:	9a 83       	std	Y+2, r25	; 0x02
     f30:	89 83       	std	Y+1, r24	; 0x01

	/* First 8 bits from the BAUD_PRESCALE inside UBRRL and last 4 bits in UBRRH*/
	UBRRH = ubrr_value >> 8;
     f32:	e0 e4       	ldi	r30, 0x40	; 64
     f34:	f0 e0       	ldi	r31, 0x00	; 0
     f36:	89 81       	ldd	r24, Y+1	; 0x01
     f38:	9a 81       	ldd	r25, Y+2	; 0x02
     f3a:	89 2f       	mov	r24, r25
     f3c:	99 27       	eor	r25, r25
     f3e:	80 83       	st	Z, r24
	UBRRL = ubrr_value;
     f40:	e9 e2       	ldi	r30, 0x29	; 41
     f42:	f0 e0       	ldi	r31, 0x00	; 0
     f44:	89 81       	ldd	r24, Y+1	; 0x01
     f46:	80 83       	st	Z, r24
}
     f48:	0f 90       	pop	r0
     f4a:	0f 90       	pop	r0
     f4c:	0f 90       	pop	r0
     f4e:	0f 90       	pop	r0
     f50:	cf 91       	pop	r28
     f52:	df 91       	pop	r29
     f54:	08 95       	ret

00000f56 <UART_sendByte>:

/*
 * Description :
 * Functional responsible for send byte to another UART device.
 */
void UART_sendByte(const uint8 data) {
     f56:	df 93       	push	r29
     f58:	cf 93       	push	r28
     f5a:	0f 92       	push	r0
     f5c:	cd b7       	in	r28, 0x3d	; 61
     f5e:	de b7       	in	r29, 0x3e	; 62
     f60:	89 83       	std	Y+1, r24	; 0x01
	/*
	 * UDRE flag is set when the Tx buffer (UDR) is empty and ready for
	 * transmitting a new byte so wait until this flag is set to one
	 */
	while (UCSRA.Bits.UDRE == 0) {
     f62:	eb e2       	ldi	r30, 0x2B	; 43
     f64:	f0 e0       	ldi	r31, 0x00	; 0
     f66:	80 81       	ld	r24, Z
     f68:	80 72       	andi	r24, 0x20	; 32
     f6a:	88 23       	and	r24, r24
     f6c:	d1 f3       	breq	.-12     	; 0xf62 <UART_sendByte+0xc>

	/*
	 * Put the required data in the UDR register and it also clear the UDRE flag as
	 * the UDR register is not empty now
	 */
	UDR = data;
     f6e:	ec e2       	ldi	r30, 0x2C	; 44
     f70:	f0 e0       	ldi	r31, 0x00	; 0
     f72:	89 81       	ldd	r24, Y+1	; 0x01
     f74:	80 83       	st	Z, r24
	/************************* Another Method *************************
	 UDR = data;
	 while(BIT_IS_CLEAR(UCSRA,TXC)){} // Wait until the transmission is complete TXC = 1
	 SET_BIT(UCSRA,TXC); // Clear the TXC flag
	 *******************************************************************/
}
     f76:	0f 90       	pop	r0
     f78:	cf 91       	pop	r28
     f7a:	df 91       	pop	r29
     f7c:	08 95       	ret

00000f7e <UART_recieveByte>:

/*
 * Description :
 * Functional responsible for receive byte from another UART device.
 */
uint8 UART_recieveByte(void) {
     f7e:	df 93       	push	r29
     f80:	cf 93       	push	r28
     f82:	cd b7       	in	r28, 0x3d	; 61
     f84:	de b7       	in	r29, 0x3e	; 62
	/* RXC flag is set when the UART receive data so wait until this flag is set to one */
	while (UCSRA.Bits.RXC == 0) {
     f86:	eb e2       	ldi	r30, 0x2B	; 43
     f88:	f0 e0       	ldi	r31, 0x00	; 0
     f8a:	80 81       	ld	r24, Z
     f8c:	80 78       	andi	r24, 0x80	; 128
     f8e:	88 23       	and	r24, r24
     f90:	d1 f3       	breq	.-12     	; 0xf86 <UART_recieveByte+0x8>

	/*
	 * Read the received data from the Rx buffer (UDR)
	 * The RXC flag will be cleared after read the data
	 */
	return UDR;
     f92:	ec e2       	ldi	r30, 0x2C	; 44
     f94:	f0 e0       	ldi	r31, 0x00	; 0
     f96:	80 81       	ld	r24, Z
}
     f98:	cf 91       	pop	r28
     f9a:	df 91       	pop	r29
     f9c:	08 95       	ret

00000f9e <UART_sendString>:

/*
 * Description :
 * Send the required string through UART to the other UART device.
 */
void UART_sendString(const uint8 *Str) {
     f9e:	df 93       	push	r29
     fa0:	cf 93       	push	r28
     fa2:	00 d0       	rcall	.+0      	; 0xfa4 <UART_sendString+0x6>
     fa4:	0f 92       	push	r0
     fa6:	cd b7       	in	r28, 0x3d	; 61
     fa8:	de b7       	in	r29, 0x3e	; 62
     faa:	9b 83       	std	Y+3, r25	; 0x03
     fac:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
     fae:	19 82       	std	Y+1, r1	; 0x01
     fb0:	0e c0       	rjmp	.+28     	; 0xfce <UART_sendString+0x30>

	/* Send the whole string */
	while (Str[i] != '\0') {
		UART_sendByte(Str[i]);
     fb2:	89 81       	ldd	r24, Y+1	; 0x01
     fb4:	28 2f       	mov	r18, r24
     fb6:	30 e0       	ldi	r19, 0x00	; 0
     fb8:	8a 81       	ldd	r24, Y+2	; 0x02
     fba:	9b 81       	ldd	r25, Y+3	; 0x03
     fbc:	fc 01       	movw	r30, r24
     fbe:	e2 0f       	add	r30, r18
     fc0:	f3 1f       	adc	r31, r19
     fc2:	80 81       	ld	r24, Z
     fc4:	0e 94 ab 07 	call	0xf56	; 0xf56 <UART_sendByte>
		i++;
     fc8:	89 81       	ldd	r24, Y+1	; 0x01
     fca:	8f 5f       	subi	r24, 0xFF	; 255
     fcc:	89 83       	std	Y+1, r24	; 0x01
 */
void UART_sendString(const uint8 *Str) {
	uint8 i = 0;

	/* Send the whole string */
	while (Str[i] != '\0') {
     fce:	89 81       	ldd	r24, Y+1	; 0x01
     fd0:	28 2f       	mov	r18, r24
     fd2:	30 e0       	ldi	r19, 0x00	; 0
     fd4:	8a 81       	ldd	r24, Y+2	; 0x02
     fd6:	9b 81       	ldd	r25, Y+3	; 0x03
     fd8:	fc 01       	movw	r30, r24
     fda:	e2 0f       	add	r30, r18
     fdc:	f3 1f       	adc	r31, r19
     fde:	80 81       	ld	r24, Z
     fe0:	88 23       	and	r24, r24
     fe2:	39 f7       	brne	.-50     	; 0xfb2 <UART_sendString+0x14>
	 {
	 UART_sendByte(*Str);
	 Str++;
	 }
	 *******************************************************************/
}
     fe4:	0f 90       	pop	r0
     fe6:	0f 90       	pop	r0
     fe8:	0f 90       	pop	r0
     fea:	cf 91       	pop	r28
     fec:	df 91       	pop	r29
     fee:	08 95       	ret

00000ff0 <UART_receiveString>:

/*
 * Description :
 * Receive the required string until the '#' symbol through UART from the other UART device.
 */
void UART_receiveString(uint8 *Str) {
     ff0:	0f 93       	push	r16
     ff2:	1f 93       	push	r17
     ff4:	df 93       	push	r29
     ff6:	cf 93       	push	r28
     ff8:	00 d0       	rcall	.+0      	; 0xffa <UART_receiveString+0xa>
     ffa:	0f 92       	push	r0
     ffc:	cd b7       	in	r28, 0x3d	; 61
     ffe:	de b7       	in	r29, 0x3e	; 62
    1000:	9b 83       	std	Y+3, r25	; 0x03
    1002:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    1004:	19 82       	std	Y+1, r1	; 0x01

	/* Receive the first byte */
	Str[i] = UART_recieveByte();
    1006:	89 81       	ldd	r24, Y+1	; 0x01
    1008:	28 2f       	mov	r18, r24
    100a:	30 e0       	ldi	r19, 0x00	; 0
    100c:	8a 81       	ldd	r24, Y+2	; 0x02
    100e:	9b 81       	ldd	r25, Y+3	; 0x03
    1010:	8c 01       	movw	r16, r24
    1012:	02 0f       	add	r16, r18
    1014:	13 1f       	adc	r17, r19
    1016:	0e 94 bf 07 	call	0xf7e	; 0xf7e <UART_recieveByte>
    101a:	f8 01       	movw	r30, r16
    101c:	80 83       	st	Z, r24
    101e:	0f c0       	rjmp	.+30     	; 0x103e <UART_receiveString+0x4e>

	/* Receive the whole string until the '#' */
	while (Str[i] != '#') {
		i++;
    1020:	89 81       	ldd	r24, Y+1	; 0x01
    1022:	8f 5f       	subi	r24, 0xFF	; 255
    1024:	89 83       	std	Y+1, r24	; 0x01
		Str[i] = UART_recieveByte();
    1026:	89 81       	ldd	r24, Y+1	; 0x01
    1028:	28 2f       	mov	r18, r24
    102a:	30 e0       	ldi	r19, 0x00	; 0
    102c:	8a 81       	ldd	r24, Y+2	; 0x02
    102e:	9b 81       	ldd	r25, Y+3	; 0x03
    1030:	8c 01       	movw	r16, r24
    1032:	02 0f       	add	r16, r18
    1034:	13 1f       	adc	r17, r19
    1036:	0e 94 bf 07 	call	0xf7e	; 0xf7e <UART_recieveByte>
    103a:	f8 01       	movw	r30, r16
    103c:	80 83       	st	Z, r24

	/* Receive the first byte */
	Str[i] = UART_recieveByte();

	/* Receive the whole string until the '#' */
	while (Str[i] != '#') {
    103e:	89 81       	ldd	r24, Y+1	; 0x01
    1040:	28 2f       	mov	r18, r24
    1042:	30 e0       	ldi	r19, 0x00	; 0
    1044:	8a 81       	ldd	r24, Y+2	; 0x02
    1046:	9b 81       	ldd	r25, Y+3	; 0x03
    1048:	fc 01       	movw	r30, r24
    104a:	e2 0f       	add	r30, r18
    104c:	f3 1f       	adc	r31, r19
    104e:	80 81       	ld	r24, Z
    1050:	83 32       	cpi	r24, 0x23	; 35
    1052:	31 f7       	brne	.-52     	; 0x1020 <UART_receiveString+0x30>
		i++;
		Str[i] = UART_recieveByte();
	}

	/* After receiving the whole string plus the '#', replace the '#' with '\0' */
	Str[i] = '\0';
    1054:	89 81       	ldd	r24, Y+1	; 0x01
    1056:	28 2f       	mov	r18, r24
    1058:	30 e0       	ldi	r19, 0x00	; 0
    105a:	8a 81       	ldd	r24, Y+2	; 0x02
    105c:	9b 81       	ldd	r25, Y+3	; 0x03
    105e:	fc 01       	movw	r30, r24
    1060:	e2 0f       	add	r30, r18
    1062:	f3 1f       	adc	r31, r19
    1064:	10 82       	st	Z, r1
}
    1066:	0f 90       	pop	r0
    1068:	0f 90       	pop	r0
    106a:	0f 90       	pop	r0
    106c:	cf 91       	pop	r28
    106e:	df 91       	pop	r29
    1070:	1f 91       	pop	r17
    1072:	0f 91       	pop	r16
    1074:	08 95       	ret

00001076 <TWI_init>:
 ===================================================
 */
#include "twi.h"
#include "../../lib/common_macros.h"
#include "twi_Reg.h"
void TWI_init(const TWI_ConfigType *Config_Ptr) {
    1076:	cf 92       	push	r12
    1078:	df 92       	push	r13
    107a:	ef 92       	push	r14
    107c:	ff 92       	push	r15
    107e:	0f 93       	push	r16
    1080:	1f 93       	push	r17
    1082:	df 93       	push	r29
    1084:	cf 93       	push	r28
    1086:	00 d0       	rcall	.+0      	; 0x1088 <TWI_init+0x12>
    1088:	00 d0       	rcall	.+0      	; 0x108a <TWI_init+0x14>
    108a:	cd b7       	in	r28, 0x3d	; 61
    108c:	de b7       	in	r29, 0x3e	; 62
    108e:	9a 83       	std	Y+2, r25	; 0x02
    1090:	89 83       	std	Y+1, r24	; 0x01
	/*Fscl = Fcpu/16+2*TWBR*4^TWPS
	 *TWBR = (((Fscl/Fcpu)-16)/(2*Prescaler))*/
	/*calc the value should put in Twi*/
	TWBR = ((((F_CPU) / (Config_Ptr->bit_rate)) - 16)
    1092:	cc 24       	eor	r12, r12
    1094:	dd 24       	eor	r13, r13
    1096:	68 94       	set
    1098:	c5 f8       	bld	r12, 5
    109a:	e9 81       	ldd	r30, Y+1	; 0x01
    109c:	fa 81       	ldd	r31, Y+2	; 0x02
    109e:	20 81       	ld	r18, Z
    10a0:	31 81       	ldd	r19, Z+1	; 0x01
    10a2:	42 81       	ldd	r20, Z+2	; 0x02
    10a4:	53 81       	ldd	r21, Z+3	; 0x03
    10a6:	80 e0       	ldi	r24, 0x00	; 0
    10a8:	92 e1       	ldi	r25, 0x12	; 18
    10aa:	aa e7       	ldi	r26, 0x7A	; 122
    10ac:	b0 e0       	ldi	r27, 0x00	; 0
    10ae:	bc 01       	movw	r22, r24
    10b0:	cd 01       	movw	r24, r26
    10b2:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__udivmodsi4>
    10b6:	da 01       	movw	r26, r20
    10b8:	c9 01       	movw	r24, r18
    10ba:	0f 2e       	mov	r0, r31
    10bc:	f0 ef       	ldi	r31, 0xF0	; 240
    10be:	ef 2e       	mov	r14, r31
    10c0:	ff ef       	ldi	r31, 0xFF	; 255
    10c2:	ff 2e       	mov	r15, r31
    10c4:	ff ef       	ldi	r31, 0xFF	; 255
    10c6:	0f 2f       	mov	r16, r31
    10c8:	ff ef       	ldi	r31, 0xFF	; 255
    10ca:	1f 2f       	mov	r17, r31
    10cc:	f0 2d       	mov	r31, r0
    10ce:	e8 0e       	add	r14, r24
    10d0:	f9 1e       	adc	r15, r25
    10d2:	0a 1f       	adc	r16, r26
    10d4:	1b 1f       	adc	r17, r27
    10d6:	e9 81       	ldd	r30, Y+1	; 0x01
    10d8:	fa 81       	ldd	r31, Y+2	; 0x02
    10da:	85 81       	ldd	r24, Z+5	; 0x05
    10dc:	88 2f       	mov	r24, r24
    10de:	90 e0       	ldi	r25, 0x00	; 0
    10e0:	88 0f       	add	r24, r24
    10e2:	99 1f       	adc	r25, r25
    10e4:	9c 01       	movw	r18, r24
    10e6:	44 27       	eor	r20, r20
    10e8:	37 fd       	sbrc	r19, 7
    10ea:	40 95       	com	r20
    10ec:	54 2f       	mov	r21, r20
    10ee:	c8 01       	movw	r24, r16
    10f0:	b7 01       	movw	r22, r14
    10f2:	0e 94 a9 1c 	call	0x3952	; 0x3952 <__udivmodsi4>
    10f6:	da 01       	movw	r26, r20
    10f8:	c9 01       	movw	r24, r18
    10fa:	f6 01       	movw	r30, r12
    10fc:	80 83       	st	Z, r24
			/ (2 * Config_Ptr->Prescaler));

	switch (Config_Ptr->Prescaler) {
    10fe:	e9 81       	ldd	r30, Y+1	; 0x01
    1100:	fa 81       	ldd	r31, Y+2	; 0x02
    1102:	85 81       	ldd	r24, Z+5	; 0x05
    1104:	28 2f       	mov	r18, r24
    1106:	30 e0       	ldi	r19, 0x00	; 0
    1108:	3c 83       	std	Y+4, r19	; 0x04
    110a:	2b 83       	std	Y+3, r18	; 0x03
    110c:	8b 81       	ldd	r24, Y+3	; 0x03
    110e:	9c 81       	ldd	r25, Y+4	; 0x04
    1110:	84 30       	cpi	r24, 0x04	; 4
    1112:	91 05       	cpc	r25, r1
    1114:	d1 f0       	breq	.+52     	; 0x114a <TWI_init+0xd4>
    1116:	eb 81       	ldd	r30, Y+3	; 0x03
    1118:	fc 81       	ldd	r31, Y+4	; 0x04
    111a:	e5 30       	cpi	r30, 0x05	; 5
    111c:	f1 05       	cpc	r31, r1
    111e:	34 f4       	brge	.+12     	; 0x112c <TWI_init+0xb6>
    1120:	2b 81       	ldd	r18, Y+3	; 0x03
    1122:	3c 81       	ldd	r19, Y+4	; 0x04
    1124:	21 30       	cpi	r18, 0x01	; 1
    1126:	31 05       	cpc	r19, r1
    1128:	61 f0       	breq	.+24     	; 0x1142 <TWI_init+0xcc>
    112a:	1d c0       	rjmp	.+58     	; 0x1166 <TWI_init+0xf0>
    112c:	8b 81       	ldd	r24, Y+3	; 0x03
    112e:	9c 81       	ldd	r25, Y+4	; 0x04
    1130:	80 31       	cpi	r24, 0x10	; 16
    1132:	91 05       	cpc	r25, r1
    1134:	79 f0       	breq	.+30     	; 0x1154 <TWI_init+0xde>
    1136:	eb 81       	ldd	r30, Y+3	; 0x03
    1138:	fc 81       	ldd	r31, Y+4	; 0x04
    113a:	e0 34       	cpi	r30, 0x40	; 64
    113c:	f1 05       	cpc	r31, r1
    113e:	79 f0       	breq	.+30     	; 0x115e <TWI_init+0xe8>
    1140:	12 c0       	rjmp	.+36     	; 0x1166 <TWI_init+0xf0>
	case 1:
		TWSR = 0x00;
    1142:	e1 e2       	ldi	r30, 0x21	; 33
    1144:	f0 e0       	ldi	r31, 0x00	; 0
    1146:	10 82       	st	Z, r1
    1148:	0e c0       	rjmp	.+28     	; 0x1166 <TWI_init+0xf0>

		break;
	case 4:
		TWSR = 0x01;
    114a:	e1 e2       	ldi	r30, 0x21	; 33
    114c:	f0 e0       	ldi	r31, 0x00	; 0
    114e:	81 e0       	ldi	r24, 0x01	; 1
    1150:	80 83       	st	Z, r24
    1152:	09 c0       	rjmp	.+18     	; 0x1166 <TWI_init+0xf0>

		break;
	case 16:
		TWSR = 0x02;
    1154:	e1 e2       	ldi	r30, 0x21	; 33
    1156:	f0 e0       	ldi	r31, 0x00	; 0
    1158:	82 e0       	ldi	r24, 0x02	; 2
    115a:	80 83       	st	Z, r24
    115c:	04 c0       	rjmp	.+8      	; 0x1166 <TWI_init+0xf0>

		break;
	case 64:
		TWSR = 0x03;
    115e:	e1 e2       	ldi	r30, 0x21	; 33
    1160:	f0 e0       	ldi	r31, 0x00	; 0
    1162:	83 e0       	ldi	r24, 0x03	; 3
    1164:	80 83       	st	Z, r24
	default:
		break;
	}
	/* Two Wire Bus address my address if any master device want to call me: 0x1 (used in case this MC is a slave device)
	 General Call Recognition: Off */
	TWAR.Bits.TWA0_6 = Config_Ptr->address; // my address = 0x01 :)
    1166:	a2 e2       	ldi	r26, 0x22	; 34
    1168:	b0 e0       	ldi	r27, 0x00	; 0
    116a:	e9 81       	ldd	r30, Y+1	; 0x01
    116c:	fa 81       	ldd	r31, Y+2	; 0x02
    116e:	84 81       	ldd	r24, Z+4	; 0x04
    1170:	8f 77       	andi	r24, 0x7F	; 127
    1172:	98 2f       	mov	r25, r24
    1174:	99 0f       	add	r25, r25
    1176:	8c 91       	ld	r24, X
    1178:	81 70       	andi	r24, 0x01	; 1
    117a:	89 2b       	or	r24, r25
    117c:	8c 93       	st	X, r24

	TWCR.Bits.TWEN = 1;/* enable TWI */
    117e:	e6 e5       	ldi	r30, 0x56	; 86
    1180:	f0 e0       	ldi	r31, 0x00	; 0
    1182:	80 81       	ld	r24, Z
    1184:	84 60       	ori	r24, 0x04	; 4
    1186:	80 83       	st	Z, r24

}
    1188:	0f 90       	pop	r0
    118a:	0f 90       	pop	r0
    118c:	0f 90       	pop	r0
    118e:	0f 90       	pop	r0
    1190:	cf 91       	pop	r28
    1192:	df 91       	pop	r29
    1194:	1f 91       	pop	r17
    1196:	0f 91       	pop	r16
    1198:	ff 90       	pop	r15
    119a:	ef 90       	pop	r14
    119c:	df 90       	pop	r13
    119e:	cf 90       	pop	r12
    11a0:	08 95       	ret

000011a2 <TWI_start>:

void TWI_start(void) {
    11a2:	df 93       	push	r29
    11a4:	cf 93       	push	r28
    11a6:	cd b7       	in	r28, 0x3d	; 61
    11a8:	de b7       	in	r29, 0x3e	; 62
	 * Clear the TWINT flag before sending the start bit TWINT=1
	 * send the start bit by TWSTA=1
	 * Enable TWI Module TWEN=1
	 */
	/*TWCR.Byte=0xA4;*/
	TWCR.Bits.TWSTA = 1;
    11aa:	e6 e5       	ldi	r30, 0x56	; 86
    11ac:	f0 e0       	ldi	r31, 0x00	; 0
    11ae:	80 81       	ld	r24, Z
    11b0:	80 62       	ori	r24, 0x20	; 32
    11b2:	80 83       	st	Z, r24
	TWCR.Bits.TWEA = 0;
    11b4:	e6 e5       	ldi	r30, 0x56	; 86
    11b6:	f0 e0       	ldi	r31, 0x00	; 0
    11b8:	80 81       	ld	r24, Z
    11ba:	8f 7b       	andi	r24, 0xBF	; 191
    11bc:	80 83       	st	Z, r24
	TWCR.Bits.TWSTO = 0;
    11be:	e6 e5       	ldi	r30, 0x56	; 86
    11c0:	f0 e0       	ldi	r31, 0x00	; 0
    11c2:	80 81       	ld	r24, Z
    11c4:	8f 7e       	andi	r24, 0xEF	; 239
    11c6:	80 83       	st	Z, r24
	TWCR.Bits.TWIE = 0;
    11c8:	e6 e5       	ldi	r30, 0x56	; 86
    11ca:	f0 e0       	ldi	r31, 0x00	; 0
    11cc:	80 81       	ld	r24, Z
    11ce:	8e 7f       	andi	r24, 0xFE	; 254
    11d0:	80 83       	st	Z, r24
	TWCR.Bits.TWWC = 0;
    11d2:	e6 e5       	ldi	r30, 0x56	; 86
    11d4:	f0 e0       	ldi	r31, 0x00	; 0
    11d6:	80 81       	ld	r24, Z
    11d8:	87 7f       	andi	r24, 0xF7	; 247
    11da:	80 83       	st	Z, r24
	TWCR.Bits.TWINT = 1;
    11dc:	e6 e5       	ldi	r30, 0x56	; 86
    11de:	f0 e0       	ldi	r31, 0x00	; 0
    11e0:	80 81       	ld	r24, Z
    11e2:	80 68       	ori	r24, 0x80	; 128
    11e4:	80 83       	st	Z, r24
	/*TWCR.Bits.TWEN = 1;*/

	/* Wait for TWINT flag set in TWCR Register (start bit is send successfully) */
	while (TWCR.Bits.TWINT == 0)
    11e6:	e6 e5       	ldi	r30, 0x56	; 86
    11e8:	f0 e0       	ldi	r31, 0x00	; 0
    11ea:	80 81       	ld	r24, Z
    11ec:	80 78       	andi	r24, 0x80	; 128
    11ee:	88 23       	and	r24, r24
    11f0:	d1 f3       	breq	.-12     	; 0x11e6 <TWI_start+0x44>
		;

}
    11f2:	cf 91       	pop	r28
    11f4:	df 91       	pop	r29
    11f6:	08 95       	ret

000011f8 <TWI_stop>:

void TWI_stop(void) {
    11f8:	df 93       	push	r29
    11fa:	cf 93       	push	r28
    11fc:	cd b7       	in	r28, 0x3d	; 61
    11fe:	de b7       	in	r29, 0x3e	; 62
	 * Clear the TWINT flag before sending the stop bit TWINT=1
	 * send the stop bit by TWSTO=1
	 * Enable TWI Module TWEN=1
	 */
	//TWCR.Byte = 0x94;
	TWCR.Bits.TWSTA = 0;
    1200:	e6 e5       	ldi	r30, 0x56	; 86
    1202:	f0 e0       	ldi	r31, 0x00	; 0
    1204:	80 81       	ld	r24, Z
    1206:	8f 7d       	andi	r24, 0xDF	; 223
    1208:	80 83       	st	Z, r24
	TWCR.Bits.TWEA = 0;
    120a:	e6 e5       	ldi	r30, 0x56	; 86
    120c:	f0 e0       	ldi	r31, 0x00	; 0
    120e:	80 81       	ld	r24, Z
    1210:	8f 7b       	andi	r24, 0xBF	; 191
    1212:	80 83       	st	Z, r24
	TWCR.Bits.TWSTO = 1;
    1214:	e6 e5       	ldi	r30, 0x56	; 86
    1216:	f0 e0       	ldi	r31, 0x00	; 0
    1218:	80 81       	ld	r24, Z
    121a:	80 61       	ori	r24, 0x10	; 16
    121c:	80 83       	st	Z, r24
	TWCR.Bits.TWIE = 0;
    121e:	e6 e5       	ldi	r30, 0x56	; 86
    1220:	f0 e0       	ldi	r31, 0x00	; 0
    1222:	80 81       	ld	r24, Z
    1224:	8e 7f       	andi	r24, 0xFE	; 254
    1226:	80 83       	st	Z, r24
	TWCR.Bits.TWWC = 0;
    1228:	e6 e5       	ldi	r30, 0x56	; 86
    122a:	f0 e0       	ldi	r31, 0x00	; 0
    122c:	80 81       	ld	r24, Z
    122e:	87 7f       	andi	r24, 0xF7	; 247
    1230:	80 83       	st	Z, r24
	TWCR.Bits.TWINT = 1;
    1232:	e6 e5       	ldi	r30, 0x56	; 86
    1234:	f0 e0       	ldi	r31, 0x00	; 0
    1236:	80 81       	ld	r24, Z
    1238:	80 68       	ori	r24, 0x80	; 128
    123a:	80 83       	st	Z, r24
	//TWCR.Bits.TWEN = 1;

}
    123c:	cf 91       	pop	r28
    123e:	df 91       	pop	r29
    1240:	08 95       	ret

00001242 <TWI_writeByte>:

void TWI_writeByte(uint8 data) {
    1242:	df 93       	push	r29
    1244:	cf 93       	push	r28
    1246:	0f 92       	push	r0
    1248:	cd b7       	in	r28, 0x3d	; 61
    124a:	de b7       	in	r29, 0x3e	; 62
    124c:	89 83       	std	Y+1, r24	; 0x01
	/* Put data On TWI data Register */
	TWDR = data;
    124e:	e3 e2       	ldi	r30, 0x23	; 35
    1250:	f0 e0       	ldi	r31, 0x00	; 0
    1252:	89 81       	ldd	r24, Y+1	; 0x01
    1254:	80 83       	st	Z, r24
	/*
	 * Clear the TWINT flag before sending the data TWINT=1
	 * Enable TWI Module TWEN=1
	 */
	//TWCR.Byte = 0x84;
	TWCR.Bits.TWSTA = 0;
    1256:	e6 e5       	ldi	r30, 0x56	; 86
    1258:	f0 e0       	ldi	r31, 0x00	; 0
    125a:	80 81       	ld	r24, Z
    125c:	8f 7d       	andi	r24, 0xDF	; 223
    125e:	80 83       	st	Z, r24
	TWCR.Bits.TWEA = 0;
    1260:	e6 e5       	ldi	r30, 0x56	; 86
    1262:	f0 e0       	ldi	r31, 0x00	; 0
    1264:	80 81       	ld	r24, Z
    1266:	8f 7b       	andi	r24, 0xBF	; 191
    1268:	80 83       	st	Z, r24
	TWCR.Bits.TWSTO = 0;
    126a:	e6 e5       	ldi	r30, 0x56	; 86
    126c:	f0 e0       	ldi	r31, 0x00	; 0
    126e:	80 81       	ld	r24, Z
    1270:	8f 7e       	andi	r24, 0xEF	; 239
    1272:	80 83       	st	Z, r24
	TWCR.Bits.TWIE = 0;
    1274:	e6 e5       	ldi	r30, 0x56	; 86
    1276:	f0 e0       	ldi	r31, 0x00	; 0
    1278:	80 81       	ld	r24, Z
    127a:	8e 7f       	andi	r24, 0xFE	; 254
    127c:	80 83       	st	Z, r24
	TWCR.Bits.TWWC = 0;
    127e:	e6 e5       	ldi	r30, 0x56	; 86
    1280:	f0 e0       	ldi	r31, 0x00	; 0
    1282:	80 81       	ld	r24, Z
    1284:	87 7f       	andi	r24, 0xF7	; 247
    1286:	80 83       	st	Z, r24
	TWCR.Bits.TWINT = 1;
    1288:	e6 e5       	ldi	r30, 0x56	; 86
    128a:	f0 e0       	ldi	r31, 0x00	; 0
    128c:	80 81       	ld	r24, Z
    128e:	80 68       	ori	r24, 0x80	; 128
    1290:	80 83       	st	Z, r24
	//TWCR.Bits.TWEN = 1;
	/* Wait for TWINT flag set in TWCR Register(data is send successfully) */
	while (TWCR.Bits.TWINT == 0)
    1292:	e6 e5       	ldi	r30, 0x56	; 86
    1294:	f0 e0       	ldi	r31, 0x00	; 0
    1296:	80 81       	ld	r24, Z
    1298:	80 78       	andi	r24, 0x80	; 128
    129a:	88 23       	and	r24, r24
    129c:	d1 f3       	breq	.-12     	; 0x1292 <TWI_writeByte+0x50>
		;
}
    129e:	0f 90       	pop	r0
    12a0:	cf 91       	pop	r28
    12a2:	df 91       	pop	r29
    12a4:	08 95       	ret

000012a6 <TWI_readByteWithACK>:

uint8 TWI_readByteWithACK(void) {
    12a6:	df 93       	push	r29
    12a8:	cf 93       	push	r28
    12aa:	cd b7       	in	r28, 0x3d	; 61
    12ac:	de b7       	in	r29, 0x3e	; 62
	 * Clear the TWINT flag before reading the data TWINT=1
	 * Enable sending ACK after reading or receiving data TWEA=1
	 * Enable TWI Module TWEN=1
	 */
	//TWCR.Byte = 0xC4;
	TWCR.Bits.TWSTA = 0;
    12ae:	e6 e5       	ldi	r30, 0x56	; 86
    12b0:	f0 e0       	ldi	r31, 0x00	; 0
    12b2:	80 81       	ld	r24, Z
    12b4:	8f 7d       	andi	r24, 0xDF	; 223
    12b6:	80 83       	st	Z, r24
	TWCR.Bits.TWEA = 1;
    12b8:	e6 e5       	ldi	r30, 0x56	; 86
    12ba:	f0 e0       	ldi	r31, 0x00	; 0
    12bc:	80 81       	ld	r24, Z
    12be:	80 64       	ori	r24, 0x40	; 64
    12c0:	80 83       	st	Z, r24
	TWCR.Bits.TWSTO = 0;
    12c2:	e6 e5       	ldi	r30, 0x56	; 86
    12c4:	f0 e0       	ldi	r31, 0x00	; 0
    12c6:	80 81       	ld	r24, Z
    12c8:	8f 7e       	andi	r24, 0xEF	; 239
    12ca:	80 83       	st	Z, r24
	TWCR.Bits.TWIE = 0;
    12cc:	e6 e5       	ldi	r30, 0x56	; 86
    12ce:	f0 e0       	ldi	r31, 0x00	; 0
    12d0:	80 81       	ld	r24, Z
    12d2:	8e 7f       	andi	r24, 0xFE	; 254
    12d4:	80 83       	st	Z, r24
	TWCR.Bits.TWWC = 0;
    12d6:	e6 e5       	ldi	r30, 0x56	; 86
    12d8:	f0 e0       	ldi	r31, 0x00	; 0
    12da:	80 81       	ld	r24, Z
    12dc:	87 7f       	andi	r24, 0xF7	; 247
    12de:	80 83       	st	Z, r24
	TWCR.Bits.TWINT = 1;
    12e0:	e6 e5       	ldi	r30, 0x56	; 86
    12e2:	f0 e0       	ldi	r31, 0x00	; 0
    12e4:	80 81       	ld	r24, Z
    12e6:	80 68       	ori	r24, 0x80	; 128
    12e8:	80 83       	st	Z, r24
	//TWCR.Bits.TWEN = 1;
	/* Wait for TWINT flag set in TWCR Register (data received successfully) */
	while (TWCR.Bits.TWINT == 0)
    12ea:	e6 e5       	ldi	r30, 0x56	; 86
    12ec:	f0 e0       	ldi	r31, 0x00	; 0
    12ee:	80 81       	ld	r24, Z
    12f0:	80 78       	andi	r24, 0x80	; 128
    12f2:	88 23       	and	r24, r24
    12f4:	d1 f3       	breq	.-12     	; 0x12ea <TWI_readByteWithACK+0x44>
		;
	/* Read Data */
	return TWDR;
    12f6:	e3 e2       	ldi	r30, 0x23	; 35
    12f8:	f0 e0       	ldi	r31, 0x00	; 0
    12fa:	80 81       	ld	r24, Z
}
    12fc:	cf 91       	pop	r28
    12fe:	df 91       	pop	r29
    1300:	08 95       	ret

00001302 <TWI_readByteWithNACK>:

uint8 TWI_readByteWithNACK(void) {
    1302:	df 93       	push	r29
    1304:	cf 93       	push	r28
    1306:	cd b7       	in	r28, 0x3d	; 61
    1308:	de b7       	in	r29, 0x3e	; 62
	/*
	 * Clear the TWINT flag before reading the data TWINT=1
	 * Enable TWI Module TWEN=1
	 */
	//TWCR.Byte = 0x84;
	TWCR.Bits.TWSTA = 0;
    130a:	e6 e5       	ldi	r30, 0x56	; 86
    130c:	f0 e0       	ldi	r31, 0x00	; 0
    130e:	80 81       	ld	r24, Z
    1310:	8f 7d       	andi	r24, 0xDF	; 223
    1312:	80 83       	st	Z, r24
	TWCR.Bits.TWEA = 0;
    1314:	e6 e5       	ldi	r30, 0x56	; 86
    1316:	f0 e0       	ldi	r31, 0x00	; 0
    1318:	80 81       	ld	r24, Z
    131a:	8f 7b       	andi	r24, 0xBF	; 191
    131c:	80 83       	st	Z, r24
	TWCR.Bits.TWSTO = 0;
    131e:	e6 e5       	ldi	r30, 0x56	; 86
    1320:	f0 e0       	ldi	r31, 0x00	; 0
    1322:	80 81       	ld	r24, Z
    1324:	8f 7e       	andi	r24, 0xEF	; 239
    1326:	80 83       	st	Z, r24
	TWCR.Bits.TWIE = 0;
    1328:	e6 e5       	ldi	r30, 0x56	; 86
    132a:	f0 e0       	ldi	r31, 0x00	; 0
    132c:	80 81       	ld	r24, Z
    132e:	8e 7f       	andi	r24, 0xFE	; 254
    1330:	80 83       	st	Z, r24
	TWCR.Bits.TWWC = 0;
    1332:	e6 e5       	ldi	r30, 0x56	; 86
    1334:	f0 e0       	ldi	r31, 0x00	; 0
    1336:	80 81       	ld	r24, Z
    1338:	87 7f       	andi	r24, 0xF7	; 247
    133a:	80 83       	st	Z, r24
	TWCR.Bits.TWINT = 1;
    133c:	e6 e5       	ldi	r30, 0x56	; 86
    133e:	f0 e0       	ldi	r31, 0x00	; 0
    1340:	80 81       	ld	r24, Z
    1342:	80 68       	ori	r24, 0x80	; 128
    1344:	80 83       	st	Z, r24
	//TWCR.Bits.TWEN = 1;
	/* Wait for TWINT flag set in TWCR Register (data received successfully) */
	while (TWCR.Bits.TWINT == 0)
    1346:	e6 e5       	ldi	r30, 0x56	; 86
    1348:	f0 e0       	ldi	r31, 0x00	; 0
    134a:	80 81       	ld	r24, Z
    134c:	80 78       	andi	r24, 0x80	; 128
    134e:	88 23       	and	r24, r24
    1350:	d1 f3       	breq	.-12     	; 0x1346 <TWI_readByteWithNACK+0x44>
		;
	/* Read Data */
	return TWDR;
    1352:	e3 e2       	ldi	r30, 0x23	; 35
    1354:	f0 e0       	ldi	r31, 0x00	; 0
    1356:	80 81       	ld	r24, Z
}
    1358:	cf 91       	pop	r28
    135a:	df 91       	pop	r29
    135c:	08 95       	ret

0000135e <TWI_getStatus>:

uint8 TWI_getStatus(void) {
    135e:	df 93       	push	r29
    1360:	cf 93       	push	r28
    1362:	0f 92       	push	r0
    1364:	cd b7       	in	r28, 0x3d	; 61
    1366:	de b7       	in	r29, 0x3e	; 62
	uint8 status;
	/* masking to eliminate first 3 bits and get the last 5 bits (status bits) */
	status = TWSR & 0xF8;
    1368:	e1 e2       	ldi	r30, 0x21	; 33
    136a:	f0 e0       	ldi	r31, 0x00	; 0
    136c:	80 81       	ld	r24, Z
    136e:	88 7f       	andi	r24, 0xF8	; 248
    1370:	89 83       	std	Y+1, r24	; 0x01
	return status;
    1372:	89 81       	ldd	r24, Y+1	; 0x01
}
    1374:	0f 90       	pop	r0
    1376:	cf 91       	pop	r28
    1378:	df 91       	pop	r29
    137a:	08 95       	ret

0000137c <__vector_9>:
static volatile void (*g_callBackPtr)(void) = NULL_PTR;
/*******************************************************************************
 *                       Interrupt Service Routines                            *
 *******************************************************************************/
/* Normal mode ISR */
ISR(TIMER1_OVF_vect) {
    137c:	1f 92       	push	r1
    137e:	0f 92       	push	r0
    1380:	0f b6       	in	r0, 0x3f	; 63
    1382:	0f 92       	push	r0
    1384:	11 24       	eor	r1, r1
    1386:	2f 93       	push	r18
    1388:	3f 93       	push	r19
    138a:	4f 93       	push	r20
    138c:	5f 93       	push	r21
    138e:	6f 93       	push	r22
    1390:	7f 93       	push	r23
    1392:	8f 93       	push	r24
    1394:	9f 93       	push	r25
    1396:	af 93       	push	r26
    1398:	bf 93       	push	r27
    139a:	ef 93       	push	r30
    139c:	ff 93       	push	r31
    139e:	df 93       	push	r29
    13a0:	cf 93       	push	r28
    13a2:	cd b7       	in	r28, 0x3d	; 61
    13a4:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR) {
    13a6:	80 91 7e 01 	lds	r24, 0x017E
    13aa:	90 91 7f 01 	lds	r25, 0x017F
    13ae:	00 97       	sbiw	r24, 0x00	; 0
    13b0:	29 f0       	breq	.+10     	; 0x13bc <__vector_9+0x40>
		(*g_callBackPtr)();
    13b2:	e0 91 7e 01 	lds	r30, 0x017E
    13b6:	f0 91 7f 01 	lds	r31, 0x017F
    13ba:	09 95       	icall
	}
}
    13bc:	cf 91       	pop	r28
    13be:	df 91       	pop	r29
    13c0:	ff 91       	pop	r31
    13c2:	ef 91       	pop	r30
    13c4:	bf 91       	pop	r27
    13c6:	af 91       	pop	r26
    13c8:	9f 91       	pop	r25
    13ca:	8f 91       	pop	r24
    13cc:	7f 91       	pop	r23
    13ce:	6f 91       	pop	r22
    13d0:	5f 91       	pop	r21
    13d2:	4f 91       	pop	r20
    13d4:	3f 91       	pop	r19
    13d6:	2f 91       	pop	r18
    13d8:	0f 90       	pop	r0
    13da:	0f be       	out	0x3f, r0	; 63
    13dc:	0f 90       	pop	r0
    13de:	1f 90       	pop	r1
    13e0:	18 95       	reti

000013e2 <__vector_7>:

/* Compare mode ISR */
ISR(TIMER1_COMPA_vect) {
    13e2:	1f 92       	push	r1
    13e4:	0f 92       	push	r0
    13e6:	0f b6       	in	r0, 0x3f	; 63
    13e8:	0f 92       	push	r0
    13ea:	11 24       	eor	r1, r1
    13ec:	2f 93       	push	r18
    13ee:	3f 93       	push	r19
    13f0:	4f 93       	push	r20
    13f2:	5f 93       	push	r21
    13f4:	6f 93       	push	r22
    13f6:	7f 93       	push	r23
    13f8:	8f 93       	push	r24
    13fa:	9f 93       	push	r25
    13fc:	af 93       	push	r26
    13fe:	bf 93       	push	r27
    1400:	ef 93       	push	r30
    1402:	ff 93       	push	r31
    1404:	df 93       	push	r29
    1406:	cf 93       	push	r28
    1408:	cd b7       	in	r28, 0x3d	; 61
    140a:	de b7       	in	r29, 0x3e	; 62
	if (g_callBackPtr != NULL_PTR) {
    140c:	80 91 7e 01 	lds	r24, 0x017E
    1410:	90 91 7f 01 	lds	r25, 0x017F
    1414:	00 97       	sbiw	r24, 0x00	; 0
    1416:	29 f0       	breq	.+10     	; 0x1422 <__vector_7+0x40>
		(*g_callBackPtr)();
    1418:	e0 91 7e 01 	lds	r30, 0x017E
    141c:	f0 91 7f 01 	lds	r31, 0x017F
    1420:	09 95       	icall
	}
}
    1422:	cf 91       	pop	r28
    1424:	df 91       	pop	r29
    1426:	ff 91       	pop	r31
    1428:	ef 91       	pop	r30
    142a:	bf 91       	pop	r27
    142c:	af 91       	pop	r26
    142e:	9f 91       	pop	r25
    1430:	8f 91       	pop	r24
    1432:	7f 91       	pop	r23
    1434:	6f 91       	pop	r22
    1436:	5f 91       	pop	r21
    1438:	4f 91       	pop	r20
    143a:	3f 91       	pop	r19
    143c:	2f 91       	pop	r18
    143e:	0f 90       	pop	r0
    1440:	0f be       	out	0x3f, r0	; 63
    1442:	0f 90       	pop	r0
    1444:	1f 90       	pop	r1
    1446:	18 95       	reti

00001448 <Timer1_init>:
/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/
/* Description
 Function to initialize the Timer driver */
void Timer1_init(const Timer1_ConfigType *Config_Ptr) {
    1448:	df 93       	push	r29
    144a:	cf 93       	push	r28
    144c:	00 d0       	rcall	.+0      	; 0x144e <Timer1_init+0x6>
    144e:	00 d0       	rcall	.+0      	; 0x1450 <Timer1_init+0x8>
    1450:	cd b7       	in	r28, 0x3d	; 61
    1452:	de b7       	in	r29, 0x3e	; 62
    1454:	9a 83       	std	Y+2, r25	; 0x02
    1456:	89 83       	std	Y+1, r24	; 0x01
	TCNT1_REG = (Config_Ptr->initial_value);
    1458:	ac e4       	ldi	r26, 0x4C	; 76
    145a:	b0 e0       	ldi	r27, 0x00	; 0
    145c:	e9 81       	ldd	r30, Y+1	; 0x01
    145e:	fa 81       	ldd	r31, Y+2	; 0x02
    1460:	80 81       	ld	r24, Z
    1462:	91 81       	ldd	r25, Z+1	; 0x01
    1464:	11 96       	adiw	r26, 0x01	; 1
    1466:	9c 93       	st	X, r25
    1468:	8e 93       	st	-X, r24
	switch ((Config_Ptr->mode)) {
    146a:	e9 81       	ldd	r30, Y+1	; 0x01
    146c:	fa 81       	ldd	r31, Y+2	; 0x02
    146e:	85 81       	ldd	r24, Z+5	; 0x05
    1470:	28 2f       	mov	r18, r24
    1472:	30 e0       	ldi	r19, 0x00	; 0
    1474:	3c 83       	std	Y+4, r19	; 0x04
    1476:	2b 83       	std	Y+3, r18	; 0x03
    1478:	8b 81       	ldd	r24, Y+3	; 0x03
    147a:	9c 81       	ldd	r25, Y+4	; 0x04
    147c:	00 97       	sbiw	r24, 0x00	; 0
    147e:	31 f0       	breq	.+12     	; 0x148c <Timer1_init+0x44>
    1480:	2b 81       	ldd	r18, Y+3	; 0x03
    1482:	3c 81       	ldd	r19, Y+4	; 0x04
    1484:	24 30       	cpi	r18, 0x04	; 4
    1486:	31 05       	cpc	r19, r1
    1488:	89 f0       	breq	.+34     	; 0x14ac <Timer1_init+0x64>
    148a:	2d c0       	rjmp	.+90     	; 0x14e6 <Timer1_init+0x9e>
	case Timer1_Mode_0_Normal:
		/*NO PWM*/
		TCCR1A_REG.Bits.FOC1A_BIT = 1;
    148c:	ef e4       	ldi	r30, 0x4F	; 79
    148e:	f0 e0       	ldi	r31, 0x00	; 0
    1490:	80 81       	ld	r24, Z
    1492:	84 60       	ori	r24, 0x04	; 4
    1494:	80 83       	st	Z, r24
		TCCR1A_REG.Bits.FOC1B_BIT = 1;
    1496:	ef e4       	ldi	r30, 0x4F	; 79
    1498:	f0 e0       	ldi	r31, 0x00	; 0
    149a:	80 81       	ld	r24, Z
    149c:	88 60       	ori	r24, 0x08	; 8
    149e:	80 83       	st	Z, r24
		/*TOIE1 Interput enable*/
		TIMSK_REG.Bits.TOIE1_BIT = 1;
    14a0:	e9 e5       	ldi	r30, 0x59	; 89
    14a2:	f0 e0       	ldi	r31, 0x00	; 0
    14a4:	80 81       	ld	r24, Z
    14a6:	84 60       	ori	r24, 0x04	; 4
    14a8:	80 83       	st	Z, r24
    14aa:	1d c0       	rjmp	.+58     	; 0x14e6 <Timer1_init+0x9e>
		break;
	case Timer1_Mode_4_CTC:
		/*NO PWM*/
		TCCR1A_REG.Bits.FOC1A_BIT = 1;
    14ac:	ef e4       	ldi	r30, 0x4F	; 79
    14ae:	f0 e0       	ldi	r31, 0x00	; 0
    14b0:	80 81       	ld	r24, Z
    14b2:	84 60       	ori	r24, 0x04	; 4
    14b4:	80 83       	st	Z, r24
		TCCR1A_REG.Bits.FOC1B_BIT = 1;
    14b6:	ef e4       	ldi	r30, 0x4F	; 79
    14b8:	f0 e0       	ldi	r31, 0x00	; 0
    14ba:	80 81       	ld	r24, Z
    14bc:	88 60       	ori	r24, 0x08	; 8
    14be:	80 83       	st	Z, r24
		/*CTC MODE*/
		TCCR1B_REG.Bits.WGM12_BIT = 1;
    14c0:	ee e4       	ldi	r30, 0x4E	; 78
    14c2:	f0 e0       	ldi	r31, 0x00	; 0
    14c4:	80 81       	ld	r24, Z
    14c6:	88 60       	ori	r24, 0x08	; 8
    14c8:	80 83       	st	Z, r24
		/*OCIE1A Interput enable*/
		TIMSK_REG.Bits.OCIE1A_BIT = 1;
    14ca:	e9 e5       	ldi	r30, 0x59	; 89
    14cc:	f0 e0       	ldi	r31, 0x00	; 0
    14ce:	80 81       	ld	r24, Z
    14d0:	80 61       	ori	r24, 0x10	; 16
    14d2:	80 83       	st	Z, r24
		/*Set the compere value*/
		OCR1A_REG = Config_Ptr->compare_value;
    14d4:	aa e4       	ldi	r26, 0x4A	; 74
    14d6:	b0 e0       	ldi	r27, 0x00	; 0
    14d8:	e9 81       	ldd	r30, Y+1	; 0x01
    14da:	fa 81       	ldd	r31, Y+2	; 0x02
    14dc:	82 81       	ldd	r24, Z+2	; 0x02
    14de:	93 81       	ldd	r25, Z+3	; 0x03
    14e0:	11 96       	adiw	r26, 0x01	; 1
    14e2:	9c 93       	st	X, r25
    14e4:	8e 93       	st	-X, r24
		break;
	default:
		break;
	}
	/*Clock*/
	TCCR1B_REG.Bits.CS10_11_12_BITS = (Config_Ptr->prescaler);
    14e6:	ae e4       	ldi	r26, 0x4E	; 78
    14e8:	b0 e0       	ldi	r27, 0x00	; 0
    14ea:	e9 81       	ldd	r30, Y+1	; 0x01
    14ec:	fa 81       	ldd	r31, Y+2	; 0x02
    14ee:	84 81       	ldd	r24, Z+4	; 0x04
    14f0:	87 70       	andi	r24, 0x07	; 7
    14f2:	98 2f       	mov	r25, r24
    14f4:	97 70       	andi	r25, 0x07	; 7
    14f6:	8c 91       	ld	r24, X
    14f8:	88 7f       	andi	r24, 0xF8	; 248
    14fa:	89 2b       	or	r24, r25
    14fc:	8c 93       	st	X, r24
}
    14fe:	0f 90       	pop	r0
    1500:	0f 90       	pop	r0
    1502:	0f 90       	pop	r0
    1504:	0f 90       	pop	r0
    1506:	cf 91       	pop	r28
    1508:	df 91       	pop	r29
    150a:	08 95       	ret

0000150c <Timer1_deInit>:
/*Description
 Function to disable the Timer1.*/
void Timer1_deInit(void) {
    150c:	df 93       	push	r29
    150e:	cf 93       	push	r28
    1510:	cd b7       	in	r28, 0x3d	; 61
    1512:	de b7       	in	r29, 0x3e	; 62
	/*Set all values*/
	TCNT1_REG = 0;
    1514:	ec e4       	ldi	r30, 0x4C	; 76
    1516:	f0 e0       	ldi	r31, 0x00	; 0
    1518:	11 82       	std	Z+1, r1	; 0x01
    151a:	10 82       	st	Z, r1
	TCCR1A_REG.Byte = 0x00;
    151c:	ef e4       	ldi	r30, 0x4F	; 79
    151e:	f0 e0       	ldi	r31, 0x00	; 0
    1520:	10 82       	st	Z, r1
	TCCR1B_REG.Byte = 0x00;
    1522:	ee e4       	ldi	r30, 0x4E	; 78
    1524:	f0 e0       	ldi	r31, 0x00	; 0
    1526:	10 82       	st	Z, r1
	TIMSK_REG.Byte = 0x00;
    1528:	e9 e5       	ldi	r30, 0x59	; 89
    152a:	f0 e0       	ldi	r31, 0x00	; 0
    152c:	10 82       	st	Z, r1
	OCR1A_REG = 0;
    152e:	ea e4       	ldi	r30, 0x4A	; 74
    1530:	f0 e0       	ldi	r31, 0x00	; 0
    1532:	11 82       	std	Z+1, r1	; 0x01
    1534:	10 82       	st	Z, r1
	OCR1B_REG = 0;
    1536:	e8 e4       	ldi	r30, 0x48	; 72
    1538:	f0 e0       	ldi	r31, 0x00	; 0
    153a:	11 82       	std	Z+1, r1	; 0x01
    153c:	10 82       	st	Z, r1
	ICR1_REG = 0;
    153e:	e6 e4       	ldi	r30, 0x46	; 70
    1540:	f0 e0       	ldi	r31, 0x00	; 0
    1542:	11 82       	std	Z+1, r1	; 0x01
    1544:	10 82       	st	Z, r1
	g_callBackPtr = NULL_PTR;
    1546:	10 92 7f 01 	sts	0x017F, r1
    154a:	10 92 7e 01 	sts	0x017E, r1

}
    154e:	cf 91       	pop	r28
    1550:	df 91       	pop	r29
    1552:	08 95       	ret

00001554 <Timer1_setCallBack>:
/*Description
 Function to set the Call Back function address.*/
void Timer1_setCallBack(void (*a_ptr)(void)) {
    1554:	df 93       	push	r29
    1556:	cf 93       	push	r28
    1558:	00 d0       	rcall	.+0      	; 0x155a <Timer1_setCallBack+0x6>
    155a:	cd b7       	in	r28, 0x3d	; 61
    155c:	de b7       	in	r29, 0x3e	; 62
    155e:	9a 83       	std	Y+2, r25	; 0x02
    1560:	89 83       	std	Y+1, r24	; 0x01
	g_callBackPtr = a_ptr;
    1562:	89 81       	ldd	r24, Y+1	; 0x01
    1564:	9a 81       	ldd	r25, Y+2	; 0x02
    1566:	90 93 7f 01 	sts	0x017F, r25
    156a:	80 93 7e 01 	sts	0x017E, r24
}
    156e:	0f 90       	pop	r0
    1570:	0f 90       	pop	r0
    1572:	cf 91       	pop	r28
    1574:	df 91       	pop	r29
    1576:	08 95       	ret

00001578 <PWM_Timer0_Start>:
  Setup the prescaler with F_CPU/8.
  Setup the compare value based on the required input duty cycle
  Setup the direction for OC0 as output pin through the GPIO driver.
  The generated PWM signal frequency will be 500Hz to control the DC
 Motor speed*/
void PWM_Timer0_Start(uint8 duty_cycle) {
    1578:	df 93       	push	r29
    157a:	cf 93       	push	r28
    157c:	0f 92       	push	r0
    157e:	cd b7       	in	r28, 0x3d	; 61
    1580:	de b7       	in	r29, 0x3e	; 62
    1582:	89 83       	std	Y+1, r24	; 0x01
	TCNT0 = 0; // Set Timer Initial Value to 0
    1584:	e2 e5       	ldi	r30, 0x52	; 82
    1586:	f0 e0       	ldi	r31, 0x00	; 0
    1588:	10 82       	st	Z, r1

	OCR0 = duty_cycle; // Set Compare Value
    158a:	ec e5       	ldi	r30, 0x5C	; 92
    158c:	f0 e0       	ldi	r31, 0x00	; 0
    158e:	89 81       	ldd	r24, Y+1	; 0x01
    1590:	80 83       	st	Z, r24

	DDRB = DDRB | (1 << PB3); // Configure PB3/OC0 as output pin
    1592:	a7 e3       	ldi	r26, 0x37	; 55
    1594:	b0 e0       	ldi	r27, 0x00	; 0
    1596:	e7 e3       	ldi	r30, 0x37	; 55
    1598:	f0 e0       	ldi	r31, 0x00	; 0
    159a:	80 81       	ld	r24, Z
    159c:	88 60       	ori	r24, 0x08	; 8
    159e:	8c 93       	st	X, r24
	 * 1. Fast PWM mode FOC0=0
	 * 2. Fast PWM Mode WGM01=1 & WGM00=1
	 * 3. Clear OC0 when match occurs (non inverted mode) COM00=0 & COM01=1
	 * 4. clock = F_CPU/8 CS00=0 CS01=1 CS02=0
	 */
	TCCR0 = (1 << WGM00) | (1 << WGM01) | (1 << COM01) | (1 << CS01);
    15a0:	e3 e5       	ldi	r30, 0x53	; 83
    15a2:	f0 e0       	ldi	r31, 0x00	; 0
    15a4:	8a e6       	ldi	r24, 0x6A	; 106
    15a6:	80 83       	st	Z, r24
}
    15a8:	0f 90       	pop	r0
    15aa:	cf 91       	pop	r28
    15ac:	df 91       	pop	r29
    15ae:	08 95       	ret

000015b0 <GPIO_setupPinDirection>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num,
		GPIO_PinDirectionType direction) {
    15b0:	df 93       	push	r29
    15b2:	cf 93       	push	r28
    15b4:	00 d0       	rcall	.+0      	; 0x15b6 <GPIO_setupPinDirection+0x6>
    15b6:	00 d0       	rcall	.+0      	; 0x15b8 <GPIO_setupPinDirection+0x8>
    15b8:	0f 92       	push	r0
    15ba:	cd b7       	in	r28, 0x3d	; 61
    15bc:	de b7       	in	r29, 0x3e	; 62
    15be:	89 83       	std	Y+1, r24	; 0x01
    15c0:	6a 83       	std	Y+2, r22	; 0x02
    15c2:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if ((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS)) {
    15c4:	8a 81       	ldd	r24, Y+2	; 0x02
    15c6:	88 30       	cpi	r24, 0x08	; 8
    15c8:	08 f0       	brcs	.+2      	; 0x15cc <GPIO_setupPinDirection+0x1c>
    15ca:	d5 c0       	rjmp	.+426    	; 0x1776 <GPIO_setupPinDirection+0x1c6>
    15cc:	89 81       	ldd	r24, Y+1	; 0x01
    15ce:	84 30       	cpi	r24, 0x04	; 4
    15d0:	08 f0       	brcs	.+2      	; 0x15d4 <GPIO_setupPinDirection+0x24>
    15d2:	d1 c0       	rjmp	.+418    	; 0x1776 <GPIO_setupPinDirection+0x1c6>
		/* Do Nothing */
	} else {
		/* Setup the pin direction as required */
		switch (port_num) {
    15d4:	89 81       	ldd	r24, Y+1	; 0x01
    15d6:	28 2f       	mov	r18, r24
    15d8:	30 e0       	ldi	r19, 0x00	; 0
    15da:	3d 83       	std	Y+5, r19	; 0x05
    15dc:	2c 83       	std	Y+4, r18	; 0x04
    15de:	8c 81       	ldd	r24, Y+4	; 0x04
    15e0:	9d 81       	ldd	r25, Y+5	; 0x05
    15e2:	81 30       	cpi	r24, 0x01	; 1
    15e4:	91 05       	cpc	r25, r1
    15e6:	09 f4       	brne	.+2      	; 0x15ea <GPIO_setupPinDirection+0x3a>
    15e8:	43 c0       	rjmp	.+134    	; 0x1670 <GPIO_setupPinDirection+0xc0>
    15ea:	2c 81       	ldd	r18, Y+4	; 0x04
    15ec:	3d 81       	ldd	r19, Y+5	; 0x05
    15ee:	22 30       	cpi	r18, 0x02	; 2
    15f0:	31 05       	cpc	r19, r1
    15f2:	2c f4       	brge	.+10     	; 0x15fe <GPIO_setupPinDirection+0x4e>
    15f4:	8c 81       	ldd	r24, Y+4	; 0x04
    15f6:	9d 81       	ldd	r25, Y+5	; 0x05
    15f8:	00 97       	sbiw	r24, 0x00	; 0
    15fa:	71 f0       	breq	.+28     	; 0x1618 <GPIO_setupPinDirection+0x68>
    15fc:	bc c0       	rjmp	.+376    	; 0x1776 <GPIO_setupPinDirection+0x1c6>
    15fe:	2c 81       	ldd	r18, Y+4	; 0x04
    1600:	3d 81       	ldd	r19, Y+5	; 0x05
    1602:	22 30       	cpi	r18, 0x02	; 2
    1604:	31 05       	cpc	r19, r1
    1606:	09 f4       	brne	.+2      	; 0x160a <GPIO_setupPinDirection+0x5a>
    1608:	5f c0       	rjmp	.+190    	; 0x16c8 <GPIO_setupPinDirection+0x118>
    160a:	8c 81       	ldd	r24, Y+4	; 0x04
    160c:	9d 81       	ldd	r25, Y+5	; 0x05
    160e:	83 30       	cpi	r24, 0x03	; 3
    1610:	91 05       	cpc	r25, r1
    1612:	09 f4       	brne	.+2      	; 0x1616 <GPIO_setupPinDirection+0x66>
    1614:	85 c0       	rjmp	.+266    	; 0x1720 <GPIO_setupPinDirection+0x170>
    1616:	af c0       	rjmp	.+350    	; 0x1776 <GPIO_setupPinDirection+0x1c6>
		case PORTA_ID:
			if (direction == PIN_OUTPUT) {
    1618:	8b 81       	ldd	r24, Y+3	; 0x03
    161a:	81 30       	cpi	r24, 0x01	; 1
    161c:	a1 f4       	brne	.+40     	; 0x1646 <GPIO_setupPinDirection+0x96>
				SET_BIT(DDRA, pin_num);
    161e:	aa e3       	ldi	r26, 0x3A	; 58
    1620:	b0 e0       	ldi	r27, 0x00	; 0
    1622:	ea e3       	ldi	r30, 0x3A	; 58
    1624:	f0 e0       	ldi	r31, 0x00	; 0
    1626:	80 81       	ld	r24, Z
    1628:	48 2f       	mov	r20, r24
    162a:	8a 81       	ldd	r24, Y+2	; 0x02
    162c:	28 2f       	mov	r18, r24
    162e:	30 e0       	ldi	r19, 0x00	; 0
    1630:	81 e0       	ldi	r24, 0x01	; 1
    1632:	90 e0       	ldi	r25, 0x00	; 0
    1634:	02 2e       	mov	r0, r18
    1636:	02 c0       	rjmp	.+4      	; 0x163c <GPIO_setupPinDirection+0x8c>
    1638:	88 0f       	add	r24, r24
    163a:	99 1f       	adc	r25, r25
    163c:	0a 94       	dec	r0
    163e:	e2 f7       	brpl	.-8      	; 0x1638 <GPIO_setupPinDirection+0x88>
    1640:	84 2b       	or	r24, r20
    1642:	8c 93       	st	X, r24
    1644:	98 c0       	rjmp	.+304    	; 0x1776 <GPIO_setupPinDirection+0x1c6>
			} else {
				CLEAR_BIT(DDRA, pin_num);
    1646:	aa e3       	ldi	r26, 0x3A	; 58
    1648:	b0 e0       	ldi	r27, 0x00	; 0
    164a:	ea e3       	ldi	r30, 0x3A	; 58
    164c:	f0 e0       	ldi	r31, 0x00	; 0
    164e:	80 81       	ld	r24, Z
    1650:	48 2f       	mov	r20, r24
    1652:	8a 81       	ldd	r24, Y+2	; 0x02
    1654:	28 2f       	mov	r18, r24
    1656:	30 e0       	ldi	r19, 0x00	; 0
    1658:	81 e0       	ldi	r24, 0x01	; 1
    165a:	90 e0       	ldi	r25, 0x00	; 0
    165c:	02 2e       	mov	r0, r18
    165e:	02 c0       	rjmp	.+4      	; 0x1664 <GPIO_setupPinDirection+0xb4>
    1660:	88 0f       	add	r24, r24
    1662:	99 1f       	adc	r25, r25
    1664:	0a 94       	dec	r0
    1666:	e2 f7       	brpl	.-8      	; 0x1660 <GPIO_setupPinDirection+0xb0>
    1668:	80 95       	com	r24
    166a:	84 23       	and	r24, r20
    166c:	8c 93       	st	X, r24
    166e:	83 c0       	rjmp	.+262    	; 0x1776 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTB_ID:
			if (direction == PIN_OUTPUT) {
    1670:	8b 81       	ldd	r24, Y+3	; 0x03
    1672:	81 30       	cpi	r24, 0x01	; 1
    1674:	a1 f4       	brne	.+40     	; 0x169e <GPIO_setupPinDirection+0xee>
				SET_BIT(DDRB, pin_num);
    1676:	a7 e3       	ldi	r26, 0x37	; 55
    1678:	b0 e0       	ldi	r27, 0x00	; 0
    167a:	e7 e3       	ldi	r30, 0x37	; 55
    167c:	f0 e0       	ldi	r31, 0x00	; 0
    167e:	80 81       	ld	r24, Z
    1680:	48 2f       	mov	r20, r24
    1682:	8a 81       	ldd	r24, Y+2	; 0x02
    1684:	28 2f       	mov	r18, r24
    1686:	30 e0       	ldi	r19, 0x00	; 0
    1688:	81 e0       	ldi	r24, 0x01	; 1
    168a:	90 e0       	ldi	r25, 0x00	; 0
    168c:	02 2e       	mov	r0, r18
    168e:	02 c0       	rjmp	.+4      	; 0x1694 <GPIO_setupPinDirection+0xe4>
    1690:	88 0f       	add	r24, r24
    1692:	99 1f       	adc	r25, r25
    1694:	0a 94       	dec	r0
    1696:	e2 f7       	brpl	.-8      	; 0x1690 <GPIO_setupPinDirection+0xe0>
    1698:	84 2b       	or	r24, r20
    169a:	8c 93       	st	X, r24
    169c:	6c c0       	rjmp	.+216    	; 0x1776 <GPIO_setupPinDirection+0x1c6>
			} else {
				CLEAR_BIT(DDRB, pin_num);
    169e:	a7 e3       	ldi	r26, 0x37	; 55
    16a0:	b0 e0       	ldi	r27, 0x00	; 0
    16a2:	e7 e3       	ldi	r30, 0x37	; 55
    16a4:	f0 e0       	ldi	r31, 0x00	; 0
    16a6:	80 81       	ld	r24, Z
    16a8:	48 2f       	mov	r20, r24
    16aa:	8a 81       	ldd	r24, Y+2	; 0x02
    16ac:	28 2f       	mov	r18, r24
    16ae:	30 e0       	ldi	r19, 0x00	; 0
    16b0:	81 e0       	ldi	r24, 0x01	; 1
    16b2:	90 e0       	ldi	r25, 0x00	; 0
    16b4:	02 2e       	mov	r0, r18
    16b6:	02 c0       	rjmp	.+4      	; 0x16bc <GPIO_setupPinDirection+0x10c>
    16b8:	88 0f       	add	r24, r24
    16ba:	99 1f       	adc	r25, r25
    16bc:	0a 94       	dec	r0
    16be:	e2 f7       	brpl	.-8      	; 0x16b8 <GPIO_setupPinDirection+0x108>
    16c0:	80 95       	com	r24
    16c2:	84 23       	and	r24, r20
    16c4:	8c 93       	st	X, r24
    16c6:	57 c0       	rjmp	.+174    	; 0x1776 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTC_ID:
			if (direction == PIN_OUTPUT) {
    16c8:	8b 81       	ldd	r24, Y+3	; 0x03
    16ca:	81 30       	cpi	r24, 0x01	; 1
    16cc:	a1 f4       	brne	.+40     	; 0x16f6 <GPIO_setupPinDirection+0x146>
				SET_BIT(DDRC, pin_num);
    16ce:	a4 e3       	ldi	r26, 0x34	; 52
    16d0:	b0 e0       	ldi	r27, 0x00	; 0
    16d2:	e4 e3       	ldi	r30, 0x34	; 52
    16d4:	f0 e0       	ldi	r31, 0x00	; 0
    16d6:	80 81       	ld	r24, Z
    16d8:	48 2f       	mov	r20, r24
    16da:	8a 81       	ldd	r24, Y+2	; 0x02
    16dc:	28 2f       	mov	r18, r24
    16de:	30 e0       	ldi	r19, 0x00	; 0
    16e0:	81 e0       	ldi	r24, 0x01	; 1
    16e2:	90 e0       	ldi	r25, 0x00	; 0
    16e4:	02 2e       	mov	r0, r18
    16e6:	02 c0       	rjmp	.+4      	; 0x16ec <GPIO_setupPinDirection+0x13c>
    16e8:	88 0f       	add	r24, r24
    16ea:	99 1f       	adc	r25, r25
    16ec:	0a 94       	dec	r0
    16ee:	e2 f7       	brpl	.-8      	; 0x16e8 <GPIO_setupPinDirection+0x138>
    16f0:	84 2b       	or	r24, r20
    16f2:	8c 93       	st	X, r24
    16f4:	40 c0       	rjmp	.+128    	; 0x1776 <GPIO_setupPinDirection+0x1c6>
			} else {
				CLEAR_BIT(DDRC, pin_num);
    16f6:	a4 e3       	ldi	r26, 0x34	; 52
    16f8:	b0 e0       	ldi	r27, 0x00	; 0
    16fa:	e4 e3       	ldi	r30, 0x34	; 52
    16fc:	f0 e0       	ldi	r31, 0x00	; 0
    16fe:	80 81       	ld	r24, Z
    1700:	48 2f       	mov	r20, r24
    1702:	8a 81       	ldd	r24, Y+2	; 0x02
    1704:	28 2f       	mov	r18, r24
    1706:	30 e0       	ldi	r19, 0x00	; 0
    1708:	81 e0       	ldi	r24, 0x01	; 1
    170a:	90 e0       	ldi	r25, 0x00	; 0
    170c:	02 2e       	mov	r0, r18
    170e:	02 c0       	rjmp	.+4      	; 0x1714 <GPIO_setupPinDirection+0x164>
    1710:	88 0f       	add	r24, r24
    1712:	99 1f       	adc	r25, r25
    1714:	0a 94       	dec	r0
    1716:	e2 f7       	brpl	.-8      	; 0x1710 <GPIO_setupPinDirection+0x160>
    1718:	80 95       	com	r24
    171a:	84 23       	and	r24, r20
    171c:	8c 93       	st	X, r24
    171e:	2b c0       	rjmp	.+86     	; 0x1776 <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTD_ID:
			if (direction == PIN_OUTPUT) {
    1720:	8b 81       	ldd	r24, Y+3	; 0x03
    1722:	81 30       	cpi	r24, 0x01	; 1
    1724:	a1 f4       	brne	.+40     	; 0x174e <GPIO_setupPinDirection+0x19e>
				SET_BIT(DDRD, pin_num);
    1726:	a1 e3       	ldi	r26, 0x31	; 49
    1728:	b0 e0       	ldi	r27, 0x00	; 0
    172a:	e1 e3       	ldi	r30, 0x31	; 49
    172c:	f0 e0       	ldi	r31, 0x00	; 0
    172e:	80 81       	ld	r24, Z
    1730:	48 2f       	mov	r20, r24
    1732:	8a 81       	ldd	r24, Y+2	; 0x02
    1734:	28 2f       	mov	r18, r24
    1736:	30 e0       	ldi	r19, 0x00	; 0
    1738:	81 e0       	ldi	r24, 0x01	; 1
    173a:	90 e0       	ldi	r25, 0x00	; 0
    173c:	02 2e       	mov	r0, r18
    173e:	02 c0       	rjmp	.+4      	; 0x1744 <GPIO_setupPinDirection+0x194>
    1740:	88 0f       	add	r24, r24
    1742:	99 1f       	adc	r25, r25
    1744:	0a 94       	dec	r0
    1746:	e2 f7       	brpl	.-8      	; 0x1740 <GPIO_setupPinDirection+0x190>
    1748:	84 2b       	or	r24, r20
    174a:	8c 93       	st	X, r24
    174c:	14 c0       	rjmp	.+40     	; 0x1776 <GPIO_setupPinDirection+0x1c6>
			} else {
				CLEAR_BIT(DDRD, pin_num);
    174e:	a1 e3       	ldi	r26, 0x31	; 49
    1750:	b0 e0       	ldi	r27, 0x00	; 0
    1752:	e1 e3       	ldi	r30, 0x31	; 49
    1754:	f0 e0       	ldi	r31, 0x00	; 0
    1756:	80 81       	ld	r24, Z
    1758:	48 2f       	mov	r20, r24
    175a:	8a 81       	ldd	r24, Y+2	; 0x02
    175c:	28 2f       	mov	r18, r24
    175e:	30 e0       	ldi	r19, 0x00	; 0
    1760:	81 e0       	ldi	r24, 0x01	; 1
    1762:	90 e0       	ldi	r25, 0x00	; 0
    1764:	02 2e       	mov	r0, r18
    1766:	02 c0       	rjmp	.+4      	; 0x176c <GPIO_setupPinDirection+0x1bc>
    1768:	88 0f       	add	r24, r24
    176a:	99 1f       	adc	r25, r25
    176c:	0a 94       	dec	r0
    176e:	e2 f7       	brpl	.-8      	; 0x1768 <GPIO_setupPinDirection+0x1b8>
    1770:	80 95       	com	r24
    1772:	84 23       	and	r24, r20
    1774:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    1776:	0f 90       	pop	r0
    1778:	0f 90       	pop	r0
    177a:	0f 90       	pop	r0
    177c:	0f 90       	pop	r0
    177e:	0f 90       	pop	r0
    1780:	cf 91       	pop	r28
    1782:	df 91       	pop	r29
    1784:	08 95       	ret

00001786 <GPIO_writePin>:
 * Description :
 * Write the value Logic High or Logic Low on the required pin.
 * If the input port number or pin number are not correct, The function will not handle the request.
 * If the pin is input, this function will enable/disable the internal pull-up resistor.
 */
void GPIO_writePin(uint8 port_num, uint8 pin_num, uint8 value) {
    1786:	df 93       	push	r29
    1788:	cf 93       	push	r28
    178a:	00 d0       	rcall	.+0      	; 0x178c <GPIO_writePin+0x6>
    178c:	00 d0       	rcall	.+0      	; 0x178e <GPIO_writePin+0x8>
    178e:	0f 92       	push	r0
    1790:	cd b7       	in	r28, 0x3d	; 61
    1792:	de b7       	in	r29, 0x3e	; 62
    1794:	89 83       	std	Y+1, r24	; 0x01
    1796:	6a 83       	std	Y+2, r22	; 0x02
    1798:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if ((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS)) {
    179a:	8a 81       	ldd	r24, Y+2	; 0x02
    179c:	88 30       	cpi	r24, 0x08	; 8
    179e:	08 f0       	brcs	.+2      	; 0x17a2 <GPIO_writePin+0x1c>
    17a0:	d5 c0       	rjmp	.+426    	; 0x194c <GPIO_writePin+0x1c6>
    17a2:	89 81       	ldd	r24, Y+1	; 0x01
    17a4:	84 30       	cpi	r24, 0x04	; 4
    17a6:	08 f0       	brcs	.+2      	; 0x17aa <GPIO_writePin+0x24>
    17a8:	d1 c0       	rjmp	.+418    	; 0x194c <GPIO_writePin+0x1c6>
		/* Do Nothing */
	} else {
		/* Write the pin value as required */
		switch (port_num) {
    17aa:	89 81       	ldd	r24, Y+1	; 0x01
    17ac:	28 2f       	mov	r18, r24
    17ae:	30 e0       	ldi	r19, 0x00	; 0
    17b0:	3d 83       	std	Y+5, r19	; 0x05
    17b2:	2c 83       	std	Y+4, r18	; 0x04
    17b4:	8c 81       	ldd	r24, Y+4	; 0x04
    17b6:	9d 81       	ldd	r25, Y+5	; 0x05
    17b8:	81 30       	cpi	r24, 0x01	; 1
    17ba:	91 05       	cpc	r25, r1
    17bc:	09 f4       	brne	.+2      	; 0x17c0 <GPIO_writePin+0x3a>
    17be:	43 c0       	rjmp	.+134    	; 0x1846 <GPIO_writePin+0xc0>
    17c0:	2c 81       	ldd	r18, Y+4	; 0x04
    17c2:	3d 81       	ldd	r19, Y+5	; 0x05
    17c4:	22 30       	cpi	r18, 0x02	; 2
    17c6:	31 05       	cpc	r19, r1
    17c8:	2c f4       	brge	.+10     	; 0x17d4 <GPIO_writePin+0x4e>
    17ca:	8c 81       	ldd	r24, Y+4	; 0x04
    17cc:	9d 81       	ldd	r25, Y+5	; 0x05
    17ce:	00 97       	sbiw	r24, 0x00	; 0
    17d0:	71 f0       	breq	.+28     	; 0x17ee <GPIO_writePin+0x68>
    17d2:	bc c0       	rjmp	.+376    	; 0x194c <GPIO_writePin+0x1c6>
    17d4:	2c 81       	ldd	r18, Y+4	; 0x04
    17d6:	3d 81       	ldd	r19, Y+5	; 0x05
    17d8:	22 30       	cpi	r18, 0x02	; 2
    17da:	31 05       	cpc	r19, r1
    17dc:	09 f4       	brne	.+2      	; 0x17e0 <GPIO_writePin+0x5a>
    17de:	5f c0       	rjmp	.+190    	; 0x189e <GPIO_writePin+0x118>
    17e0:	8c 81       	ldd	r24, Y+4	; 0x04
    17e2:	9d 81       	ldd	r25, Y+5	; 0x05
    17e4:	83 30       	cpi	r24, 0x03	; 3
    17e6:	91 05       	cpc	r25, r1
    17e8:	09 f4       	brne	.+2      	; 0x17ec <GPIO_writePin+0x66>
    17ea:	85 c0       	rjmp	.+266    	; 0x18f6 <GPIO_writePin+0x170>
    17ec:	af c0       	rjmp	.+350    	; 0x194c <GPIO_writePin+0x1c6>
		case PORTA_ID:
			if (value == LOGIC_HIGH) {
    17ee:	8b 81       	ldd	r24, Y+3	; 0x03
    17f0:	81 30       	cpi	r24, 0x01	; 1
    17f2:	a1 f4       	brne	.+40     	; 0x181c <GPIO_writePin+0x96>
				SET_BIT(PORTA, pin_num);
    17f4:	ab e3       	ldi	r26, 0x3B	; 59
    17f6:	b0 e0       	ldi	r27, 0x00	; 0
    17f8:	eb e3       	ldi	r30, 0x3B	; 59
    17fa:	f0 e0       	ldi	r31, 0x00	; 0
    17fc:	80 81       	ld	r24, Z
    17fe:	48 2f       	mov	r20, r24
    1800:	8a 81       	ldd	r24, Y+2	; 0x02
    1802:	28 2f       	mov	r18, r24
    1804:	30 e0       	ldi	r19, 0x00	; 0
    1806:	81 e0       	ldi	r24, 0x01	; 1
    1808:	90 e0       	ldi	r25, 0x00	; 0
    180a:	02 2e       	mov	r0, r18
    180c:	02 c0       	rjmp	.+4      	; 0x1812 <GPIO_writePin+0x8c>
    180e:	88 0f       	add	r24, r24
    1810:	99 1f       	adc	r25, r25
    1812:	0a 94       	dec	r0
    1814:	e2 f7       	brpl	.-8      	; 0x180e <GPIO_writePin+0x88>
    1816:	84 2b       	or	r24, r20
    1818:	8c 93       	st	X, r24
    181a:	98 c0       	rjmp	.+304    	; 0x194c <GPIO_writePin+0x1c6>
			} else {
				CLEAR_BIT(PORTA, pin_num);
    181c:	ab e3       	ldi	r26, 0x3B	; 59
    181e:	b0 e0       	ldi	r27, 0x00	; 0
    1820:	eb e3       	ldi	r30, 0x3B	; 59
    1822:	f0 e0       	ldi	r31, 0x00	; 0
    1824:	80 81       	ld	r24, Z
    1826:	48 2f       	mov	r20, r24
    1828:	8a 81       	ldd	r24, Y+2	; 0x02
    182a:	28 2f       	mov	r18, r24
    182c:	30 e0       	ldi	r19, 0x00	; 0
    182e:	81 e0       	ldi	r24, 0x01	; 1
    1830:	90 e0       	ldi	r25, 0x00	; 0
    1832:	02 2e       	mov	r0, r18
    1834:	02 c0       	rjmp	.+4      	; 0x183a <GPIO_writePin+0xb4>
    1836:	88 0f       	add	r24, r24
    1838:	99 1f       	adc	r25, r25
    183a:	0a 94       	dec	r0
    183c:	e2 f7       	brpl	.-8      	; 0x1836 <GPIO_writePin+0xb0>
    183e:	80 95       	com	r24
    1840:	84 23       	and	r24, r20
    1842:	8c 93       	st	X, r24
    1844:	83 c0       	rjmp	.+262    	; 0x194c <GPIO_writePin+0x1c6>
			}
			break;
		case PORTB_ID:
			if (value == LOGIC_HIGH) {
    1846:	8b 81       	ldd	r24, Y+3	; 0x03
    1848:	81 30       	cpi	r24, 0x01	; 1
    184a:	a1 f4       	brne	.+40     	; 0x1874 <GPIO_writePin+0xee>
				SET_BIT(PORTB, pin_num);
    184c:	a8 e3       	ldi	r26, 0x38	; 56
    184e:	b0 e0       	ldi	r27, 0x00	; 0
    1850:	e8 e3       	ldi	r30, 0x38	; 56
    1852:	f0 e0       	ldi	r31, 0x00	; 0
    1854:	80 81       	ld	r24, Z
    1856:	48 2f       	mov	r20, r24
    1858:	8a 81       	ldd	r24, Y+2	; 0x02
    185a:	28 2f       	mov	r18, r24
    185c:	30 e0       	ldi	r19, 0x00	; 0
    185e:	81 e0       	ldi	r24, 0x01	; 1
    1860:	90 e0       	ldi	r25, 0x00	; 0
    1862:	02 2e       	mov	r0, r18
    1864:	02 c0       	rjmp	.+4      	; 0x186a <GPIO_writePin+0xe4>
    1866:	88 0f       	add	r24, r24
    1868:	99 1f       	adc	r25, r25
    186a:	0a 94       	dec	r0
    186c:	e2 f7       	brpl	.-8      	; 0x1866 <GPIO_writePin+0xe0>
    186e:	84 2b       	or	r24, r20
    1870:	8c 93       	st	X, r24
    1872:	6c c0       	rjmp	.+216    	; 0x194c <GPIO_writePin+0x1c6>
			} else {
				CLEAR_BIT(PORTB, pin_num);
    1874:	a8 e3       	ldi	r26, 0x38	; 56
    1876:	b0 e0       	ldi	r27, 0x00	; 0
    1878:	e8 e3       	ldi	r30, 0x38	; 56
    187a:	f0 e0       	ldi	r31, 0x00	; 0
    187c:	80 81       	ld	r24, Z
    187e:	48 2f       	mov	r20, r24
    1880:	8a 81       	ldd	r24, Y+2	; 0x02
    1882:	28 2f       	mov	r18, r24
    1884:	30 e0       	ldi	r19, 0x00	; 0
    1886:	81 e0       	ldi	r24, 0x01	; 1
    1888:	90 e0       	ldi	r25, 0x00	; 0
    188a:	02 2e       	mov	r0, r18
    188c:	02 c0       	rjmp	.+4      	; 0x1892 <GPIO_writePin+0x10c>
    188e:	88 0f       	add	r24, r24
    1890:	99 1f       	adc	r25, r25
    1892:	0a 94       	dec	r0
    1894:	e2 f7       	brpl	.-8      	; 0x188e <GPIO_writePin+0x108>
    1896:	80 95       	com	r24
    1898:	84 23       	and	r24, r20
    189a:	8c 93       	st	X, r24
    189c:	57 c0       	rjmp	.+174    	; 0x194c <GPIO_writePin+0x1c6>
			}
			break;
		case PORTC_ID:
			if (value == LOGIC_HIGH) {
    189e:	8b 81       	ldd	r24, Y+3	; 0x03
    18a0:	81 30       	cpi	r24, 0x01	; 1
    18a2:	a1 f4       	brne	.+40     	; 0x18cc <GPIO_writePin+0x146>
				SET_BIT(PORTC, pin_num);
    18a4:	a5 e3       	ldi	r26, 0x35	; 53
    18a6:	b0 e0       	ldi	r27, 0x00	; 0
    18a8:	e5 e3       	ldi	r30, 0x35	; 53
    18aa:	f0 e0       	ldi	r31, 0x00	; 0
    18ac:	80 81       	ld	r24, Z
    18ae:	48 2f       	mov	r20, r24
    18b0:	8a 81       	ldd	r24, Y+2	; 0x02
    18b2:	28 2f       	mov	r18, r24
    18b4:	30 e0       	ldi	r19, 0x00	; 0
    18b6:	81 e0       	ldi	r24, 0x01	; 1
    18b8:	90 e0       	ldi	r25, 0x00	; 0
    18ba:	02 2e       	mov	r0, r18
    18bc:	02 c0       	rjmp	.+4      	; 0x18c2 <GPIO_writePin+0x13c>
    18be:	88 0f       	add	r24, r24
    18c0:	99 1f       	adc	r25, r25
    18c2:	0a 94       	dec	r0
    18c4:	e2 f7       	brpl	.-8      	; 0x18be <GPIO_writePin+0x138>
    18c6:	84 2b       	or	r24, r20
    18c8:	8c 93       	st	X, r24
    18ca:	40 c0       	rjmp	.+128    	; 0x194c <GPIO_writePin+0x1c6>
			} else {
				CLEAR_BIT(PORTC, pin_num);
    18cc:	a5 e3       	ldi	r26, 0x35	; 53
    18ce:	b0 e0       	ldi	r27, 0x00	; 0
    18d0:	e5 e3       	ldi	r30, 0x35	; 53
    18d2:	f0 e0       	ldi	r31, 0x00	; 0
    18d4:	80 81       	ld	r24, Z
    18d6:	48 2f       	mov	r20, r24
    18d8:	8a 81       	ldd	r24, Y+2	; 0x02
    18da:	28 2f       	mov	r18, r24
    18dc:	30 e0       	ldi	r19, 0x00	; 0
    18de:	81 e0       	ldi	r24, 0x01	; 1
    18e0:	90 e0       	ldi	r25, 0x00	; 0
    18e2:	02 2e       	mov	r0, r18
    18e4:	02 c0       	rjmp	.+4      	; 0x18ea <GPIO_writePin+0x164>
    18e6:	88 0f       	add	r24, r24
    18e8:	99 1f       	adc	r25, r25
    18ea:	0a 94       	dec	r0
    18ec:	e2 f7       	brpl	.-8      	; 0x18e6 <GPIO_writePin+0x160>
    18ee:	80 95       	com	r24
    18f0:	84 23       	and	r24, r20
    18f2:	8c 93       	st	X, r24
    18f4:	2b c0       	rjmp	.+86     	; 0x194c <GPIO_writePin+0x1c6>
			}
			break;
		case PORTD_ID:
			if (value == LOGIC_HIGH) {
    18f6:	8b 81       	ldd	r24, Y+3	; 0x03
    18f8:	81 30       	cpi	r24, 0x01	; 1
    18fa:	a1 f4       	brne	.+40     	; 0x1924 <GPIO_writePin+0x19e>
				SET_BIT(PORTD, pin_num);
    18fc:	a2 e3       	ldi	r26, 0x32	; 50
    18fe:	b0 e0       	ldi	r27, 0x00	; 0
    1900:	e2 e3       	ldi	r30, 0x32	; 50
    1902:	f0 e0       	ldi	r31, 0x00	; 0
    1904:	80 81       	ld	r24, Z
    1906:	48 2f       	mov	r20, r24
    1908:	8a 81       	ldd	r24, Y+2	; 0x02
    190a:	28 2f       	mov	r18, r24
    190c:	30 e0       	ldi	r19, 0x00	; 0
    190e:	81 e0       	ldi	r24, 0x01	; 1
    1910:	90 e0       	ldi	r25, 0x00	; 0
    1912:	02 2e       	mov	r0, r18
    1914:	02 c0       	rjmp	.+4      	; 0x191a <GPIO_writePin+0x194>
    1916:	88 0f       	add	r24, r24
    1918:	99 1f       	adc	r25, r25
    191a:	0a 94       	dec	r0
    191c:	e2 f7       	brpl	.-8      	; 0x1916 <GPIO_writePin+0x190>
    191e:	84 2b       	or	r24, r20
    1920:	8c 93       	st	X, r24
    1922:	14 c0       	rjmp	.+40     	; 0x194c <GPIO_writePin+0x1c6>
			} else {
				CLEAR_BIT(PORTD, pin_num);
    1924:	a2 e3       	ldi	r26, 0x32	; 50
    1926:	b0 e0       	ldi	r27, 0x00	; 0
    1928:	e2 e3       	ldi	r30, 0x32	; 50
    192a:	f0 e0       	ldi	r31, 0x00	; 0
    192c:	80 81       	ld	r24, Z
    192e:	48 2f       	mov	r20, r24
    1930:	8a 81       	ldd	r24, Y+2	; 0x02
    1932:	28 2f       	mov	r18, r24
    1934:	30 e0       	ldi	r19, 0x00	; 0
    1936:	81 e0       	ldi	r24, 0x01	; 1
    1938:	90 e0       	ldi	r25, 0x00	; 0
    193a:	02 2e       	mov	r0, r18
    193c:	02 c0       	rjmp	.+4      	; 0x1942 <GPIO_writePin+0x1bc>
    193e:	88 0f       	add	r24, r24
    1940:	99 1f       	adc	r25, r25
    1942:	0a 94       	dec	r0
    1944:	e2 f7       	brpl	.-8      	; 0x193e <GPIO_writePin+0x1b8>
    1946:	80 95       	com	r24
    1948:	84 23       	and	r24, r20
    194a:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    194c:	0f 90       	pop	r0
    194e:	0f 90       	pop	r0
    1950:	0f 90       	pop	r0
    1952:	0f 90       	pop	r0
    1954:	0f 90       	pop	r0
    1956:	cf 91       	pop	r28
    1958:	df 91       	pop	r29
    195a:	08 95       	ret

0000195c <GPIO_readPin>:
/*
 * Description :
 * Read and return the value for the required pin, it should be Logic High or Logic Low.
 * If the input port number or pin number are not correct, The function will return Logic Low.
 */
uint8 GPIO_readPin(uint8 port_num, uint8 pin_num) {
    195c:	df 93       	push	r29
    195e:	cf 93       	push	r28
    1960:	00 d0       	rcall	.+0      	; 0x1962 <GPIO_readPin+0x6>
    1962:	00 d0       	rcall	.+0      	; 0x1964 <GPIO_readPin+0x8>
    1964:	0f 92       	push	r0
    1966:	cd b7       	in	r28, 0x3d	; 61
    1968:	de b7       	in	r29, 0x3e	; 62
    196a:	8a 83       	std	Y+2, r24	; 0x02
    196c:	6b 83       	std	Y+3, r22	; 0x03
	uint8 pin_value = LOGIC_LOW;
    196e:	19 82       	std	Y+1, r1	; 0x01
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if ((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS)) {
    1970:	8b 81       	ldd	r24, Y+3	; 0x03
    1972:	88 30       	cpi	r24, 0x08	; 8
    1974:	08 f0       	brcs	.+2      	; 0x1978 <GPIO_readPin+0x1c>
    1976:	84 c0       	rjmp	.+264    	; 0x1a80 <GPIO_readPin+0x124>
    1978:	8a 81       	ldd	r24, Y+2	; 0x02
    197a:	84 30       	cpi	r24, 0x04	; 4
    197c:	08 f0       	brcs	.+2      	; 0x1980 <GPIO_readPin+0x24>
    197e:	80 c0       	rjmp	.+256    	; 0x1a80 <GPIO_readPin+0x124>
		/* Do Nothing */
	} else {
		/* Read the pin value as required */
		switch (port_num) {
    1980:	8a 81       	ldd	r24, Y+2	; 0x02
    1982:	28 2f       	mov	r18, r24
    1984:	30 e0       	ldi	r19, 0x00	; 0
    1986:	3d 83       	std	Y+5, r19	; 0x05
    1988:	2c 83       	std	Y+4, r18	; 0x04
    198a:	4c 81       	ldd	r20, Y+4	; 0x04
    198c:	5d 81       	ldd	r21, Y+5	; 0x05
    198e:	41 30       	cpi	r20, 0x01	; 1
    1990:	51 05       	cpc	r21, r1
    1992:	79 f1       	breq	.+94     	; 0x19f2 <GPIO_readPin+0x96>
    1994:	8c 81       	ldd	r24, Y+4	; 0x04
    1996:	9d 81       	ldd	r25, Y+5	; 0x05
    1998:	82 30       	cpi	r24, 0x02	; 2
    199a:	91 05       	cpc	r25, r1
    199c:	34 f4       	brge	.+12     	; 0x19aa <GPIO_readPin+0x4e>
    199e:	2c 81       	ldd	r18, Y+4	; 0x04
    19a0:	3d 81       	ldd	r19, Y+5	; 0x05
    19a2:	21 15       	cp	r18, r1
    19a4:	31 05       	cpc	r19, r1
    19a6:	69 f0       	breq	.+26     	; 0x19c2 <GPIO_readPin+0x66>
    19a8:	6b c0       	rjmp	.+214    	; 0x1a80 <GPIO_readPin+0x124>
    19aa:	4c 81       	ldd	r20, Y+4	; 0x04
    19ac:	5d 81       	ldd	r21, Y+5	; 0x05
    19ae:	42 30       	cpi	r20, 0x02	; 2
    19b0:	51 05       	cpc	r21, r1
    19b2:	b9 f1       	breq	.+110    	; 0x1a22 <GPIO_readPin+0xc6>
    19b4:	8c 81       	ldd	r24, Y+4	; 0x04
    19b6:	9d 81       	ldd	r25, Y+5	; 0x05
    19b8:	83 30       	cpi	r24, 0x03	; 3
    19ba:	91 05       	cpc	r25, r1
    19bc:	09 f4       	brne	.+2      	; 0x19c0 <GPIO_readPin+0x64>
    19be:	49 c0       	rjmp	.+146    	; 0x1a52 <GPIO_readPin+0xf6>
    19c0:	5f c0       	rjmp	.+190    	; 0x1a80 <GPIO_readPin+0x124>
		case PORTA_ID:
			if (BIT_IS_SET(PINA, pin_num)) {
    19c2:	e9 e3       	ldi	r30, 0x39	; 57
    19c4:	f0 e0       	ldi	r31, 0x00	; 0
    19c6:	80 81       	ld	r24, Z
    19c8:	28 2f       	mov	r18, r24
    19ca:	30 e0       	ldi	r19, 0x00	; 0
    19cc:	8b 81       	ldd	r24, Y+3	; 0x03
    19ce:	88 2f       	mov	r24, r24
    19d0:	90 e0       	ldi	r25, 0x00	; 0
    19d2:	a9 01       	movw	r20, r18
    19d4:	02 c0       	rjmp	.+4      	; 0x19da <GPIO_readPin+0x7e>
    19d6:	55 95       	asr	r21
    19d8:	47 95       	ror	r20
    19da:	8a 95       	dec	r24
    19dc:	e2 f7       	brpl	.-8      	; 0x19d6 <GPIO_readPin+0x7a>
    19de:	ca 01       	movw	r24, r20
    19e0:	81 70       	andi	r24, 0x01	; 1
    19e2:	90 70       	andi	r25, 0x00	; 0
    19e4:	88 23       	and	r24, r24
    19e6:	19 f0       	breq	.+6      	; 0x19ee <GPIO_readPin+0x92>
				pin_value = LOGIC_HIGH;
    19e8:	81 e0       	ldi	r24, 0x01	; 1
    19ea:	89 83       	std	Y+1, r24	; 0x01
    19ec:	49 c0       	rjmp	.+146    	; 0x1a80 <GPIO_readPin+0x124>
			} else {
				pin_value = LOGIC_LOW;
    19ee:	19 82       	std	Y+1, r1	; 0x01
    19f0:	47 c0       	rjmp	.+142    	; 0x1a80 <GPIO_readPin+0x124>
			}
			break;
		case PORTB_ID:
			if (BIT_IS_SET(PINB, pin_num)) {
    19f2:	e6 e3       	ldi	r30, 0x36	; 54
    19f4:	f0 e0       	ldi	r31, 0x00	; 0
    19f6:	80 81       	ld	r24, Z
    19f8:	28 2f       	mov	r18, r24
    19fa:	30 e0       	ldi	r19, 0x00	; 0
    19fc:	8b 81       	ldd	r24, Y+3	; 0x03
    19fe:	88 2f       	mov	r24, r24
    1a00:	90 e0       	ldi	r25, 0x00	; 0
    1a02:	a9 01       	movw	r20, r18
    1a04:	02 c0       	rjmp	.+4      	; 0x1a0a <GPIO_readPin+0xae>
    1a06:	55 95       	asr	r21
    1a08:	47 95       	ror	r20
    1a0a:	8a 95       	dec	r24
    1a0c:	e2 f7       	brpl	.-8      	; 0x1a06 <GPIO_readPin+0xaa>
    1a0e:	ca 01       	movw	r24, r20
    1a10:	81 70       	andi	r24, 0x01	; 1
    1a12:	90 70       	andi	r25, 0x00	; 0
    1a14:	88 23       	and	r24, r24
    1a16:	19 f0       	breq	.+6      	; 0x1a1e <GPIO_readPin+0xc2>
				pin_value = LOGIC_HIGH;
    1a18:	81 e0       	ldi	r24, 0x01	; 1
    1a1a:	89 83       	std	Y+1, r24	; 0x01
    1a1c:	31 c0       	rjmp	.+98     	; 0x1a80 <GPIO_readPin+0x124>
			} else {
				pin_value = LOGIC_LOW;
    1a1e:	19 82       	std	Y+1, r1	; 0x01
    1a20:	2f c0       	rjmp	.+94     	; 0x1a80 <GPIO_readPin+0x124>
			}
			break;
		case PORTC_ID:
			if (BIT_IS_SET(PINC, pin_num)) {
    1a22:	e3 e3       	ldi	r30, 0x33	; 51
    1a24:	f0 e0       	ldi	r31, 0x00	; 0
    1a26:	80 81       	ld	r24, Z
    1a28:	28 2f       	mov	r18, r24
    1a2a:	30 e0       	ldi	r19, 0x00	; 0
    1a2c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a2e:	88 2f       	mov	r24, r24
    1a30:	90 e0       	ldi	r25, 0x00	; 0
    1a32:	a9 01       	movw	r20, r18
    1a34:	02 c0       	rjmp	.+4      	; 0x1a3a <GPIO_readPin+0xde>
    1a36:	55 95       	asr	r21
    1a38:	47 95       	ror	r20
    1a3a:	8a 95       	dec	r24
    1a3c:	e2 f7       	brpl	.-8      	; 0x1a36 <GPIO_readPin+0xda>
    1a3e:	ca 01       	movw	r24, r20
    1a40:	81 70       	andi	r24, 0x01	; 1
    1a42:	90 70       	andi	r25, 0x00	; 0
    1a44:	88 23       	and	r24, r24
    1a46:	19 f0       	breq	.+6      	; 0x1a4e <GPIO_readPin+0xf2>
				pin_value = LOGIC_HIGH;
    1a48:	81 e0       	ldi	r24, 0x01	; 1
    1a4a:	89 83       	std	Y+1, r24	; 0x01
    1a4c:	19 c0       	rjmp	.+50     	; 0x1a80 <GPIO_readPin+0x124>
			} else {
				pin_value = LOGIC_LOW;
    1a4e:	19 82       	std	Y+1, r1	; 0x01
    1a50:	17 c0       	rjmp	.+46     	; 0x1a80 <GPIO_readPin+0x124>
			}
			break;
		case PORTD_ID:
			if (BIT_IS_SET(PIND, pin_num)) {
    1a52:	e0 e3       	ldi	r30, 0x30	; 48
    1a54:	f0 e0       	ldi	r31, 0x00	; 0
    1a56:	80 81       	ld	r24, Z
    1a58:	28 2f       	mov	r18, r24
    1a5a:	30 e0       	ldi	r19, 0x00	; 0
    1a5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a5e:	88 2f       	mov	r24, r24
    1a60:	90 e0       	ldi	r25, 0x00	; 0
    1a62:	a9 01       	movw	r20, r18
    1a64:	02 c0       	rjmp	.+4      	; 0x1a6a <GPIO_readPin+0x10e>
    1a66:	55 95       	asr	r21
    1a68:	47 95       	ror	r20
    1a6a:	8a 95       	dec	r24
    1a6c:	e2 f7       	brpl	.-8      	; 0x1a66 <GPIO_readPin+0x10a>
    1a6e:	ca 01       	movw	r24, r20
    1a70:	81 70       	andi	r24, 0x01	; 1
    1a72:	90 70       	andi	r25, 0x00	; 0
    1a74:	88 23       	and	r24, r24
    1a76:	19 f0       	breq	.+6      	; 0x1a7e <GPIO_readPin+0x122>
				pin_value = LOGIC_HIGH;
    1a78:	81 e0       	ldi	r24, 0x01	; 1
    1a7a:	89 83       	std	Y+1, r24	; 0x01
    1a7c:	01 c0       	rjmp	.+2      	; 0x1a80 <GPIO_readPin+0x124>
			} else {
				pin_value = LOGIC_LOW;
    1a7e:	19 82       	std	Y+1, r1	; 0x01
			}
			break;
		}
	}

	return pin_value;
    1a80:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a82:	0f 90       	pop	r0
    1a84:	0f 90       	pop	r0
    1a86:	0f 90       	pop	r0
    1a88:	0f 90       	pop	r0
    1a8a:	0f 90       	pop	r0
    1a8c:	cf 91       	pop	r28
    1a8e:	df 91       	pop	r29
    1a90:	08 95       	ret

00001a92 <GPIO_setupPortDirection>:
 * Setup the direction of the required port all pins input/output.
 * If the direction value is PORT_INPUT all pins in this port should be input pins.
 * If the direction value is PORT_OUTPUT all pins in this port should be output pins.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_setupPortDirection(uint8 port_num, GPIO_PortDirectionType direction) {
    1a92:	df 93       	push	r29
    1a94:	cf 93       	push	r28
    1a96:	00 d0       	rcall	.+0      	; 0x1a98 <GPIO_setupPortDirection+0x6>
    1a98:	00 d0       	rcall	.+0      	; 0x1a9a <GPIO_setupPortDirection+0x8>
    1a9a:	cd b7       	in	r28, 0x3d	; 61
    1a9c:	de b7       	in	r29, 0x3e	; 62
    1a9e:	89 83       	std	Y+1, r24	; 0x01
    1aa0:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if (port_num >= NUM_OF_PORTS) {
    1aa2:	89 81       	ldd	r24, Y+1	; 0x01
    1aa4:	84 30       	cpi	r24, 0x04	; 4
    1aa6:	90 f5       	brcc	.+100    	; 0x1b0c <GPIO_setupPortDirection+0x7a>
		/* Do Nothing */
	} else {
		/* Setup the port direction as required */
		switch (port_num) {
    1aa8:	89 81       	ldd	r24, Y+1	; 0x01
    1aaa:	28 2f       	mov	r18, r24
    1aac:	30 e0       	ldi	r19, 0x00	; 0
    1aae:	3c 83       	std	Y+4, r19	; 0x04
    1ab0:	2b 83       	std	Y+3, r18	; 0x03
    1ab2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ab4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ab6:	81 30       	cpi	r24, 0x01	; 1
    1ab8:	91 05       	cpc	r25, r1
    1aba:	d1 f0       	breq	.+52     	; 0x1af0 <GPIO_setupPortDirection+0x5e>
    1abc:	2b 81       	ldd	r18, Y+3	; 0x03
    1abe:	3c 81       	ldd	r19, Y+4	; 0x04
    1ac0:	22 30       	cpi	r18, 0x02	; 2
    1ac2:	31 05       	cpc	r19, r1
    1ac4:	2c f4       	brge	.+10     	; 0x1ad0 <GPIO_setupPortDirection+0x3e>
    1ac6:	8b 81       	ldd	r24, Y+3	; 0x03
    1ac8:	9c 81       	ldd	r25, Y+4	; 0x04
    1aca:	00 97       	sbiw	r24, 0x00	; 0
    1acc:	61 f0       	breq	.+24     	; 0x1ae6 <GPIO_setupPortDirection+0x54>
    1ace:	1e c0       	rjmp	.+60     	; 0x1b0c <GPIO_setupPortDirection+0x7a>
    1ad0:	2b 81       	ldd	r18, Y+3	; 0x03
    1ad2:	3c 81       	ldd	r19, Y+4	; 0x04
    1ad4:	22 30       	cpi	r18, 0x02	; 2
    1ad6:	31 05       	cpc	r19, r1
    1ad8:	81 f0       	breq	.+32     	; 0x1afa <GPIO_setupPortDirection+0x68>
    1ada:	8b 81       	ldd	r24, Y+3	; 0x03
    1adc:	9c 81       	ldd	r25, Y+4	; 0x04
    1ade:	83 30       	cpi	r24, 0x03	; 3
    1ae0:	91 05       	cpc	r25, r1
    1ae2:	81 f0       	breq	.+32     	; 0x1b04 <GPIO_setupPortDirection+0x72>
    1ae4:	13 c0       	rjmp	.+38     	; 0x1b0c <GPIO_setupPortDirection+0x7a>
		case PORTA_ID:
			DDRA = direction;
    1ae6:	ea e3       	ldi	r30, 0x3A	; 58
    1ae8:	f0 e0       	ldi	r31, 0x00	; 0
    1aea:	8a 81       	ldd	r24, Y+2	; 0x02
    1aec:	80 83       	st	Z, r24
    1aee:	0e c0       	rjmp	.+28     	; 0x1b0c <GPIO_setupPortDirection+0x7a>
			break;
		case PORTB_ID:
			DDRB = direction;
    1af0:	e7 e3       	ldi	r30, 0x37	; 55
    1af2:	f0 e0       	ldi	r31, 0x00	; 0
    1af4:	8a 81       	ldd	r24, Y+2	; 0x02
    1af6:	80 83       	st	Z, r24
    1af8:	09 c0       	rjmp	.+18     	; 0x1b0c <GPIO_setupPortDirection+0x7a>
			break;
		case PORTC_ID:
			DDRC = direction;
    1afa:	e4 e3       	ldi	r30, 0x34	; 52
    1afc:	f0 e0       	ldi	r31, 0x00	; 0
    1afe:	8a 81       	ldd	r24, Y+2	; 0x02
    1b00:	80 83       	st	Z, r24
    1b02:	04 c0       	rjmp	.+8      	; 0x1b0c <GPIO_setupPortDirection+0x7a>
			break;
		case PORTD_ID:
			DDRD = direction;
    1b04:	e1 e3       	ldi	r30, 0x31	; 49
    1b06:	f0 e0       	ldi	r31, 0x00	; 0
    1b08:	8a 81       	ldd	r24, Y+2	; 0x02
    1b0a:	80 83       	st	Z, r24
			break;
		}
	}
}
    1b0c:	0f 90       	pop	r0
    1b0e:	0f 90       	pop	r0
    1b10:	0f 90       	pop	r0
    1b12:	0f 90       	pop	r0
    1b14:	cf 91       	pop	r28
    1b16:	df 91       	pop	r29
    1b18:	08 95       	ret

00001b1a <GPIO_writePort>:
 * Write the value on the required port.
 * If any pin in the port is output pin the value will be written.
 * If any pin in the port is input pin this will activate/deactivate the internal pull-up resistor.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_writePort(uint8 port_num, uint8 value) {
    1b1a:	df 93       	push	r29
    1b1c:	cf 93       	push	r28
    1b1e:	00 d0       	rcall	.+0      	; 0x1b20 <GPIO_writePort+0x6>
    1b20:	00 d0       	rcall	.+0      	; 0x1b22 <GPIO_writePort+0x8>
    1b22:	cd b7       	in	r28, 0x3d	; 61
    1b24:	de b7       	in	r29, 0x3e	; 62
    1b26:	89 83       	std	Y+1, r24	; 0x01
    1b28:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if (port_num >= NUM_OF_PORTS) {
    1b2a:	89 81       	ldd	r24, Y+1	; 0x01
    1b2c:	84 30       	cpi	r24, 0x04	; 4
    1b2e:	90 f5       	brcc	.+100    	; 0x1b94 <GPIO_writePort+0x7a>
		/* Do Nothing */
	} else {
		/* Write the port value as required */
		switch (port_num) {
    1b30:	89 81       	ldd	r24, Y+1	; 0x01
    1b32:	28 2f       	mov	r18, r24
    1b34:	30 e0       	ldi	r19, 0x00	; 0
    1b36:	3c 83       	std	Y+4, r19	; 0x04
    1b38:	2b 83       	std	Y+3, r18	; 0x03
    1b3a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b3c:	9c 81       	ldd	r25, Y+4	; 0x04
    1b3e:	81 30       	cpi	r24, 0x01	; 1
    1b40:	91 05       	cpc	r25, r1
    1b42:	d1 f0       	breq	.+52     	; 0x1b78 <GPIO_writePort+0x5e>
    1b44:	2b 81       	ldd	r18, Y+3	; 0x03
    1b46:	3c 81       	ldd	r19, Y+4	; 0x04
    1b48:	22 30       	cpi	r18, 0x02	; 2
    1b4a:	31 05       	cpc	r19, r1
    1b4c:	2c f4       	brge	.+10     	; 0x1b58 <GPIO_writePort+0x3e>
    1b4e:	8b 81       	ldd	r24, Y+3	; 0x03
    1b50:	9c 81       	ldd	r25, Y+4	; 0x04
    1b52:	00 97       	sbiw	r24, 0x00	; 0
    1b54:	61 f0       	breq	.+24     	; 0x1b6e <GPIO_writePort+0x54>
    1b56:	1e c0       	rjmp	.+60     	; 0x1b94 <GPIO_writePort+0x7a>
    1b58:	2b 81       	ldd	r18, Y+3	; 0x03
    1b5a:	3c 81       	ldd	r19, Y+4	; 0x04
    1b5c:	22 30       	cpi	r18, 0x02	; 2
    1b5e:	31 05       	cpc	r19, r1
    1b60:	81 f0       	breq	.+32     	; 0x1b82 <GPIO_writePort+0x68>
    1b62:	8b 81       	ldd	r24, Y+3	; 0x03
    1b64:	9c 81       	ldd	r25, Y+4	; 0x04
    1b66:	83 30       	cpi	r24, 0x03	; 3
    1b68:	91 05       	cpc	r25, r1
    1b6a:	81 f0       	breq	.+32     	; 0x1b8c <GPIO_writePort+0x72>
    1b6c:	13 c0       	rjmp	.+38     	; 0x1b94 <GPIO_writePort+0x7a>
		case PORTA_ID:
			PORTA = value;
    1b6e:	eb e3       	ldi	r30, 0x3B	; 59
    1b70:	f0 e0       	ldi	r31, 0x00	; 0
    1b72:	8a 81       	ldd	r24, Y+2	; 0x02
    1b74:	80 83       	st	Z, r24
    1b76:	0e c0       	rjmp	.+28     	; 0x1b94 <GPIO_writePort+0x7a>
			break;
		case PORTB_ID:
			PORTB = value;
    1b78:	e8 e3       	ldi	r30, 0x38	; 56
    1b7a:	f0 e0       	ldi	r31, 0x00	; 0
    1b7c:	8a 81       	ldd	r24, Y+2	; 0x02
    1b7e:	80 83       	st	Z, r24
    1b80:	09 c0       	rjmp	.+18     	; 0x1b94 <GPIO_writePort+0x7a>
			break;
		case PORTC_ID:
			PORTC = value;
    1b82:	e5 e3       	ldi	r30, 0x35	; 53
    1b84:	f0 e0       	ldi	r31, 0x00	; 0
    1b86:	8a 81       	ldd	r24, Y+2	; 0x02
    1b88:	80 83       	st	Z, r24
    1b8a:	04 c0       	rjmp	.+8      	; 0x1b94 <GPIO_writePort+0x7a>
			break;
		case PORTD_ID:
			PORTD = value;
    1b8c:	e2 e3       	ldi	r30, 0x32	; 50
    1b8e:	f0 e0       	ldi	r31, 0x00	; 0
    1b90:	8a 81       	ldd	r24, Y+2	; 0x02
    1b92:	80 83       	st	Z, r24
			break;
		}
	}
}
    1b94:	0f 90       	pop	r0
    1b96:	0f 90       	pop	r0
    1b98:	0f 90       	pop	r0
    1b9a:	0f 90       	pop	r0
    1b9c:	cf 91       	pop	r28
    1b9e:	df 91       	pop	r29
    1ba0:	08 95       	ret

00001ba2 <GPIO_readPort>:
/*
 * Description :
 * Read and return the value of the required port.
 * If the input port number is not correct, The function will return ZERO value.
 */
uint8 GPIO_readPort(uint8 port_num) {
    1ba2:	df 93       	push	r29
    1ba4:	cf 93       	push	r28
    1ba6:	00 d0       	rcall	.+0      	; 0x1ba8 <GPIO_readPort+0x6>
    1ba8:	00 d0       	rcall	.+0      	; 0x1baa <GPIO_readPort+0x8>
    1baa:	cd b7       	in	r28, 0x3d	; 61
    1bac:	de b7       	in	r29, 0x3e	; 62
    1bae:	8a 83       	std	Y+2, r24	; 0x02
	uint8 value = LOGIC_LOW;
    1bb0:	19 82       	std	Y+1, r1	; 0x01

	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if (port_num >= NUM_OF_PORTS) {
    1bb2:	8a 81       	ldd	r24, Y+2	; 0x02
    1bb4:	84 30       	cpi	r24, 0x04	; 4
    1bb6:	90 f5       	brcc	.+100    	; 0x1c1c <GPIO_readPort+0x7a>
		/* Do Nothing */
	} else {
		/* Read the port value as required */
		switch (port_num) {
    1bb8:	8a 81       	ldd	r24, Y+2	; 0x02
    1bba:	28 2f       	mov	r18, r24
    1bbc:	30 e0       	ldi	r19, 0x00	; 0
    1bbe:	3c 83       	std	Y+4, r19	; 0x04
    1bc0:	2b 83       	std	Y+3, r18	; 0x03
    1bc2:	8b 81       	ldd	r24, Y+3	; 0x03
    1bc4:	9c 81       	ldd	r25, Y+4	; 0x04
    1bc6:	81 30       	cpi	r24, 0x01	; 1
    1bc8:	91 05       	cpc	r25, r1
    1bca:	d1 f0       	breq	.+52     	; 0x1c00 <GPIO_readPort+0x5e>
    1bcc:	2b 81       	ldd	r18, Y+3	; 0x03
    1bce:	3c 81       	ldd	r19, Y+4	; 0x04
    1bd0:	22 30       	cpi	r18, 0x02	; 2
    1bd2:	31 05       	cpc	r19, r1
    1bd4:	2c f4       	brge	.+10     	; 0x1be0 <GPIO_readPort+0x3e>
    1bd6:	8b 81       	ldd	r24, Y+3	; 0x03
    1bd8:	9c 81       	ldd	r25, Y+4	; 0x04
    1bda:	00 97       	sbiw	r24, 0x00	; 0
    1bdc:	61 f0       	breq	.+24     	; 0x1bf6 <GPIO_readPort+0x54>
    1bde:	1e c0       	rjmp	.+60     	; 0x1c1c <GPIO_readPort+0x7a>
    1be0:	2b 81       	ldd	r18, Y+3	; 0x03
    1be2:	3c 81       	ldd	r19, Y+4	; 0x04
    1be4:	22 30       	cpi	r18, 0x02	; 2
    1be6:	31 05       	cpc	r19, r1
    1be8:	81 f0       	breq	.+32     	; 0x1c0a <GPIO_readPort+0x68>
    1bea:	8b 81       	ldd	r24, Y+3	; 0x03
    1bec:	9c 81       	ldd	r25, Y+4	; 0x04
    1bee:	83 30       	cpi	r24, 0x03	; 3
    1bf0:	91 05       	cpc	r25, r1
    1bf2:	81 f0       	breq	.+32     	; 0x1c14 <GPIO_readPort+0x72>
    1bf4:	13 c0       	rjmp	.+38     	; 0x1c1c <GPIO_readPort+0x7a>
		case PORTA_ID:
			value = PINA;
    1bf6:	e9 e3       	ldi	r30, 0x39	; 57
    1bf8:	f0 e0       	ldi	r31, 0x00	; 0
    1bfa:	80 81       	ld	r24, Z
    1bfc:	89 83       	std	Y+1, r24	; 0x01
    1bfe:	0e c0       	rjmp	.+28     	; 0x1c1c <GPIO_readPort+0x7a>
			break;
		case PORTB_ID:
			value = PINB;
    1c00:	e6 e3       	ldi	r30, 0x36	; 54
    1c02:	f0 e0       	ldi	r31, 0x00	; 0
    1c04:	80 81       	ld	r24, Z
    1c06:	89 83       	std	Y+1, r24	; 0x01
    1c08:	09 c0       	rjmp	.+18     	; 0x1c1c <GPIO_readPort+0x7a>
			break;
		case PORTC_ID:
			value = PINC;
    1c0a:	e3 e3       	ldi	r30, 0x33	; 51
    1c0c:	f0 e0       	ldi	r31, 0x00	; 0
    1c0e:	80 81       	ld	r24, Z
    1c10:	89 83       	std	Y+1, r24	; 0x01
    1c12:	04 c0       	rjmp	.+8      	; 0x1c1c <GPIO_readPort+0x7a>
			break;
		case PORTD_ID:
			value = PIND;
    1c14:	e0 e3       	ldi	r30, 0x30	; 48
    1c16:	f0 e0       	ldi	r31, 0x00	; 0
    1c18:	80 81       	ld	r24, Z
    1c1a:	89 83       	std	Y+1, r24	; 0x01
			break;
		}
	}

	return value;
    1c1c:	89 81       	ldd	r24, Y+1	; 0x01
}
    1c1e:	0f 90       	pop	r0
    1c20:	0f 90       	pop	r0
    1c22:	0f 90       	pop	r0
    1c24:	0f 90       	pop	r0
    1c26:	cf 91       	pop	r28
    1c28:	df 91       	pop	r29
    1c2a:	08 95       	ret

00001c2c <global_interput_int>:
#include "../../lib/common_macros.h"
#include "global_interput_Reg.h"
/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/
void global_interput_int(void) {
    1c2c:	df 93       	push	r29
    1c2e:	cf 93       	push	r28
    1c30:	cd b7       	in	r28, 0x3d	; 61
    1c32:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG, I_BIT);
    1c34:	af e5       	ldi	r26, 0x5F	; 95
    1c36:	b0 e0       	ldi	r27, 0x00	; 0
    1c38:	ef e5       	ldi	r30, 0x5F	; 95
    1c3a:	f0 e0       	ldi	r31, 0x00	; 0
    1c3c:	80 81       	ld	r24, Z
    1c3e:	80 68       	ori	r24, 0x80	; 128
    1c40:	8c 93       	st	X, r24
}
    1c42:	cf 91       	pop	r28
    1c44:	df 91       	pop	r29
    1c46:	08 95       	ret

00001c48 <EEPROM_writeByte>:
 */
#include "external_eeprom.h"

#include "../../mcal/twi/twi.h"

uint8 EEPROM_writeByte(uint16 u16addr, uint8 u8data) {
    1c48:	df 93       	push	r29
    1c4a:	cf 93       	push	r28
    1c4c:	00 d0       	rcall	.+0      	; 0x1c4e <EEPROM_writeByte+0x6>
    1c4e:	00 d0       	rcall	.+0      	; 0x1c50 <EEPROM_writeByte+0x8>
    1c50:	cd b7       	in	r28, 0x3d	; 61
    1c52:	de b7       	in	r29, 0x3e	; 62
    1c54:	9a 83       	std	Y+2, r25	; 0x02
    1c56:	89 83       	std	Y+1, r24	; 0x01
    1c58:	6b 83       	std	Y+3, r22	; 0x03
	/* Send the Start Bit */
	TWI_start();
    1c5a:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <TWI_start>
	if (TWI_getStatus() != TWI_START)
    1c5e:	0e 94 af 09 	call	0x135e	; 0x135e <TWI_getStatus>
    1c62:	88 30       	cpi	r24, 0x08	; 8
    1c64:	11 f0       	breq	.+4      	; 0x1c6a <EEPROM_writeByte+0x22>
		return ERROR;
    1c66:	1c 82       	std	Y+4, r1	; 0x04
    1c68:	28 c0       	rjmp	.+80     	; 0x1cba <EEPROM_writeByte+0x72>

	/* Send the device address, we need to get A8 A9 A10 address bits from the
	 * memory location address and R/W=0 (write) */
	TWI_writeByte((uint8) (0xA0 | ((u16addr & 0x0700) >> 7)));
    1c6a:	89 81       	ldd	r24, Y+1	; 0x01
    1c6c:	9a 81       	ldd	r25, Y+2	; 0x02
    1c6e:	80 70       	andi	r24, 0x00	; 0
    1c70:	97 70       	andi	r25, 0x07	; 7
    1c72:	88 0f       	add	r24, r24
    1c74:	89 2f       	mov	r24, r25
    1c76:	88 1f       	adc	r24, r24
    1c78:	99 0b       	sbc	r25, r25
    1c7a:	91 95       	neg	r25
    1c7c:	80 6a       	ori	r24, 0xA0	; 160
    1c7e:	0e 94 21 09 	call	0x1242	; 0x1242 <TWI_writeByte>
	if (TWI_getStatus() != TWI_MT_SLA_W_ACK)
    1c82:	0e 94 af 09 	call	0x135e	; 0x135e <TWI_getStatus>
    1c86:	88 31       	cpi	r24, 0x18	; 24
    1c88:	11 f0       	breq	.+4      	; 0x1c8e <EEPROM_writeByte+0x46>
		return ERROR;
    1c8a:	1c 82       	std	Y+4, r1	; 0x04
    1c8c:	16 c0       	rjmp	.+44     	; 0x1cba <EEPROM_writeByte+0x72>

	/* Send the required memory location address */
	TWI_writeByte((uint8) (u16addr));
    1c8e:	89 81       	ldd	r24, Y+1	; 0x01
    1c90:	0e 94 21 09 	call	0x1242	; 0x1242 <TWI_writeByte>
	if (TWI_getStatus() != TWI_MT_DATA_ACK)
    1c94:	0e 94 af 09 	call	0x135e	; 0x135e <TWI_getStatus>
    1c98:	88 32       	cpi	r24, 0x28	; 40
    1c9a:	11 f0       	breq	.+4      	; 0x1ca0 <EEPROM_writeByte+0x58>
		return ERROR;
    1c9c:	1c 82       	std	Y+4, r1	; 0x04
    1c9e:	0d c0       	rjmp	.+26     	; 0x1cba <EEPROM_writeByte+0x72>

	/* write byte to eeprom */
	TWI_writeByte(u8data);
    1ca0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ca2:	0e 94 21 09 	call	0x1242	; 0x1242 <TWI_writeByte>
	if (TWI_getStatus() != TWI_MT_DATA_ACK)
    1ca6:	0e 94 af 09 	call	0x135e	; 0x135e <TWI_getStatus>
    1caa:	88 32       	cpi	r24, 0x28	; 40
    1cac:	11 f0       	breq	.+4      	; 0x1cb2 <EEPROM_writeByte+0x6a>
		return ERROR;
    1cae:	1c 82       	std	Y+4, r1	; 0x04
    1cb0:	04 c0       	rjmp	.+8      	; 0x1cba <EEPROM_writeByte+0x72>

	/* Send the Stop Bit */
	TWI_stop();
    1cb2:	0e 94 fc 08 	call	0x11f8	; 0x11f8 <TWI_stop>

	return SUCCESS;
    1cb6:	81 e0       	ldi	r24, 0x01	; 1
    1cb8:	8c 83       	std	Y+4, r24	; 0x04
    1cba:	8c 81       	ldd	r24, Y+4	; 0x04
}
    1cbc:	0f 90       	pop	r0
    1cbe:	0f 90       	pop	r0
    1cc0:	0f 90       	pop	r0
    1cc2:	0f 90       	pop	r0
    1cc4:	cf 91       	pop	r28
    1cc6:	df 91       	pop	r29
    1cc8:	08 95       	ret

00001cca <EEPROM_readByte>:

uint8 EEPROM_readByte(uint16 u16addr, uint8 *u8data) {
    1cca:	df 93       	push	r29
    1ccc:	cf 93       	push	r28
    1cce:	00 d0       	rcall	.+0      	; 0x1cd0 <EEPROM_readByte+0x6>
    1cd0:	00 d0       	rcall	.+0      	; 0x1cd2 <EEPROM_readByte+0x8>
    1cd2:	0f 92       	push	r0
    1cd4:	cd b7       	in	r28, 0x3d	; 61
    1cd6:	de b7       	in	r29, 0x3e	; 62
    1cd8:	9a 83       	std	Y+2, r25	; 0x02
    1cda:	89 83       	std	Y+1, r24	; 0x01
    1cdc:	7c 83       	std	Y+4, r23	; 0x04
    1cde:	6b 83       	std	Y+3, r22	; 0x03
	/* Send the Start Bit */
	TWI_start();
    1ce0:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <TWI_start>
	if (TWI_getStatus() != TWI_START)
    1ce4:	0e 94 af 09 	call	0x135e	; 0x135e <TWI_getStatus>
    1ce8:	88 30       	cpi	r24, 0x08	; 8
    1cea:	11 f0       	breq	.+4      	; 0x1cf0 <EEPROM_readByte+0x26>
		return ERROR;
    1cec:	1d 82       	std	Y+5, r1	; 0x05
    1cee:	44 c0       	rjmp	.+136    	; 0x1d78 <EEPROM_readByte+0xae>

	/* Send the device address, we need to get A8 A9 A10 address bits from the
	 * memory location address and R/W=0 (write) */
	TWI_writeByte((uint8) ((0xA0) | ((u16addr & 0x0700) >> 7)));
    1cf0:	89 81       	ldd	r24, Y+1	; 0x01
    1cf2:	9a 81       	ldd	r25, Y+2	; 0x02
    1cf4:	80 70       	andi	r24, 0x00	; 0
    1cf6:	97 70       	andi	r25, 0x07	; 7
    1cf8:	88 0f       	add	r24, r24
    1cfa:	89 2f       	mov	r24, r25
    1cfc:	88 1f       	adc	r24, r24
    1cfe:	99 0b       	sbc	r25, r25
    1d00:	91 95       	neg	r25
    1d02:	80 6a       	ori	r24, 0xA0	; 160
    1d04:	0e 94 21 09 	call	0x1242	; 0x1242 <TWI_writeByte>
	if (TWI_getStatus() != TWI_MT_SLA_W_ACK)
    1d08:	0e 94 af 09 	call	0x135e	; 0x135e <TWI_getStatus>
    1d0c:	88 31       	cpi	r24, 0x18	; 24
    1d0e:	11 f0       	breq	.+4      	; 0x1d14 <EEPROM_readByte+0x4a>
		return ERROR;
    1d10:	1d 82       	std	Y+5, r1	; 0x05
    1d12:	32 c0       	rjmp	.+100    	; 0x1d78 <EEPROM_readByte+0xae>

	/* Send the required memory location address */
	TWI_writeByte((uint8) (u16addr));
    1d14:	89 81       	ldd	r24, Y+1	; 0x01
    1d16:	0e 94 21 09 	call	0x1242	; 0x1242 <TWI_writeByte>
	if (TWI_getStatus() != TWI_MT_DATA_ACK)
    1d1a:	0e 94 af 09 	call	0x135e	; 0x135e <TWI_getStatus>
    1d1e:	88 32       	cpi	r24, 0x28	; 40
    1d20:	11 f0       	breq	.+4      	; 0x1d26 <EEPROM_readByte+0x5c>
		return ERROR;
    1d22:	1d 82       	std	Y+5, r1	; 0x05
    1d24:	29 c0       	rjmp	.+82     	; 0x1d78 <EEPROM_readByte+0xae>

	/* Send the Repeated Start Bit */
	TWI_start();
    1d26:	0e 94 d1 08 	call	0x11a2	; 0x11a2 <TWI_start>
	if (TWI_getStatus() != TWI_REP_START)
    1d2a:	0e 94 af 09 	call	0x135e	; 0x135e <TWI_getStatus>
    1d2e:	80 31       	cpi	r24, 0x10	; 16
    1d30:	11 f0       	breq	.+4      	; 0x1d36 <EEPROM_readByte+0x6c>
		return ERROR;
    1d32:	1d 82       	std	Y+5, r1	; 0x05
    1d34:	21 c0       	rjmp	.+66     	; 0x1d78 <EEPROM_readByte+0xae>

	/* Send the device address, we need to get A8 A9 A10 address bits from the
	 * memory location address and R/W=1 (Read) */
	TWI_writeByte((uint8) ((0xA0) | ((u16addr & 0x0700) >> 7) | 1));
    1d36:	89 81       	ldd	r24, Y+1	; 0x01
    1d38:	9a 81       	ldd	r25, Y+2	; 0x02
    1d3a:	80 70       	andi	r24, 0x00	; 0
    1d3c:	97 70       	andi	r25, 0x07	; 7
    1d3e:	88 0f       	add	r24, r24
    1d40:	89 2f       	mov	r24, r25
    1d42:	88 1f       	adc	r24, r24
    1d44:	99 0b       	sbc	r25, r25
    1d46:	91 95       	neg	r25
    1d48:	81 6a       	ori	r24, 0xA1	; 161
    1d4a:	0e 94 21 09 	call	0x1242	; 0x1242 <TWI_writeByte>
	if (TWI_getStatus() != TWI_MT_SLA_R_ACK)
    1d4e:	0e 94 af 09 	call	0x135e	; 0x135e <TWI_getStatus>
    1d52:	80 34       	cpi	r24, 0x40	; 64
    1d54:	11 f0       	breq	.+4      	; 0x1d5a <EEPROM_readByte+0x90>
		return ERROR;
    1d56:	1d 82       	std	Y+5, r1	; 0x05
    1d58:	0f c0       	rjmp	.+30     	; 0x1d78 <EEPROM_readByte+0xae>

	/* Read Byte from Memory without send ACK */
	*u8data = TWI_readByteWithNACK();
    1d5a:	0e 94 81 09 	call	0x1302	; 0x1302 <TWI_readByteWithNACK>
    1d5e:	eb 81       	ldd	r30, Y+3	; 0x03
    1d60:	fc 81       	ldd	r31, Y+4	; 0x04
    1d62:	80 83       	st	Z, r24
	if (TWI_getStatus() != TWI_MR_DATA_NACK)
    1d64:	0e 94 af 09 	call	0x135e	; 0x135e <TWI_getStatus>
    1d68:	88 35       	cpi	r24, 0x58	; 88
    1d6a:	11 f0       	breq	.+4      	; 0x1d70 <EEPROM_readByte+0xa6>
		return ERROR;
    1d6c:	1d 82       	std	Y+5, r1	; 0x05
    1d6e:	04 c0       	rjmp	.+8      	; 0x1d78 <EEPROM_readByte+0xae>

	/* Send the Stop Bit */
	TWI_stop();
    1d70:	0e 94 fc 08 	call	0x11f8	; 0x11f8 <TWI_stop>

	return SUCCESS;
    1d74:	81 e0       	ldi	r24, 0x01	; 1
    1d76:	8d 83       	std	Y+5, r24	; 0x05
    1d78:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1d7a:	0f 90       	pop	r0
    1d7c:	0f 90       	pop	r0
    1d7e:	0f 90       	pop	r0
    1d80:	0f 90       	pop	r0
    1d82:	0f 90       	pop	r0
    1d84:	cf 91       	pop	r28
    1d86:	df 91       	pop	r29
    1d88:	08 95       	ret

00001d8a <DcMotor_Init>:
 * Description
  The Function responsible for setup the direction for the two
 motor pins through the GPIO driver.
  Stop at the DC-Motor at the beginning through the GPIO driver.
 */
void DcMotor_Init(void) {
    1d8a:	df 93       	push	r29
    1d8c:	cf 93       	push	r28
    1d8e:	cd b7       	in	r28, 0x3d	; 61
    1d90:	de b7       	in	r29, 0x3e	; 62
	/*out pin*/
	GPIO_setupPinDirection(DC_MOTOR_PORT, DC_MOTOR_PIN0, PIN_OUTPUT);
    1d92:	81 e0       	ldi	r24, 0x01	; 1
    1d94:	60 e0       	ldi	r22, 0x00	; 0
    1d96:	41 e0       	ldi	r20, 0x01	; 1
    1d98:	0e 94 d8 0a 	call	0x15b0	; 0x15b0 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(DC_MOTOR_PORT, DC_MOTOR_PIN1, PIN_OUTPUT);
    1d9c:	81 e0       	ldi	r24, 0x01	; 1
    1d9e:	61 e0       	ldi	r22, 0x01	; 1
    1da0:	41 e0       	ldi	r20, 0x01	; 1
    1da2:	0e 94 d8 0a 	call	0x15b0	; 0x15b0 <GPIO_setupPinDirection>
	/*Stop*/
	GPIO_writePin(DC_MOTOR_PORT, DC_MOTOR_PIN0, LOGIC_LOW);
    1da6:	81 e0       	ldi	r24, 0x01	; 1
    1da8:	60 e0       	ldi	r22, 0x00	; 0
    1daa:	40 e0       	ldi	r20, 0x00	; 0
    1dac:	0e 94 c3 0b 	call	0x1786	; 0x1786 <GPIO_writePin>
	GPIO_writePin(DC_MOTOR_PORT, DC_MOTOR_PIN1, LOGIC_LOW);
    1db0:	81 e0       	ldi	r24, 0x01	; 1
    1db2:	61 e0       	ldi	r22, 0x01	; 1
    1db4:	40 e0       	ldi	r20, 0x00	; 0
    1db6:	0e 94 c3 0b 	call	0x1786	; 0x1786 <GPIO_writePin>
}
    1dba:	cf 91       	pop	r28
    1dbc:	df 91       	pop	r29
    1dbe:	08 95       	ret

00001dc0 <DcMotor_Rotate>:
  The function responsible for rotate the DC Motor CW/ or A-CW or
 stop the motor based on the state input state value.
  Send the required duty cycle to the PWM driver based on the
 required speed value.
 */
void DcMotor_Rotate(DcMotor_State state, uint8 speed) {
    1dc0:	df 93       	push	r29
    1dc2:	cf 93       	push	r28
    1dc4:	00 d0       	rcall	.+0      	; 0x1dc6 <DcMotor_Rotate+0x6>
    1dc6:	00 d0       	rcall	.+0      	; 0x1dc8 <DcMotor_Rotate+0x8>
    1dc8:	0f 92       	push	r0
    1dca:	cd b7       	in	r28, 0x3d	; 61
    1dcc:	de b7       	in	r29, 0x3e	; 62
    1dce:	8a 83       	std	Y+2, r24	; 0x02
    1dd0:	6b 83       	std	Y+3, r22	; 0x03
	uint8 duty_cycle;
	/*to get state*/
	switch (state) {
    1dd2:	8a 81       	ldd	r24, Y+2	; 0x02
    1dd4:	28 2f       	mov	r18, r24
    1dd6:	30 e0       	ldi	r19, 0x00	; 0
    1dd8:	3d 83       	std	Y+5, r19	; 0x05
    1dda:	2c 83       	std	Y+4, r18	; 0x04
    1ddc:	8c 81       	ldd	r24, Y+4	; 0x04
    1dde:	9d 81       	ldd	r25, Y+5	; 0x05
    1de0:	81 30       	cpi	r24, 0x01	; 1
    1de2:	91 05       	cpc	r25, r1
    1de4:	a1 f0       	breq	.+40     	; 0x1e0e <DcMotor_Rotate+0x4e>
    1de6:	2c 81       	ldd	r18, Y+4	; 0x04
    1de8:	3d 81       	ldd	r19, Y+5	; 0x05
    1dea:	22 30       	cpi	r18, 0x02	; 2
    1dec:	31 05       	cpc	r19, r1
    1dee:	d1 f0       	breq	.+52     	; 0x1e24 <DcMotor_Rotate+0x64>
    1df0:	8c 81       	ldd	r24, Y+4	; 0x04
    1df2:	9d 81       	ldd	r25, Y+5	; 0x05
    1df4:	00 97       	sbiw	r24, 0x00	; 0
    1df6:	01 f5       	brne	.+64     	; 0x1e38 <DcMotor_Rotate+0x78>
	case off:
		GPIO_writePin(DC_MOTOR_PORT, DC_MOTOR_PIN0, LOGIC_LOW);
    1df8:	81 e0       	ldi	r24, 0x01	; 1
    1dfa:	60 e0       	ldi	r22, 0x00	; 0
    1dfc:	40 e0       	ldi	r20, 0x00	; 0
    1dfe:	0e 94 c3 0b 	call	0x1786	; 0x1786 <GPIO_writePin>
		GPIO_writePin(DC_MOTOR_PORT, DC_MOTOR_PIN1, LOGIC_LOW);
    1e02:	81 e0       	ldi	r24, 0x01	; 1
    1e04:	61 e0       	ldi	r22, 0x01	; 1
    1e06:	40 e0       	ldi	r20, 0x00	; 0
    1e08:	0e 94 c3 0b 	call	0x1786	; 0x1786 <GPIO_writePin>
    1e0c:	15 c0       	rjmp	.+42     	; 0x1e38 <DcMotor_Rotate+0x78>
		break;
	case CW:
		GPIO_writePin(DC_MOTOR_PORT, DC_MOTOR_PIN0, LOGIC_HIGH);
    1e0e:	81 e0       	ldi	r24, 0x01	; 1
    1e10:	60 e0       	ldi	r22, 0x00	; 0
    1e12:	41 e0       	ldi	r20, 0x01	; 1
    1e14:	0e 94 c3 0b 	call	0x1786	; 0x1786 <GPIO_writePin>
		GPIO_writePin(DC_MOTOR_PORT, DC_MOTOR_PIN1, LOGIC_LOW);
    1e18:	81 e0       	ldi	r24, 0x01	; 1
    1e1a:	61 e0       	ldi	r22, 0x01	; 1
    1e1c:	40 e0       	ldi	r20, 0x00	; 0
    1e1e:	0e 94 c3 0b 	call	0x1786	; 0x1786 <GPIO_writePin>
    1e22:	0a c0       	rjmp	.+20     	; 0x1e38 <DcMotor_Rotate+0x78>
		break;
	case A_CW:
		GPIO_writePin(DC_MOTOR_PORT, DC_MOTOR_PIN0, LOGIC_LOW);
    1e24:	81 e0       	ldi	r24, 0x01	; 1
    1e26:	60 e0       	ldi	r22, 0x00	; 0
    1e28:	40 e0       	ldi	r20, 0x00	; 0
    1e2a:	0e 94 c3 0b 	call	0x1786	; 0x1786 <GPIO_writePin>
		GPIO_writePin(DC_MOTOR_PORT, DC_MOTOR_PIN1, LOGIC_HIGH);
    1e2e:	81 e0       	ldi	r24, 0x01	; 1
    1e30:	61 e0       	ldi	r22, 0x01	; 1
    1e32:	41 e0       	ldi	r20, 0x01	; 1
    1e34:	0e 94 c3 0b 	call	0x1786	; 0x1786 <GPIO_writePin>
		break;
	default:
		break;
	}
	/*Speed*/
	if (speed > 100) {
    1e38:	8b 81       	ldd	r24, Y+3	; 0x03
    1e3a:	85 36       	cpi	r24, 0x65	; 101
    1e3c:	10 f0       	brcs	.+4      	; 0x1e42 <DcMotor_Rotate+0x82>
		speed = 100;
    1e3e:	84 e6       	ldi	r24, 0x64	; 100
    1e40:	8b 83       	std	Y+3, r24	; 0x03
	}
	if (speed < 0) {
		speed = 0;
	}
	duty_cycle = ((float32) speed / 100) * REG_TIMER_0_SIZE;
    1e42:	8b 81       	ldd	r24, Y+3	; 0x03
    1e44:	88 2f       	mov	r24, r24
    1e46:	90 e0       	ldi	r25, 0x00	; 0
    1e48:	a0 e0       	ldi	r26, 0x00	; 0
    1e4a:	b0 e0       	ldi	r27, 0x00	; 0
    1e4c:	bc 01       	movw	r22, r24
    1e4e:	cd 01       	movw	r24, r26
    1e50:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    1e54:	dc 01       	movw	r26, r24
    1e56:	cb 01       	movw	r24, r22
    1e58:	bc 01       	movw	r22, r24
    1e5a:	cd 01       	movw	r24, r26
    1e5c:	20 e0       	ldi	r18, 0x00	; 0
    1e5e:	30 e0       	ldi	r19, 0x00	; 0
    1e60:	48 ec       	ldi	r20, 0xC8	; 200
    1e62:	52 e4       	ldi	r21, 0x42	; 66
    1e64:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1e68:	dc 01       	movw	r26, r24
    1e6a:	cb 01       	movw	r24, r22
    1e6c:	bc 01       	movw	r22, r24
    1e6e:	cd 01       	movw	r24, r26
    1e70:	20 e0       	ldi	r18, 0x00	; 0
    1e72:	30 e0       	ldi	r19, 0x00	; 0
    1e74:	4f e7       	ldi	r20, 0x7F	; 127
    1e76:	53 e4       	ldi	r21, 0x43	; 67
    1e78:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1e7c:	dc 01       	movw	r26, r24
    1e7e:	cb 01       	movw	r24, r22
    1e80:	bc 01       	movw	r22, r24
    1e82:	cd 01       	movw	r24, r26
    1e84:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e88:	dc 01       	movw	r26, r24
    1e8a:	cb 01       	movw	r24, r22
    1e8c:	89 83       	std	Y+1, r24	; 0x01
	PWM_Timer0_Start(duty_cycle);
    1e8e:	89 81       	ldd	r24, Y+1	; 0x01
    1e90:	0e 94 bc 0a 	call	0x1578	; 0x1578 <PWM_Timer0_Start>

}
    1e94:	0f 90       	pop	r0
    1e96:	0f 90       	pop	r0
    1e98:	0f 90       	pop	r0
    1e9a:	0f 90       	pop	r0
    1e9c:	0f 90       	pop	r0
    1e9e:	cf 91       	pop	r28
    1ea0:	df 91       	pop	r29
    1ea2:	08 95       	ret

00001ea4 <Buzzer_init>:
/*
 * Description
  Setup the direction for the buzzer pin as output pin through the
 GPIO driver.
  Turn off the buzzer through the GPIO.*/
void Buzzer_init() {
    1ea4:	df 93       	push	r29
    1ea6:	cf 93       	push	r28
    1ea8:	cd b7       	in	r28, 0x3d	; 61
    1eaa:	de b7       	in	r29, 0x3e	; 62
	GPIO_setupPinDirection(BUZZER_PORT, BUZZER_PIN, PIN_OUTPUT);
    1eac:	82 e0       	ldi	r24, 0x02	; 2
    1eae:	65 e0       	ldi	r22, 0x05	; 5
    1eb0:	41 e0       	ldi	r20, 0x01	; 1
    1eb2:	0e 94 d8 0a 	call	0x15b0	; 0x15b0 <GPIO_setupPinDirection>
	GPIO_writePin(BUZZER_PORT, BUZZER_PIN, LOGIC_LOW);
    1eb6:	82 e0       	ldi	r24, 0x02	; 2
    1eb8:	65 e0       	ldi	r22, 0x05	; 5
    1eba:	40 e0       	ldi	r20, 0x00	; 0
    1ebc:	0e 94 c3 0b 	call	0x1786	; 0x1786 <GPIO_writePin>
}
    1ec0:	cf 91       	pop	r28
    1ec2:	df 91       	pop	r29
    1ec4:	08 95       	ret

00001ec6 <Buzzer_on>:
/*
 * Description
  Function to enable the Buzzer through the GPIO*/
void Buzzer_on() {
    1ec6:	df 93       	push	r29
    1ec8:	cf 93       	push	r28
    1eca:	cd b7       	in	r28, 0x3d	; 61
    1ecc:	de b7       	in	r29, 0x3e	; 62
	GPIO_writePin(BUZZER_PORT, BUZZER_PIN, LOGIC_HIGH);
    1ece:	82 e0       	ldi	r24, 0x02	; 2
    1ed0:	65 e0       	ldi	r22, 0x05	; 5
    1ed2:	41 e0       	ldi	r20, 0x01	; 1
    1ed4:	0e 94 c3 0b 	call	0x1786	; 0x1786 <GPIO_writePin>
}
    1ed8:	cf 91       	pop	r28
    1eda:	df 91       	pop	r29
    1edc:	08 95       	ret

00001ede <Buzzer_off>:
/*
 * Description
  Function to disable the Buzzer through the GPIO.
 */
void Buzzer_off(void) {
    1ede:	df 93       	push	r29
    1ee0:	cf 93       	push	r28
    1ee2:	cd b7       	in	r28, 0x3d	; 61
    1ee4:	de b7       	in	r29, 0x3e	; 62
	GPIO_writePin(BUZZER_PORT, BUZZER_PIN, LOGIC_LOW);
    1ee6:	82 e0       	ldi	r24, 0x02	; 2
    1ee8:	65 e0       	ldi	r22, 0x05	; 5
    1eea:	40 e0       	ldi	r20, 0x00	; 0
    1eec:	0e 94 c3 0b 	call	0x1786	; 0x1786 <GPIO_writePin>

}
    1ef0:	cf 91       	pop	r28
    1ef2:	df 91       	pop	r29
    1ef4:	08 95       	ret

00001ef6 <main>:
void count_Seconds(void);
void Delay_By_Uing_Timer1_Using_interput(uint16 SecDelay);
/*******************************************************************************
 *                                    main                                     *
 *******************************************************************************/
int main(void) {
    1ef6:	0f 93       	push	r16
    1ef8:	1f 93       	push	r17
    1efa:	df 93       	push	r29
    1efc:	cf 93       	push	r28
    1efe:	cd b7       	in	r28, 0x3d	; 61
    1f00:	de b7       	in	r29, 0x3e	; 62
    1f02:	c3 5f       	subi	r28, 0xF3	; 243
    1f04:	d0 40       	sbci	r29, 0x00	; 0
    1f06:	0f b6       	in	r0, 0x3f	; 63
    1f08:	f8 94       	cli
    1f0a:	de bf       	out	0x3e, r29	; 62
    1f0c:	0f be       	out	0x3f, r0	; 63
    1f0e:	cd bf       	out	0x3d, r28	; 61
	/*password_counter_digit-> for loobs
	 *state -> to control  main
	 *password[5] -> to save pass frist time
	 *confirmation_password[5] -> to renter pass*/
	uint8 password_counter_digit = 0, state = CREATE_PASS;
    1f10:	fe 01       	movw	r30, r28
    1f12:	e1 53       	subi	r30, 0x31	; 49
    1f14:	ff 4f       	sbci	r31, 0xFF	; 255
    1f16:	10 82       	st	Z, r1
    1f18:	fe 01       	movw	r30, r28
    1f1a:	e2 53       	subi	r30, 0x32	; 50
    1f1c:	ff 4f       	sbci	r31, 0xFF	; 255
    1f1e:	10 82       	st	Z, r1
	boolean matched_pass_flag = 7;
    1f20:	fe 01       	movw	r30, r28
    1f22:	e3 53       	subi	r30, 0x33	; 51
    1f24:	ff 4f       	sbci	r31, 0xFF	; 255
    1f26:	87 e0       	ldi	r24, 0x07	; 7
    1f28:	80 83       	st	Z, r24
	uint8 password[5] = { 0, 0, 0, 0, 0 }, confirmation_password[5] = { 1, 1, 1,
    1f2a:	ce 01       	movw	r24, r28
    1f2c:	80 53       	subi	r24, 0x30	; 48
    1f2e:	9f 4f       	sbci	r25, 0xFF	; 255
    1f30:	25 e0       	ldi	r18, 0x05	; 5
    1f32:	fc 01       	movw	r30, r24
    1f34:	df 01       	movw	r26, r30
    1f36:	82 2f       	mov	r24, r18
    1f38:	1d 92       	st	X+, r1
    1f3a:	8a 95       	dec	r24
    1f3c:	e9 f7       	brne	.-6      	; 0x1f38 <main+0x42>
			1, 1 };
    1f3e:	ce 01       	movw	r24, r28
    1f40:	8b 52       	subi	r24, 0x2B	; 43
    1f42:	9f 4f       	sbci	r25, 0xFF	; 255
    1f44:	cb 51       	subi	r28, 0x1B	; 27
    1f46:	df 4f       	sbci	r29, 0xFF	; 255
    1f48:	99 83       	std	Y+1, r25	; 0x01
    1f4a:	88 83       	st	Y, r24
    1f4c:	c5 5e       	subi	r28, 0xE5	; 229
    1f4e:	d0 40       	sbci	r29, 0x00	; 0
    1f50:	a3 e7       	ldi	r26, 0x73	; 115
    1f52:	b1 e0       	ldi	r27, 0x01	; 1
    1f54:	c9 51       	subi	r28, 0x19	; 25
    1f56:	df 4f       	sbci	r29, 0xFF	; 255
    1f58:	b9 83       	std	Y+1, r27	; 0x01
    1f5a:	a8 83       	st	Y, r26
    1f5c:	c7 5e       	subi	r28, 0xE7	; 231
    1f5e:	d0 40       	sbci	r29, 0x00	; 0
    1f60:	b5 e0       	ldi	r27, 0x05	; 5
    1f62:	c7 51       	subi	r28, 0x17	; 23
    1f64:	df 4f       	sbci	r29, 0xFF	; 255
    1f66:	b8 83       	st	Y, r27
    1f68:	c9 5e       	subi	r28, 0xE9	; 233
    1f6a:	d0 40       	sbci	r29, 0x00	; 0
    1f6c:	c9 51       	subi	r28, 0x19	; 25
    1f6e:	df 4f       	sbci	r29, 0xFF	; 255
    1f70:	e8 81       	ld	r30, Y
    1f72:	f9 81       	ldd	r31, Y+1	; 0x01
    1f74:	c7 5e       	subi	r28, 0xE7	; 231
    1f76:	d0 40       	sbci	r29, 0x00	; 0
    1f78:	00 80       	ld	r0, Z
    1f7a:	c9 51       	subi	r28, 0x19	; 25
    1f7c:	df 4f       	sbci	r29, 0xFF	; 255
    1f7e:	88 81       	ld	r24, Y
    1f80:	99 81       	ldd	r25, Y+1	; 0x01
    1f82:	c7 5e       	subi	r28, 0xE7	; 231
    1f84:	d0 40       	sbci	r29, 0x00	; 0
    1f86:	01 96       	adiw	r24, 0x01	; 1
    1f88:	c9 51       	subi	r28, 0x19	; 25
    1f8a:	df 4f       	sbci	r29, 0xFF	; 255
    1f8c:	99 83       	std	Y+1, r25	; 0x01
    1f8e:	88 83       	st	Y, r24
    1f90:	c7 5e       	subi	r28, 0xE7	; 231
    1f92:	d0 40       	sbci	r29, 0x00	; 0
    1f94:	cb 51       	subi	r28, 0x1B	; 27
    1f96:	df 4f       	sbci	r29, 0xFF	; 255
    1f98:	a8 81       	ld	r26, Y
    1f9a:	b9 81       	ldd	r27, Y+1	; 0x01
    1f9c:	c5 5e       	subi	r28, 0xE5	; 229
    1f9e:	d0 40       	sbci	r29, 0x00	; 0
    1fa0:	0c 92       	st	X, r0
    1fa2:	cb 51       	subi	r28, 0x1B	; 27
    1fa4:	df 4f       	sbci	r29, 0xFF	; 255
    1fa6:	e8 81       	ld	r30, Y
    1fa8:	f9 81       	ldd	r31, Y+1	; 0x01
    1faa:	c5 5e       	subi	r28, 0xE5	; 229
    1fac:	d0 40       	sbci	r29, 0x00	; 0
    1fae:	31 96       	adiw	r30, 0x01	; 1
    1fb0:	cb 51       	subi	r28, 0x1B	; 27
    1fb2:	df 4f       	sbci	r29, 0xFF	; 255
    1fb4:	f9 83       	std	Y+1, r31	; 0x01
    1fb6:	e8 83       	st	Y, r30
    1fb8:	c5 5e       	subi	r28, 0xE5	; 229
    1fba:	d0 40       	sbci	r29, 0x00	; 0
    1fbc:	c7 51       	subi	r28, 0x17	; 23
    1fbe:	df 4f       	sbci	r29, 0xFF	; 255
    1fc0:	f8 81       	ld	r31, Y
    1fc2:	c9 5e       	subi	r28, 0xE9	; 233
    1fc4:	d0 40       	sbci	r29, 0x00	; 0
    1fc6:	f1 50       	subi	r31, 0x01	; 1
    1fc8:	c7 51       	subi	r28, 0x17	; 23
    1fca:	df 4f       	sbci	r29, 0xFF	; 255
    1fcc:	f8 83       	st	Y, r31
    1fce:	c9 5e       	subi	r28, 0xE9	; 233
    1fd0:	d0 40       	sbci	r29, 0x00	; 0
    1fd2:	c7 51       	subi	r28, 0x17	; 23
    1fd4:	df 4f       	sbci	r29, 0xFF	; 255
    1fd6:	88 81       	ld	r24, Y
    1fd8:	c9 5e       	subi	r28, 0xE9	; 233
    1fda:	d0 40       	sbci	r29, 0x00	; 0
    1fdc:	88 23       	and	r24, r24
    1fde:	31 f6       	brne	.-116    	; 0x1f6c <main+0x76>
	/*to Setting UART*/
	UART_ConfigType uart_Config =
			{ bits_8, Parity_Disabled, one_stop_bit, 9600 };
    1fe0:	ce 01       	movw	r24, r28
    1fe2:	86 52       	subi	r24, 0x26	; 38
    1fe4:	9f 4f       	sbci	r25, 0xFF	; 255
    1fe6:	c6 51       	subi	r28, 0x16	; 22
    1fe8:	df 4f       	sbci	r29, 0xFF	; 255
    1fea:	99 83       	std	Y+1, r25	; 0x01
    1fec:	88 83       	st	Y, r24
    1fee:	ca 5e       	subi	r28, 0xEA	; 234
    1ff0:	d0 40       	sbci	r29, 0x00	; 0
    1ff2:	ae e6       	ldi	r26, 0x6E	; 110
    1ff4:	b1 e0       	ldi	r27, 0x01	; 1
    1ff6:	c4 51       	subi	r28, 0x14	; 20
    1ff8:	df 4f       	sbci	r29, 0xFF	; 255
    1ffa:	b9 83       	std	Y+1, r27	; 0x01
    1ffc:	a8 83       	st	Y, r26
    1ffe:	cc 5e       	subi	r28, 0xEC	; 236
    2000:	d0 40       	sbci	r29, 0x00	; 0
    2002:	b5 e0       	ldi	r27, 0x05	; 5
    2004:	c2 51       	subi	r28, 0x12	; 18
    2006:	df 4f       	sbci	r29, 0xFF	; 255
    2008:	b8 83       	st	Y, r27
    200a:	ce 5e       	subi	r28, 0xEE	; 238
    200c:	d0 40       	sbci	r29, 0x00	; 0
    200e:	c4 51       	subi	r28, 0x14	; 20
    2010:	df 4f       	sbci	r29, 0xFF	; 255
    2012:	e8 81       	ld	r30, Y
    2014:	f9 81       	ldd	r31, Y+1	; 0x01
    2016:	cc 5e       	subi	r28, 0xEC	; 236
    2018:	d0 40       	sbci	r29, 0x00	; 0
    201a:	00 80       	ld	r0, Z
    201c:	c4 51       	subi	r28, 0x14	; 20
    201e:	df 4f       	sbci	r29, 0xFF	; 255
    2020:	88 81       	ld	r24, Y
    2022:	99 81       	ldd	r25, Y+1	; 0x01
    2024:	cc 5e       	subi	r28, 0xEC	; 236
    2026:	d0 40       	sbci	r29, 0x00	; 0
    2028:	01 96       	adiw	r24, 0x01	; 1
    202a:	c4 51       	subi	r28, 0x14	; 20
    202c:	df 4f       	sbci	r29, 0xFF	; 255
    202e:	99 83       	std	Y+1, r25	; 0x01
    2030:	88 83       	st	Y, r24
    2032:	cc 5e       	subi	r28, 0xEC	; 236
    2034:	d0 40       	sbci	r29, 0x00	; 0
    2036:	c6 51       	subi	r28, 0x16	; 22
    2038:	df 4f       	sbci	r29, 0xFF	; 255
    203a:	a8 81       	ld	r26, Y
    203c:	b9 81       	ldd	r27, Y+1	; 0x01
    203e:	ca 5e       	subi	r28, 0xEA	; 234
    2040:	d0 40       	sbci	r29, 0x00	; 0
    2042:	0c 92       	st	X, r0
    2044:	c6 51       	subi	r28, 0x16	; 22
    2046:	df 4f       	sbci	r29, 0xFF	; 255
    2048:	e8 81       	ld	r30, Y
    204a:	f9 81       	ldd	r31, Y+1	; 0x01
    204c:	ca 5e       	subi	r28, 0xEA	; 234
    204e:	d0 40       	sbci	r29, 0x00	; 0
    2050:	31 96       	adiw	r30, 0x01	; 1
    2052:	c6 51       	subi	r28, 0x16	; 22
    2054:	df 4f       	sbci	r29, 0xFF	; 255
    2056:	f9 83       	std	Y+1, r31	; 0x01
    2058:	e8 83       	st	Y, r30
    205a:	ca 5e       	subi	r28, 0xEA	; 234
    205c:	d0 40       	sbci	r29, 0x00	; 0
    205e:	c2 51       	subi	r28, 0x12	; 18
    2060:	df 4f       	sbci	r29, 0xFF	; 255
    2062:	f8 81       	ld	r31, Y
    2064:	ce 5e       	subi	r28, 0xEE	; 238
    2066:	d0 40       	sbci	r29, 0x00	; 0
    2068:	f1 50       	subi	r31, 0x01	; 1
    206a:	c2 51       	subi	r28, 0x12	; 18
    206c:	df 4f       	sbci	r29, 0xFF	; 255
    206e:	f8 83       	st	Y, r31
    2070:	ce 5e       	subi	r28, 0xEE	; 238
    2072:	d0 40       	sbci	r29, 0x00	; 0
    2074:	c2 51       	subi	r28, 0x12	; 18
    2076:	df 4f       	sbci	r29, 0xFF	; 255
    2078:	88 81       	ld	r24, Y
    207a:	ce 5e       	subi	r28, 0xEE	; 238
    207c:	d0 40       	sbci	r29, 0x00	; 0
    207e:	88 23       	and	r24, r24
    2080:	31 f6       	brne	.-116    	; 0x200e <main+0x118>
	/*to Setting TWI*/
	TWI_ConfigType twi_config = { TWI_FAST_Mode, 0x01, TWI_Prescaler_FCU_1 };
    2082:	ce 01       	movw	r24, r28
    2084:	81 52       	subi	r24, 0x21	; 33
    2086:	9f 4f       	sbci	r25, 0xFF	; 255
    2088:	c1 51       	subi	r28, 0x11	; 17
    208a:	df 4f       	sbci	r29, 0xFF	; 255
    208c:	99 83       	std	Y+1, r25	; 0x01
    208e:	88 83       	st	Y, r24
    2090:	cf 5e       	subi	r28, 0xEF	; 239
    2092:	d0 40       	sbci	r29, 0x00	; 0
    2094:	a8 e6       	ldi	r26, 0x68	; 104
    2096:	b1 e0       	ldi	r27, 0x01	; 1
    2098:	cf 50       	subi	r28, 0x0F	; 15
    209a:	df 4f       	sbci	r29, 0xFF	; 255
    209c:	b9 83       	std	Y+1, r27	; 0x01
    209e:	a8 83       	st	Y, r26
    20a0:	c1 5f       	subi	r28, 0xF1	; 241
    20a2:	d0 40       	sbci	r29, 0x00	; 0
    20a4:	b6 e0       	ldi	r27, 0x06	; 6
    20a6:	cd 50       	subi	r28, 0x0D	; 13
    20a8:	df 4f       	sbci	r29, 0xFF	; 255
    20aa:	b8 83       	st	Y, r27
    20ac:	c3 5f       	subi	r28, 0xF3	; 243
    20ae:	d0 40       	sbci	r29, 0x00	; 0
    20b0:	cf 50       	subi	r28, 0x0F	; 15
    20b2:	df 4f       	sbci	r29, 0xFF	; 255
    20b4:	e8 81       	ld	r30, Y
    20b6:	f9 81       	ldd	r31, Y+1	; 0x01
    20b8:	c1 5f       	subi	r28, 0xF1	; 241
    20ba:	d0 40       	sbci	r29, 0x00	; 0
    20bc:	00 80       	ld	r0, Z
    20be:	cf 50       	subi	r28, 0x0F	; 15
    20c0:	df 4f       	sbci	r29, 0xFF	; 255
    20c2:	88 81       	ld	r24, Y
    20c4:	99 81       	ldd	r25, Y+1	; 0x01
    20c6:	c1 5f       	subi	r28, 0xF1	; 241
    20c8:	d0 40       	sbci	r29, 0x00	; 0
    20ca:	01 96       	adiw	r24, 0x01	; 1
    20cc:	cf 50       	subi	r28, 0x0F	; 15
    20ce:	df 4f       	sbci	r29, 0xFF	; 255
    20d0:	99 83       	std	Y+1, r25	; 0x01
    20d2:	88 83       	st	Y, r24
    20d4:	c1 5f       	subi	r28, 0xF1	; 241
    20d6:	d0 40       	sbci	r29, 0x00	; 0
    20d8:	c1 51       	subi	r28, 0x11	; 17
    20da:	df 4f       	sbci	r29, 0xFF	; 255
    20dc:	a8 81       	ld	r26, Y
    20de:	b9 81       	ldd	r27, Y+1	; 0x01
    20e0:	cf 5e       	subi	r28, 0xEF	; 239
    20e2:	d0 40       	sbci	r29, 0x00	; 0
    20e4:	0c 92       	st	X, r0
    20e6:	c1 51       	subi	r28, 0x11	; 17
    20e8:	df 4f       	sbci	r29, 0xFF	; 255
    20ea:	e8 81       	ld	r30, Y
    20ec:	f9 81       	ldd	r31, Y+1	; 0x01
    20ee:	cf 5e       	subi	r28, 0xEF	; 239
    20f0:	d0 40       	sbci	r29, 0x00	; 0
    20f2:	31 96       	adiw	r30, 0x01	; 1
    20f4:	c1 51       	subi	r28, 0x11	; 17
    20f6:	df 4f       	sbci	r29, 0xFF	; 255
    20f8:	f9 83       	std	Y+1, r31	; 0x01
    20fa:	e8 83       	st	Y, r30
    20fc:	cf 5e       	subi	r28, 0xEF	; 239
    20fe:	d0 40       	sbci	r29, 0x00	; 0
    2100:	cd 50       	subi	r28, 0x0D	; 13
    2102:	df 4f       	sbci	r29, 0xFF	; 255
    2104:	f8 81       	ld	r31, Y
    2106:	c3 5f       	subi	r28, 0xF3	; 243
    2108:	d0 40       	sbci	r29, 0x00	; 0
    210a:	f1 50       	subi	r31, 0x01	; 1
    210c:	cd 50       	subi	r28, 0x0D	; 13
    210e:	df 4f       	sbci	r29, 0xFF	; 255
    2110:	f8 83       	st	Y, r31
    2112:	c3 5f       	subi	r28, 0xF3	; 243
    2114:	d0 40       	sbci	r29, 0x00	; 0
    2116:	cd 50       	subi	r28, 0x0D	; 13
    2118:	df 4f       	sbci	r29, 0xFF	; 255
    211a:	88 81       	ld	r24, Y
    211c:	c3 5f       	subi	r28, 0xF3	; 243
    211e:	d0 40       	sbci	r29, 0x00	; 0
    2120:	88 23       	and	r24, r24
    2122:	31 f6       	brne	.-116    	; 0x20b0 <main+0x1ba>
	global_interput_int();
    2124:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <global_interput_int>
	Buzzer_init();
    2128:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <Buzzer_init>
	DcMotor_Init();
    212c:	0e 94 c5 0e 	call	0x1d8a	; 0x1d8a <DcMotor_Init>
	TWI_init(&twi_config);
    2130:	ce 01       	movw	r24, r28
    2132:	81 52       	subi	r24, 0x21	; 33
    2134:	9f 4f       	sbci	r25, 0xFF	; 255
    2136:	0e 94 3b 08 	call	0x1076	; 0x1076 <TWI_init>
	UART_init(&uart_Config);
    213a:	ce 01       	movw	r24, r28
    213c:	86 52       	subi	r24, 0x26	; 38
    213e:	9f 4f       	sbci	r25, 0xFF	; 255
    2140:	0e 94 17 07 	call	0xe2e	; 0xe2e <UART_init>
	/*to make sure that the 2MC`s are realy conected*/
	if (UART_recieveByte() == READY) {
    2144:	0e 94 bf 07 	call	0xf7e	; 0xf7e <UART_recieveByte>
    2148:	80 32       	cpi	r24, 0x20	; 32
    214a:	09 f0       	breq	.+2      	; 0x214e <main+0x258>
    214c:	43 c0       	rjmp	.+134    	; 0x21d4 <main+0x2de>
		UART_sendByte(IAM_READY);
    214e:	80 e1       	ldi	r24, 0x10	; 16
    2150:	0e 94 ab 07 	call	0xf56	; 0xf56 <UART_sendByte>
    2154:	3f c0       	rjmp	.+126    	; 0x21d4 <main+0x2de>
	while (1) {
		/*******************************************************************************
		 *                                    CREATE_PASS                              *
		 *******************************************************************************/
		while (state == CREATE_PASS) {
			uint8 local_state = UART_recieveByte();/*to receive uart state */
    2156:	0e 94 bf 07 	call	0xf7e	; 0xf7e <UART_recieveByte>
    215a:	fe 01       	movw	r30, r28
    215c:	e4 53       	subi	r30, 0x34	; 52
    215e:	ff 4f       	sbci	r31, 0xFF	; 255
    2160:	80 83       	st	Z, r24
			g_try = 0;/*to recount try of check pass*/
    2162:	10 92 81 01 	sts	0x0181, r1
			if (local_state == UART_CREATE_PASS_READY) {
    2166:	fe 01       	movw	r30, r28
    2168:	e4 53       	subi	r30, 0x34	; 52
    216a:	ff 4f       	sbci	r31, 0xFF	; 255
    216c:	80 81       	ld	r24, Z
    216e:	8a 30       	cpi	r24, 0x0A	; 10
    2170:	69 f5       	brne	.+90     	; 0x21cc <main+0x2d6>
				UART_sendByte(UART_CREATE_PASS_YES_READY);
    2172:	8b e0       	ldi	r24, 0x0B	; 11
    2174:	0e 94 ab 07 	call	0xf56	; 0xf56 <UART_sendByte>
				/*to receive pass*/
				for (password_counter_digit = 0; password_counter_digit < 5;
    2178:	fe 01       	movw	r30, r28
    217a:	e1 53       	subi	r30, 0x31	; 49
    217c:	ff 4f       	sbci	r31, 0xFF	; 255
    217e:	10 82       	st	Z, r1
    2180:	19 c0       	rjmp	.+50     	; 0x21b4 <main+0x2be>
						++password_counter_digit) {
					password[password_counter_digit] = UART_recieveByte();
    2182:	fe 01       	movw	r30, r28
    2184:	e1 53       	subi	r30, 0x31	; 49
    2186:	ff 4f       	sbci	r31, 0xFF	; 255
    2188:	80 81       	ld	r24, Z
    218a:	08 2f       	mov	r16, r24
    218c:	10 e0       	ldi	r17, 0x00	; 0
    218e:	0e 94 bf 07 	call	0xf7e	; 0xf7e <UART_recieveByte>
    2192:	28 2f       	mov	r18, r24
    2194:	ce 01       	movw	r24, r28
    2196:	80 53       	subi	r24, 0x30	; 48
    2198:	9f 4f       	sbci	r25, 0xFF	; 255
    219a:	fc 01       	movw	r30, r24
    219c:	e0 0f       	add	r30, r16
    219e:	f1 1f       	adc	r31, r17
    21a0:	20 83       	st	Z, r18
			g_try = 0;/*to recount try of check pass*/
			if (local_state == UART_CREATE_PASS_READY) {
				UART_sendByte(UART_CREATE_PASS_YES_READY);
				/*to receive pass*/
				for (password_counter_digit = 0; password_counter_digit < 5;
						++password_counter_digit) {
    21a2:	de 01       	movw	r26, r28
    21a4:	a1 53       	subi	r26, 0x31	; 49
    21a6:	bf 4f       	sbci	r27, 0xFF	; 255
    21a8:	fe 01       	movw	r30, r28
    21aa:	e1 53       	subi	r30, 0x31	; 49
    21ac:	ff 4f       	sbci	r31, 0xFF	; 255
    21ae:	80 81       	ld	r24, Z
    21b0:	8f 5f       	subi	r24, 0xFF	; 255
    21b2:	8c 93       	st	X, r24
			uint8 local_state = UART_recieveByte();/*to receive uart state */
			g_try = 0;/*to recount try of check pass*/
			if (local_state == UART_CREATE_PASS_READY) {
				UART_sendByte(UART_CREATE_PASS_YES_READY);
				/*to receive pass*/
				for (password_counter_digit = 0; password_counter_digit < 5;
    21b4:	fe 01       	movw	r30, r28
    21b6:	e1 53       	subi	r30, 0x31	; 49
    21b8:	ff 4f       	sbci	r31, 0xFF	; 255
    21ba:	80 81       	ld	r24, Z
    21bc:	85 30       	cpi	r24, 0x05	; 5
    21be:	08 f3       	brcs	.-62     	; 0x2182 <main+0x28c>
						++password_counter_digit) {
					password[password_counter_digit] = UART_recieveByte();
				}
				state = RECREATE_PASS;
    21c0:	fe 01       	movw	r30, r28
    21c2:	e2 53       	subi	r30, 0x32	; 50
    21c4:	ff 4f       	sbci	r31, 0xFF	; 255
    21c6:	81 e0       	ldi	r24, 0x01	; 1
    21c8:	80 83       	st	Z, r24
    21ca:	4a c0       	rjmp	.+148    	; 0x2260 <main+0x36a>
				break;
			} else {
				state = CREATE_PASS;
    21cc:	fe 01       	movw	r30, r28
    21ce:	e2 53       	subi	r30, 0x32	; 50
    21d0:	ff 4f       	sbci	r31, 0xFF	; 255
    21d2:	10 82       	st	Z, r1
	}
	while (1) {
		/*******************************************************************************
		 *                                    CREATE_PASS                              *
		 *******************************************************************************/
		while (state == CREATE_PASS) {
    21d4:	fe 01       	movw	r30, r28
    21d6:	e2 53       	subi	r30, 0x32	; 50
    21d8:	ff 4f       	sbci	r31, 0xFF	; 255
    21da:	80 81       	ld	r24, Z
    21dc:	88 23       	and	r24, r24
    21de:	09 f4       	brne	.+2      	; 0x21e2 <main+0x2ec>
    21e0:	ba cf       	rjmp	.-140    	; 0x2156 <main+0x260>
    21e2:	3e c0       	rjmp	.+124    	; 0x2260 <main+0x36a>
		}
		/*******************************************************************************
		 *                                    RECREATE_PASS                            *
		 *******************************************************************************/
		while (state == RECREATE_PASS) {
			uint8 local_state = UART_recieveByte();
    21e4:	0e 94 bf 07 	call	0xf7e	; 0xf7e <UART_recieveByte>
    21e8:	fe 01       	movw	r30, r28
    21ea:	e5 53       	subi	r30, 0x35	; 53
    21ec:	ff 4f       	sbci	r31, 0xFF	; 255
    21ee:	80 83       	st	Z, r24
			if (local_state == UART_RECREATE_PASS_READY) {
    21f0:	fe 01       	movw	r30, r28
    21f2:	e5 53       	subi	r30, 0x35	; 53
    21f4:	ff 4f       	sbci	r31, 0xFF	; 255
    21f6:	80 81       	ld	r24, Z
    21f8:	8c 30       	cpi	r24, 0x0C	; 12
    21fa:	69 f5       	brne	.+90     	; 0x2256 <main+0x360>
				UART_sendByte(UART_RECREATE_PASS_YES_READY);
    21fc:	8d e0       	ldi	r24, 0x0D	; 13
    21fe:	0e 94 ab 07 	call	0xf56	; 0xf56 <UART_sendByte>
				/*to receive conf pass*/
				for (password_counter_digit = 0; password_counter_digit < 5;
    2202:	fe 01       	movw	r30, r28
    2204:	e1 53       	subi	r30, 0x31	; 49
    2206:	ff 4f       	sbci	r31, 0xFF	; 255
    2208:	10 82       	st	Z, r1
    220a:	19 c0       	rjmp	.+50     	; 0x223e <main+0x348>
						++password_counter_digit) {
					confirmation_password[password_counter_digit] =
    220c:	fe 01       	movw	r30, r28
    220e:	e1 53       	subi	r30, 0x31	; 49
    2210:	ff 4f       	sbci	r31, 0xFF	; 255
    2212:	80 81       	ld	r24, Z
    2214:	08 2f       	mov	r16, r24
    2216:	10 e0       	ldi	r17, 0x00	; 0
    2218:	0e 94 bf 07 	call	0xf7e	; 0xf7e <UART_recieveByte>
    221c:	28 2f       	mov	r18, r24
    221e:	ce 01       	movw	r24, r28
    2220:	8b 52       	subi	r24, 0x2B	; 43
    2222:	9f 4f       	sbci	r25, 0xFF	; 255
    2224:	fc 01       	movw	r30, r24
    2226:	e0 0f       	add	r30, r16
    2228:	f1 1f       	adc	r31, r17
    222a:	20 83       	st	Z, r18
			uint8 local_state = UART_recieveByte();
			if (local_state == UART_RECREATE_PASS_READY) {
				UART_sendByte(UART_RECREATE_PASS_YES_READY);
				/*to receive conf pass*/
				for (password_counter_digit = 0; password_counter_digit < 5;
						++password_counter_digit) {
    222c:	de 01       	movw	r26, r28
    222e:	a1 53       	subi	r26, 0x31	; 49
    2230:	bf 4f       	sbci	r27, 0xFF	; 255
    2232:	fe 01       	movw	r30, r28
    2234:	e1 53       	subi	r30, 0x31	; 49
    2236:	ff 4f       	sbci	r31, 0xFF	; 255
    2238:	80 81       	ld	r24, Z
    223a:	8f 5f       	subi	r24, 0xFF	; 255
    223c:	8c 93       	st	X, r24
		while (state == RECREATE_PASS) {
			uint8 local_state = UART_recieveByte();
			if (local_state == UART_RECREATE_PASS_READY) {
				UART_sendByte(UART_RECREATE_PASS_YES_READY);
				/*to receive conf pass*/
				for (password_counter_digit = 0; password_counter_digit < 5;
    223e:	fe 01       	movw	r30, r28
    2240:	e1 53       	subi	r30, 0x31	; 49
    2242:	ff 4f       	sbci	r31, 0xFF	; 255
    2244:	80 81       	ld	r24, Z
    2246:	85 30       	cpi	r24, 0x05	; 5
    2248:	08 f3       	brcs	.-62     	; 0x220c <main+0x316>
						++password_counter_digit) {
					confirmation_password[password_counter_digit] =
							UART_recieveByte();

				}
				state = CONFIRMA_PASS;
    224a:	fe 01       	movw	r30, r28
    224c:	e2 53       	subi	r30, 0x32	; 50
    224e:	ff 4f       	sbci	r31, 0xFF	; 255
    2250:	86 e0       	ldi	r24, 0x06	; 6
    2252:	80 83       	st	Z, r24
    2254:	0c c0       	rjmp	.+24     	; 0x226e <main+0x378>
				break;
			} else {
				state = RECREATE_PASS;
    2256:	fe 01       	movw	r30, r28
    2258:	e2 53       	subi	r30, 0x32	; 50
    225a:	ff 4f       	sbci	r31, 0xFF	; 255
    225c:	81 e0       	ldi	r24, 0x01	; 1
    225e:	80 83       	st	Z, r24
			}
		}
		/*******************************************************************************
		 *                                    RECREATE_PASS                            *
		 *******************************************************************************/
		while (state == RECREATE_PASS) {
    2260:	fe 01       	movw	r30, r28
    2262:	e2 53       	subi	r30, 0x32	; 50
    2264:	ff 4f       	sbci	r31, 0xFF	; 255
    2266:	80 81       	ld	r24, Z
    2268:	81 30       	cpi	r24, 0x01	; 1
    226a:	09 f4       	brne	.+2      	; 0x226e <main+0x378>
    226c:	bb cf       	rjmp	.-138    	; 0x21e4 <main+0x2ee>
		}
		/*******************************************************************************
		 *                                    CONFIRMA_PASS                           *
		 *******************************************************************************/
		/*to Confirma pass and store it  in eeprom*/
		while (state == CONFIRMA_PASS) {
    226e:	fe 01       	movw	r30, r28
    2270:	e2 53       	subi	r30, 0x32	; 50
    2272:	ff 4f       	sbci	r31, 0xFF	; 255
    2274:	80 81       	ld	r24, Z
    2276:	86 30       	cpi	r24, 0x06	; 6
    2278:	11 f0       	breq	.+4      	; 0x227e <main+0x388>
    227a:	0c 94 17 19 	jmp	0x322e	; 0x322e <main+0x1338>
			uint8 local_state = UART_recieveByte();
    227e:	0e 94 bf 07 	call	0xf7e	; 0xf7e <UART_recieveByte>
    2282:	fe 01       	movw	r30, r28
    2284:	e6 53       	subi	r30, 0x36	; 54
    2286:	ff 4f       	sbci	r31, 0xFF	; 255
    2288:	80 83       	st	Z, r24
			if (local_state == UART_CONFIRMA_PASS_READY) {
    228a:	fe 01       	movw	r30, r28
    228c:	e6 53       	subi	r30, 0x36	; 54
    228e:	ff 4f       	sbci	r31, 0xFF	; 255
    2290:	80 81       	ld	r24, Z
    2292:	82 31       	cpi	r24, 0x12	; 18
    2294:	09 f0       	breq	.+2      	; 0x2298 <main+0x3a2>
    2296:	3e c0       	rjmp	.+124    	; 0x2314 <main+0x41e>
				UART_sendByte(UART_CONFIRMA_PASS_YES_READY);
    2298:	83 e1       	ldi	r24, 0x13	; 19
    229a:	0e 94 ab 07 	call	0xf56	; 0xf56 <UART_sendByte>
				for (password_counter_digit = 0; password_counter_digit < 5;
    229e:	fe 01       	movw	r30, r28
    22a0:	e1 53       	subi	r30, 0x31	; 49
    22a2:	ff 4f       	sbci	r31, 0xFF	; 255
    22a4:	10 82       	st	Z, r1
    22a6:	30 c0       	rjmp	.+96     	; 0x2308 <main+0x412>
						++password_counter_digit) {
					if (password[password_counter_digit]
    22a8:	fe 01       	movw	r30, r28
    22aa:	e1 53       	subi	r30, 0x31	; 49
    22ac:	ff 4f       	sbci	r31, 0xFF	; 255
    22ae:	80 81       	ld	r24, Z
    22b0:	28 2f       	mov	r18, r24
    22b2:	30 e0       	ldi	r19, 0x00	; 0
    22b4:	ce 01       	movw	r24, r28
    22b6:	80 53       	subi	r24, 0x30	; 48
    22b8:	9f 4f       	sbci	r25, 0xFF	; 255
    22ba:	fc 01       	movw	r30, r24
    22bc:	e2 0f       	add	r30, r18
    22be:	f3 1f       	adc	r31, r19
    22c0:	40 81       	ld	r20, Z
    22c2:	fe 01       	movw	r30, r28
    22c4:	e1 53       	subi	r30, 0x31	; 49
    22c6:	ff 4f       	sbci	r31, 0xFF	; 255
    22c8:	80 81       	ld	r24, Z
    22ca:	28 2f       	mov	r18, r24
    22cc:	30 e0       	ldi	r19, 0x00	; 0
    22ce:	ce 01       	movw	r24, r28
    22d0:	8b 52       	subi	r24, 0x2B	; 43
    22d2:	9f 4f       	sbci	r25, 0xFF	; 255
    22d4:	fc 01       	movw	r30, r24
    22d6:	e2 0f       	add	r30, r18
    22d8:	f3 1f       	adc	r31, r19
    22da:	80 81       	ld	r24, Z
    22dc:	48 17       	cp	r20, r24
    22de:	79 f4       	brne	.+30     	; 0x22fe <main+0x408>
							== confirmation_password[password_counter_digit]) {
						matched_pass_flag = TRUE;
    22e0:	fe 01       	movw	r30, r28
    22e2:	e3 53       	subi	r30, 0x33	; 51
    22e4:	ff 4f       	sbci	r31, 0xFF	; 255
    22e6:	81 e0       	ldi	r24, 0x01	; 1
    22e8:	80 83       	st	Z, r24
		while (state == CONFIRMA_PASS) {
			uint8 local_state = UART_recieveByte();
			if (local_state == UART_CONFIRMA_PASS_READY) {
				UART_sendByte(UART_CONFIRMA_PASS_YES_READY);
				for (password_counter_digit = 0; password_counter_digit < 5;
						++password_counter_digit) {
    22ea:	de 01       	movw	r26, r28
    22ec:	a1 53       	subi	r26, 0x31	; 49
    22ee:	bf 4f       	sbci	r27, 0xFF	; 255
    22f0:	fe 01       	movw	r30, r28
    22f2:	e1 53       	subi	r30, 0x31	; 49
    22f4:	ff 4f       	sbci	r31, 0xFF	; 255
    22f6:	80 81       	ld	r24, Z
    22f8:	8f 5f       	subi	r24, 0xFF	; 255
    22fa:	8c 93       	st	X, r24
    22fc:	05 c0       	rjmp	.+10     	; 0x2308 <main+0x412>
					if (password[password_counter_digit]
							== confirmation_password[password_counter_digit]) {
						matched_pass_flag = TRUE;

					} else {
						matched_pass_flag = FALSE;
    22fe:	fe 01       	movw	r30, r28
    2300:	e3 53       	subi	r30, 0x33	; 51
    2302:	ff 4f       	sbci	r31, 0xFF	; 255
    2304:	10 82       	st	Z, r1
    2306:	06 c0       	rjmp	.+12     	; 0x2314 <main+0x41e>
		/*to Confirma pass and store it  in eeprom*/
		while (state == CONFIRMA_PASS) {
			uint8 local_state = UART_recieveByte();
			if (local_state == UART_CONFIRMA_PASS_READY) {
				UART_sendByte(UART_CONFIRMA_PASS_YES_READY);
				for (password_counter_digit = 0; password_counter_digit < 5;
    2308:	fe 01       	movw	r30, r28
    230a:	e1 53       	subi	r30, 0x31	; 49
    230c:	ff 4f       	sbci	r31, 0xFF	; 255
    230e:	80 81       	ld	r24, Z
    2310:	85 30       	cpi	r24, 0x05	; 5
    2312:	50 f2       	brcs	.-108    	; 0x22a8 <main+0x3b2>

						break;
					}
				}
			}
			if (matched_pass_flag == TRUE) {
    2314:	fe 01       	movw	r30, r28
    2316:	e3 53       	subi	r30, 0x33	; 51
    2318:	ff 4f       	sbci	r31, 0xFF	; 255
    231a:	80 81       	ld	r24, Z
    231c:	81 30       	cpi	r24, 0x01	; 1
    231e:	09 f0       	breq	.+2      	; 0x2322 <main+0x42c>
    2320:	3a c7       	rjmp	.+3700   	; 0x3196 <main+0x12a0>
				UART_sendByte(UART_CONFIRMA_PASS_FINSH);
    2322:	86 e1       	ldi	r24, 0x16	; 22
    2324:	0e 94 ab 07 	call	0xf56	; 0xf56 <UART_sendByte>
				state = MAIN;
    2328:	fe 01       	movw	r30, r28
    232a:	e2 53       	subi	r30, 0x32	; 50
    232c:	ff 4f       	sbci	r31, 0xFF	; 255
    232e:	85 e0       	ldi	r24, 0x05	; 5
    2330:	80 83       	st	Z, r24
				/*write and read from eeprom*/
				EEPROM_writeByte(0x0310, confirmation_password[0]);
    2332:	fe 01       	movw	r30, r28
    2334:	eb 52       	subi	r30, 0x2B	; 43
    2336:	ff 4f       	sbci	r31, 0xFF	; 255
    2338:	20 81       	ld	r18, Z
    233a:	80 e1       	ldi	r24, 0x10	; 16
    233c:	93 e0       	ldi	r25, 0x03	; 3
    233e:	62 2f       	mov	r22, r18
    2340:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <EEPROM_writeByte>
    2344:	fe 01       	movw	r30, r28
    2346:	ef 53       	subi	r30, 0x3F	; 63
    2348:	ff 4f       	sbci	r31, 0xFF	; 255
    234a:	80 e0       	ldi	r24, 0x00	; 0
    234c:	90 e0       	ldi	r25, 0x00	; 0
    234e:	a0 e2       	ldi	r26, 0x20	; 32
    2350:	b1 e4       	ldi	r27, 0x41	; 65
    2352:	80 83       	st	Z, r24
    2354:	91 83       	std	Z+1, r25	; 0x01
    2356:	a2 83       	std	Z+2, r26	; 0x02
    2358:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    235a:	8e 01       	movw	r16, r28
    235c:	03 54       	subi	r16, 0x43	; 67
    235e:	1f 4f       	sbci	r17, 0xFF	; 255
    2360:	fe 01       	movw	r30, r28
    2362:	ef 53       	subi	r30, 0x3F	; 63
    2364:	ff 4f       	sbci	r31, 0xFF	; 255
    2366:	60 81       	ld	r22, Z
    2368:	71 81       	ldd	r23, Z+1	; 0x01
    236a:	82 81       	ldd	r24, Z+2	; 0x02
    236c:	93 81       	ldd	r25, Z+3	; 0x03
    236e:	20 e0       	ldi	r18, 0x00	; 0
    2370:	30 e0       	ldi	r19, 0x00	; 0
    2372:	4a ef       	ldi	r20, 0xFA	; 250
    2374:	54 e4       	ldi	r21, 0x44	; 68
    2376:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    237a:	dc 01       	movw	r26, r24
    237c:	cb 01       	movw	r24, r22
    237e:	f8 01       	movw	r30, r16
    2380:	80 83       	st	Z, r24
    2382:	91 83       	std	Z+1, r25	; 0x01
    2384:	a2 83       	std	Z+2, r26	; 0x02
    2386:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    2388:	fe 01       	movw	r30, r28
    238a:	e3 54       	subi	r30, 0x43	; 67
    238c:	ff 4f       	sbci	r31, 0xFF	; 255
    238e:	60 81       	ld	r22, Z
    2390:	71 81       	ldd	r23, Z+1	; 0x01
    2392:	82 81       	ldd	r24, Z+2	; 0x02
    2394:	93 81       	ldd	r25, Z+3	; 0x03
    2396:	20 e0       	ldi	r18, 0x00	; 0
    2398:	30 e0       	ldi	r19, 0x00	; 0
    239a:	40 e8       	ldi	r20, 0x80	; 128
    239c:	5f e3       	ldi	r21, 0x3F	; 63
    239e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    23a2:	88 23       	and	r24, r24
    23a4:	44 f4       	brge	.+16     	; 0x23b6 <main+0x4c0>
		__ticks = 1;
    23a6:	fe 01       	movw	r30, r28
    23a8:	e5 54       	subi	r30, 0x45	; 69
    23aa:	ff 4f       	sbci	r31, 0xFF	; 255
    23ac:	81 e0       	ldi	r24, 0x01	; 1
    23ae:	90 e0       	ldi	r25, 0x00	; 0
    23b0:	91 83       	std	Z+1, r25	; 0x01
    23b2:	80 83       	st	Z, r24
    23b4:	64 c0       	rjmp	.+200    	; 0x247e <main+0x588>
	else if (__tmp > 65535)
    23b6:	fe 01       	movw	r30, r28
    23b8:	e3 54       	subi	r30, 0x43	; 67
    23ba:	ff 4f       	sbci	r31, 0xFF	; 255
    23bc:	60 81       	ld	r22, Z
    23be:	71 81       	ldd	r23, Z+1	; 0x01
    23c0:	82 81       	ldd	r24, Z+2	; 0x02
    23c2:	93 81       	ldd	r25, Z+3	; 0x03
    23c4:	20 e0       	ldi	r18, 0x00	; 0
    23c6:	3f ef       	ldi	r19, 0xFF	; 255
    23c8:	4f e7       	ldi	r20, 0x7F	; 127
    23ca:	57 e4       	ldi	r21, 0x47	; 71
    23cc:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    23d0:	18 16       	cp	r1, r24
    23d2:	0c f0       	brlt	.+2      	; 0x23d6 <main+0x4e0>
    23d4:	43 c0       	rjmp	.+134    	; 0x245c <main+0x566>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    23d6:	fe 01       	movw	r30, r28
    23d8:	ef 53       	subi	r30, 0x3F	; 63
    23da:	ff 4f       	sbci	r31, 0xFF	; 255
    23dc:	60 81       	ld	r22, Z
    23de:	71 81       	ldd	r23, Z+1	; 0x01
    23e0:	82 81       	ldd	r24, Z+2	; 0x02
    23e2:	93 81       	ldd	r25, Z+3	; 0x03
    23e4:	20 e0       	ldi	r18, 0x00	; 0
    23e6:	30 e0       	ldi	r19, 0x00	; 0
    23e8:	40 e2       	ldi	r20, 0x20	; 32
    23ea:	51 e4       	ldi	r21, 0x41	; 65
    23ec:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    23f0:	dc 01       	movw	r26, r24
    23f2:	cb 01       	movw	r24, r22
    23f4:	8e 01       	movw	r16, r28
    23f6:	05 54       	subi	r16, 0x45	; 69
    23f8:	1f 4f       	sbci	r17, 0xFF	; 255
    23fa:	bc 01       	movw	r22, r24
    23fc:	cd 01       	movw	r24, r26
    23fe:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2402:	dc 01       	movw	r26, r24
    2404:	cb 01       	movw	r24, r22
    2406:	f8 01       	movw	r30, r16
    2408:	91 83       	std	Z+1, r25	; 0x01
    240a:	80 83       	st	Z, r24
    240c:	1f c0       	rjmp	.+62     	; 0x244c <main+0x556>
    240e:	fe 01       	movw	r30, r28
    2410:	e7 54       	subi	r30, 0x47	; 71
    2412:	ff 4f       	sbci	r31, 0xFF	; 255
    2414:	88 ec       	ldi	r24, 0xC8	; 200
    2416:	90 e0       	ldi	r25, 0x00	; 0
    2418:	91 83       	std	Z+1, r25	; 0x01
    241a:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    241c:	fe 01       	movw	r30, r28
    241e:	e7 54       	subi	r30, 0x47	; 71
    2420:	ff 4f       	sbci	r31, 0xFF	; 255
    2422:	80 81       	ld	r24, Z
    2424:	91 81       	ldd	r25, Z+1	; 0x01
    2426:	01 97       	sbiw	r24, 0x01	; 1
    2428:	f1 f7       	brne	.-4      	; 0x2426 <main+0x530>
    242a:	fe 01       	movw	r30, r28
    242c:	e7 54       	subi	r30, 0x47	; 71
    242e:	ff 4f       	sbci	r31, 0xFF	; 255
    2430:	91 83       	std	Z+1, r25	; 0x01
    2432:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2434:	de 01       	movw	r26, r28
    2436:	a5 54       	subi	r26, 0x45	; 69
    2438:	bf 4f       	sbci	r27, 0xFF	; 255
    243a:	fe 01       	movw	r30, r28
    243c:	e5 54       	subi	r30, 0x45	; 69
    243e:	ff 4f       	sbci	r31, 0xFF	; 255
    2440:	80 81       	ld	r24, Z
    2442:	91 81       	ldd	r25, Z+1	; 0x01
    2444:	01 97       	sbiw	r24, 0x01	; 1
    2446:	11 96       	adiw	r26, 0x01	; 1
    2448:	9c 93       	st	X, r25
    244a:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    244c:	fe 01       	movw	r30, r28
    244e:	e5 54       	subi	r30, 0x45	; 69
    2450:	ff 4f       	sbci	r31, 0xFF	; 255
    2452:	80 81       	ld	r24, Z
    2454:	91 81       	ldd	r25, Z+1	; 0x01
    2456:	00 97       	sbiw	r24, 0x00	; 0
    2458:	d1 f6       	brne	.-76     	; 0x240e <main+0x518>
    245a:	27 c0       	rjmp	.+78     	; 0x24aa <main+0x5b4>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    245c:	8e 01       	movw	r16, r28
    245e:	05 54       	subi	r16, 0x45	; 69
    2460:	1f 4f       	sbci	r17, 0xFF	; 255
    2462:	fe 01       	movw	r30, r28
    2464:	e3 54       	subi	r30, 0x43	; 67
    2466:	ff 4f       	sbci	r31, 0xFF	; 255
    2468:	60 81       	ld	r22, Z
    246a:	71 81       	ldd	r23, Z+1	; 0x01
    246c:	82 81       	ldd	r24, Z+2	; 0x02
    246e:	93 81       	ldd	r25, Z+3	; 0x03
    2470:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2474:	dc 01       	movw	r26, r24
    2476:	cb 01       	movw	r24, r22
    2478:	f8 01       	movw	r30, r16
    247a:	91 83       	std	Z+1, r25	; 0x01
    247c:	80 83       	st	Z, r24
    247e:	de 01       	movw	r26, r28
    2480:	a9 54       	subi	r26, 0x49	; 73
    2482:	bf 4f       	sbci	r27, 0xFF	; 255
    2484:	fe 01       	movw	r30, r28
    2486:	e5 54       	subi	r30, 0x45	; 69
    2488:	ff 4f       	sbci	r31, 0xFF	; 255
    248a:	80 81       	ld	r24, Z
    248c:	91 81       	ldd	r25, Z+1	; 0x01
    248e:	8d 93       	st	X+, r24
    2490:	9c 93       	st	X, r25
    2492:	fe 01       	movw	r30, r28
    2494:	e9 54       	subi	r30, 0x49	; 73
    2496:	ff 4f       	sbci	r31, 0xFF	; 255
    2498:	80 81       	ld	r24, Z
    249a:	91 81       	ldd	r25, Z+1	; 0x01
    249c:	01 97       	sbiw	r24, 0x01	; 1
    249e:	f1 f7       	brne	.-4      	; 0x249c <main+0x5a6>
    24a0:	fe 01       	movw	r30, r28
    24a2:	e9 54       	subi	r30, 0x49	; 73
    24a4:	ff 4f       	sbci	r31, 0xFF	; 255
    24a6:	91 83       	std	Z+1, r25	; 0x01
    24a8:	80 83       	st	Z, r24
				_delay_ms(10);
				EEPROM_readByte(0x0310, &confirmation_password[0]);
    24aa:	9e 01       	movw	r18, r28
    24ac:	2b 52       	subi	r18, 0x2B	; 43
    24ae:	3f 4f       	sbci	r19, 0xFF	; 255
    24b0:	80 e1       	ldi	r24, 0x10	; 16
    24b2:	93 e0       	ldi	r25, 0x03	; 3
    24b4:	b9 01       	movw	r22, r18
    24b6:	0e 94 65 0e 	call	0x1cca	; 0x1cca <EEPROM_readByte>
    24ba:	fe 01       	movw	r30, r28
    24bc:	ed 54       	subi	r30, 0x4D	; 77
    24be:	ff 4f       	sbci	r31, 0xFF	; 255
    24c0:	80 e0       	ldi	r24, 0x00	; 0
    24c2:	90 e0       	ldi	r25, 0x00	; 0
    24c4:	a0 e2       	ldi	r26, 0x20	; 32
    24c6:	b1 e4       	ldi	r27, 0x41	; 65
    24c8:	80 83       	st	Z, r24
    24ca:	91 83       	std	Z+1, r25	; 0x01
    24cc:	a2 83       	std	Z+2, r26	; 0x02
    24ce:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    24d0:	8e 01       	movw	r16, r28
    24d2:	01 55       	subi	r16, 0x51	; 81
    24d4:	1f 4f       	sbci	r17, 0xFF	; 255
    24d6:	fe 01       	movw	r30, r28
    24d8:	ed 54       	subi	r30, 0x4D	; 77
    24da:	ff 4f       	sbci	r31, 0xFF	; 255
    24dc:	60 81       	ld	r22, Z
    24de:	71 81       	ldd	r23, Z+1	; 0x01
    24e0:	82 81       	ldd	r24, Z+2	; 0x02
    24e2:	93 81       	ldd	r25, Z+3	; 0x03
    24e4:	20 e0       	ldi	r18, 0x00	; 0
    24e6:	30 e0       	ldi	r19, 0x00	; 0
    24e8:	4a ef       	ldi	r20, 0xFA	; 250
    24ea:	54 e4       	ldi	r21, 0x44	; 68
    24ec:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    24f0:	dc 01       	movw	r26, r24
    24f2:	cb 01       	movw	r24, r22
    24f4:	f8 01       	movw	r30, r16
    24f6:	80 83       	st	Z, r24
    24f8:	91 83       	std	Z+1, r25	; 0x01
    24fa:	a2 83       	std	Z+2, r26	; 0x02
    24fc:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    24fe:	fe 01       	movw	r30, r28
    2500:	e1 55       	subi	r30, 0x51	; 81
    2502:	ff 4f       	sbci	r31, 0xFF	; 255
    2504:	60 81       	ld	r22, Z
    2506:	71 81       	ldd	r23, Z+1	; 0x01
    2508:	82 81       	ldd	r24, Z+2	; 0x02
    250a:	93 81       	ldd	r25, Z+3	; 0x03
    250c:	20 e0       	ldi	r18, 0x00	; 0
    250e:	30 e0       	ldi	r19, 0x00	; 0
    2510:	40 e8       	ldi	r20, 0x80	; 128
    2512:	5f e3       	ldi	r21, 0x3F	; 63
    2514:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2518:	88 23       	and	r24, r24
    251a:	44 f4       	brge	.+16     	; 0x252c <main+0x636>
		__ticks = 1;
    251c:	fe 01       	movw	r30, r28
    251e:	e3 55       	subi	r30, 0x53	; 83
    2520:	ff 4f       	sbci	r31, 0xFF	; 255
    2522:	81 e0       	ldi	r24, 0x01	; 1
    2524:	90 e0       	ldi	r25, 0x00	; 0
    2526:	91 83       	std	Z+1, r25	; 0x01
    2528:	80 83       	st	Z, r24
    252a:	64 c0       	rjmp	.+200    	; 0x25f4 <main+0x6fe>
	else if (__tmp > 65535)
    252c:	fe 01       	movw	r30, r28
    252e:	e1 55       	subi	r30, 0x51	; 81
    2530:	ff 4f       	sbci	r31, 0xFF	; 255
    2532:	60 81       	ld	r22, Z
    2534:	71 81       	ldd	r23, Z+1	; 0x01
    2536:	82 81       	ldd	r24, Z+2	; 0x02
    2538:	93 81       	ldd	r25, Z+3	; 0x03
    253a:	20 e0       	ldi	r18, 0x00	; 0
    253c:	3f ef       	ldi	r19, 0xFF	; 255
    253e:	4f e7       	ldi	r20, 0x7F	; 127
    2540:	57 e4       	ldi	r21, 0x47	; 71
    2542:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2546:	18 16       	cp	r1, r24
    2548:	0c f0       	brlt	.+2      	; 0x254c <main+0x656>
    254a:	43 c0       	rjmp	.+134    	; 0x25d2 <main+0x6dc>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    254c:	fe 01       	movw	r30, r28
    254e:	ed 54       	subi	r30, 0x4D	; 77
    2550:	ff 4f       	sbci	r31, 0xFF	; 255
    2552:	60 81       	ld	r22, Z
    2554:	71 81       	ldd	r23, Z+1	; 0x01
    2556:	82 81       	ldd	r24, Z+2	; 0x02
    2558:	93 81       	ldd	r25, Z+3	; 0x03
    255a:	20 e0       	ldi	r18, 0x00	; 0
    255c:	30 e0       	ldi	r19, 0x00	; 0
    255e:	40 e2       	ldi	r20, 0x20	; 32
    2560:	51 e4       	ldi	r21, 0x41	; 65
    2562:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2566:	dc 01       	movw	r26, r24
    2568:	cb 01       	movw	r24, r22
    256a:	8e 01       	movw	r16, r28
    256c:	03 55       	subi	r16, 0x53	; 83
    256e:	1f 4f       	sbci	r17, 0xFF	; 255
    2570:	bc 01       	movw	r22, r24
    2572:	cd 01       	movw	r24, r26
    2574:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2578:	dc 01       	movw	r26, r24
    257a:	cb 01       	movw	r24, r22
    257c:	f8 01       	movw	r30, r16
    257e:	91 83       	std	Z+1, r25	; 0x01
    2580:	80 83       	st	Z, r24
    2582:	1f c0       	rjmp	.+62     	; 0x25c2 <main+0x6cc>
    2584:	fe 01       	movw	r30, r28
    2586:	e5 55       	subi	r30, 0x55	; 85
    2588:	ff 4f       	sbci	r31, 0xFF	; 255
    258a:	88 ec       	ldi	r24, 0xC8	; 200
    258c:	90 e0       	ldi	r25, 0x00	; 0
    258e:	91 83       	std	Z+1, r25	; 0x01
    2590:	80 83       	st	Z, r24
    2592:	fe 01       	movw	r30, r28
    2594:	e5 55       	subi	r30, 0x55	; 85
    2596:	ff 4f       	sbci	r31, 0xFF	; 255
    2598:	80 81       	ld	r24, Z
    259a:	91 81       	ldd	r25, Z+1	; 0x01
    259c:	01 97       	sbiw	r24, 0x01	; 1
    259e:	f1 f7       	brne	.-4      	; 0x259c <main+0x6a6>
    25a0:	fe 01       	movw	r30, r28
    25a2:	e5 55       	subi	r30, 0x55	; 85
    25a4:	ff 4f       	sbci	r31, 0xFF	; 255
    25a6:	91 83       	std	Z+1, r25	; 0x01
    25a8:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    25aa:	de 01       	movw	r26, r28
    25ac:	a3 55       	subi	r26, 0x53	; 83
    25ae:	bf 4f       	sbci	r27, 0xFF	; 255
    25b0:	fe 01       	movw	r30, r28
    25b2:	e3 55       	subi	r30, 0x53	; 83
    25b4:	ff 4f       	sbci	r31, 0xFF	; 255
    25b6:	80 81       	ld	r24, Z
    25b8:	91 81       	ldd	r25, Z+1	; 0x01
    25ba:	01 97       	sbiw	r24, 0x01	; 1
    25bc:	11 96       	adiw	r26, 0x01	; 1
    25be:	9c 93       	st	X, r25
    25c0:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    25c2:	fe 01       	movw	r30, r28
    25c4:	e3 55       	subi	r30, 0x53	; 83
    25c6:	ff 4f       	sbci	r31, 0xFF	; 255
    25c8:	80 81       	ld	r24, Z
    25ca:	91 81       	ldd	r25, Z+1	; 0x01
    25cc:	00 97       	sbiw	r24, 0x00	; 0
    25ce:	d1 f6       	brne	.-76     	; 0x2584 <main+0x68e>
    25d0:	27 c0       	rjmp	.+78     	; 0x2620 <main+0x72a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    25d2:	8e 01       	movw	r16, r28
    25d4:	03 55       	subi	r16, 0x53	; 83
    25d6:	1f 4f       	sbci	r17, 0xFF	; 255
    25d8:	fe 01       	movw	r30, r28
    25da:	e1 55       	subi	r30, 0x51	; 81
    25dc:	ff 4f       	sbci	r31, 0xFF	; 255
    25de:	60 81       	ld	r22, Z
    25e0:	71 81       	ldd	r23, Z+1	; 0x01
    25e2:	82 81       	ldd	r24, Z+2	; 0x02
    25e4:	93 81       	ldd	r25, Z+3	; 0x03
    25e6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    25ea:	dc 01       	movw	r26, r24
    25ec:	cb 01       	movw	r24, r22
    25ee:	f8 01       	movw	r30, r16
    25f0:	91 83       	std	Z+1, r25	; 0x01
    25f2:	80 83       	st	Z, r24
    25f4:	de 01       	movw	r26, r28
    25f6:	a7 55       	subi	r26, 0x57	; 87
    25f8:	bf 4f       	sbci	r27, 0xFF	; 255
    25fa:	fe 01       	movw	r30, r28
    25fc:	e3 55       	subi	r30, 0x53	; 83
    25fe:	ff 4f       	sbci	r31, 0xFF	; 255
    2600:	80 81       	ld	r24, Z
    2602:	91 81       	ldd	r25, Z+1	; 0x01
    2604:	8d 93       	st	X+, r24
    2606:	9c 93       	st	X, r25
    2608:	fe 01       	movw	r30, r28
    260a:	e7 55       	subi	r30, 0x57	; 87
    260c:	ff 4f       	sbci	r31, 0xFF	; 255
    260e:	80 81       	ld	r24, Z
    2610:	91 81       	ldd	r25, Z+1	; 0x01
    2612:	01 97       	sbiw	r24, 0x01	; 1
    2614:	f1 f7       	brne	.-4      	; 0x2612 <main+0x71c>
    2616:	fe 01       	movw	r30, r28
    2618:	e7 55       	subi	r30, 0x57	; 87
    261a:	ff 4f       	sbci	r31, 0xFF	; 255
    261c:	91 83       	std	Z+1, r25	; 0x01
    261e:	80 83       	st	Z, r24
				_delay_ms(10);
				EEPROM_writeByte(0x0315, confirmation_password[1]);
    2620:	fe 01       	movw	r30, r28
    2622:	eb 52       	subi	r30, 0x2B	; 43
    2624:	ff 4f       	sbci	r31, 0xFF	; 255
    2626:	21 81       	ldd	r18, Z+1	; 0x01
    2628:	85 e1       	ldi	r24, 0x15	; 21
    262a:	93 e0       	ldi	r25, 0x03	; 3
    262c:	62 2f       	mov	r22, r18
    262e:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <EEPROM_writeByte>
    2632:	fe 01       	movw	r30, r28
    2634:	eb 55       	subi	r30, 0x5B	; 91
    2636:	ff 4f       	sbci	r31, 0xFF	; 255
    2638:	80 e0       	ldi	r24, 0x00	; 0
    263a:	90 e0       	ldi	r25, 0x00	; 0
    263c:	a0 e2       	ldi	r26, 0x20	; 32
    263e:	b1 e4       	ldi	r27, 0x41	; 65
    2640:	80 83       	st	Z, r24
    2642:	91 83       	std	Z+1, r25	; 0x01
    2644:	a2 83       	std	Z+2, r26	; 0x02
    2646:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2648:	8e 01       	movw	r16, r28
    264a:	0f 55       	subi	r16, 0x5F	; 95
    264c:	1f 4f       	sbci	r17, 0xFF	; 255
    264e:	fe 01       	movw	r30, r28
    2650:	eb 55       	subi	r30, 0x5B	; 91
    2652:	ff 4f       	sbci	r31, 0xFF	; 255
    2654:	60 81       	ld	r22, Z
    2656:	71 81       	ldd	r23, Z+1	; 0x01
    2658:	82 81       	ldd	r24, Z+2	; 0x02
    265a:	93 81       	ldd	r25, Z+3	; 0x03
    265c:	20 e0       	ldi	r18, 0x00	; 0
    265e:	30 e0       	ldi	r19, 0x00	; 0
    2660:	4a ef       	ldi	r20, 0xFA	; 250
    2662:	54 e4       	ldi	r21, 0x44	; 68
    2664:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2668:	dc 01       	movw	r26, r24
    266a:	cb 01       	movw	r24, r22
    266c:	f8 01       	movw	r30, r16
    266e:	80 83       	st	Z, r24
    2670:	91 83       	std	Z+1, r25	; 0x01
    2672:	a2 83       	std	Z+2, r26	; 0x02
    2674:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    2676:	fe 01       	movw	r30, r28
    2678:	ef 55       	subi	r30, 0x5F	; 95
    267a:	ff 4f       	sbci	r31, 0xFF	; 255
    267c:	60 81       	ld	r22, Z
    267e:	71 81       	ldd	r23, Z+1	; 0x01
    2680:	82 81       	ldd	r24, Z+2	; 0x02
    2682:	93 81       	ldd	r25, Z+3	; 0x03
    2684:	20 e0       	ldi	r18, 0x00	; 0
    2686:	30 e0       	ldi	r19, 0x00	; 0
    2688:	40 e8       	ldi	r20, 0x80	; 128
    268a:	5f e3       	ldi	r21, 0x3F	; 63
    268c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2690:	88 23       	and	r24, r24
    2692:	44 f4       	brge	.+16     	; 0x26a4 <main+0x7ae>
		__ticks = 1;
    2694:	fe 01       	movw	r30, r28
    2696:	e1 56       	subi	r30, 0x61	; 97
    2698:	ff 4f       	sbci	r31, 0xFF	; 255
    269a:	81 e0       	ldi	r24, 0x01	; 1
    269c:	90 e0       	ldi	r25, 0x00	; 0
    269e:	91 83       	std	Z+1, r25	; 0x01
    26a0:	80 83       	st	Z, r24
    26a2:	64 c0       	rjmp	.+200    	; 0x276c <main+0x876>
	else if (__tmp > 65535)
    26a4:	fe 01       	movw	r30, r28
    26a6:	ef 55       	subi	r30, 0x5F	; 95
    26a8:	ff 4f       	sbci	r31, 0xFF	; 255
    26aa:	60 81       	ld	r22, Z
    26ac:	71 81       	ldd	r23, Z+1	; 0x01
    26ae:	82 81       	ldd	r24, Z+2	; 0x02
    26b0:	93 81       	ldd	r25, Z+3	; 0x03
    26b2:	20 e0       	ldi	r18, 0x00	; 0
    26b4:	3f ef       	ldi	r19, 0xFF	; 255
    26b6:	4f e7       	ldi	r20, 0x7F	; 127
    26b8:	57 e4       	ldi	r21, 0x47	; 71
    26ba:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    26be:	18 16       	cp	r1, r24
    26c0:	0c f0       	brlt	.+2      	; 0x26c4 <main+0x7ce>
    26c2:	43 c0       	rjmp	.+134    	; 0x274a <main+0x854>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    26c4:	fe 01       	movw	r30, r28
    26c6:	eb 55       	subi	r30, 0x5B	; 91
    26c8:	ff 4f       	sbci	r31, 0xFF	; 255
    26ca:	60 81       	ld	r22, Z
    26cc:	71 81       	ldd	r23, Z+1	; 0x01
    26ce:	82 81       	ldd	r24, Z+2	; 0x02
    26d0:	93 81       	ldd	r25, Z+3	; 0x03
    26d2:	20 e0       	ldi	r18, 0x00	; 0
    26d4:	30 e0       	ldi	r19, 0x00	; 0
    26d6:	40 e2       	ldi	r20, 0x20	; 32
    26d8:	51 e4       	ldi	r21, 0x41	; 65
    26da:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    26de:	dc 01       	movw	r26, r24
    26e0:	cb 01       	movw	r24, r22
    26e2:	8e 01       	movw	r16, r28
    26e4:	01 56       	subi	r16, 0x61	; 97
    26e6:	1f 4f       	sbci	r17, 0xFF	; 255
    26e8:	bc 01       	movw	r22, r24
    26ea:	cd 01       	movw	r24, r26
    26ec:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    26f0:	dc 01       	movw	r26, r24
    26f2:	cb 01       	movw	r24, r22
    26f4:	f8 01       	movw	r30, r16
    26f6:	91 83       	std	Z+1, r25	; 0x01
    26f8:	80 83       	st	Z, r24
    26fa:	1f c0       	rjmp	.+62     	; 0x273a <main+0x844>
    26fc:	fe 01       	movw	r30, r28
    26fe:	e3 56       	subi	r30, 0x63	; 99
    2700:	ff 4f       	sbci	r31, 0xFF	; 255
    2702:	88 ec       	ldi	r24, 0xC8	; 200
    2704:	90 e0       	ldi	r25, 0x00	; 0
    2706:	91 83       	std	Z+1, r25	; 0x01
    2708:	80 83       	st	Z, r24
    270a:	fe 01       	movw	r30, r28
    270c:	e3 56       	subi	r30, 0x63	; 99
    270e:	ff 4f       	sbci	r31, 0xFF	; 255
    2710:	80 81       	ld	r24, Z
    2712:	91 81       	ldd	r25, Z+1	; 0x01
    2714:	01 97       	sbiw	r24, 0x01	; 1
    2716:	f1 f7       	brne	.-4      	; 0x2714 <main+0x81e>
    2718:	fe 01       	movw	r30, r28
    271a:	e3 56       	subi	r30, 0x63	; 99
    271c:	ff 4f       	sbci	r31, 0xFF	; 255
    271e:	91 83       	std	Z+1, r25	; 0x01
    2720:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2722:	de 01       	movw	r26, r28
    2724:	a1 56       	subi	r26, 0x61	; 97
    2726:	bf 4f       	sbci	r27, 0xFF	; 255
    2728:	fe 01       	movw	r30, r28
    272a:	e1 56       	subi	r30, 0x61	; 97
    272c:	ff 4f       	sbci	r31, 0xFF	; 255
    272e:	80 81       	ld	r24, Z
    2730:	91 81       	ldd	r25, Z+1	; 0x01
    2732:	01 97       	sbiw	r24, 0x01	; 1
    2734:	11 96       	adiw	r26, 0x01	; 1
    2736:	9c 93       	st	X, r25
    2738:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    273a:	fe 01       	movw	r30, r28
    273c:	e1 56       	subi	r30, 0x61	; 97
    273e:	ff 4f       	sbci	r31, 0xFF	; 255
    2740:	80 81       	ld	r24, Z
    2742:	91 81       	ldd	r25, Z+1	; 0x01
    2744:	00 97       	sbiw	r24, 0x00	; 0
    2746:	d1 f6       	brne	.-76     	; 0x26fc <main+0x806>
    2748:	27 c0       	rjmp	.+78     	; 0x2798 <main+0x8a2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    274a:	8e 01       	movw	r16, r28
    274c:	01 56       	subi	r16, 0x61	; 97
    274e:	1f 4f       	sbci	r17, 0xFF	; 255
    2750:	fe 01       	movw	r30, r28
    2752:	ef 55       	subi	r30, 0x5F	; 95
    2754:	ff 4f       	sbci	r31, 0xFF	; 255
    2756:	60 81       	ld	r22, Z
    2758:	71 81       	ldd	r23, Z+1	; 0x01
    275a:	82 81       	ldd	r24, Z+2	; 0x02
    275c:	93 81       	ldd	r25, Z+3	; 0x03
    275e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2762:	dc 01       	movw	r26, r24
    2764:	cb 01       	movw	r24, r22
    2766:	f8 01       	movw	r30, r16
    2768:	91 83       	std	Z+1, r25	; 0x01
    276a:	80 83       	st	Z, r24
    276c:	de 01       	movw	r26, r28
    276e:	a5 56       	subi	r26, 0x65	; 101
    2770:	bf 4f       	sbci	r27, 0xFF	; 255
    2772:	fe 01       	movw	r30, r28
    2774:	e1 56       	subi	r30, 0x61	; 97
    2776:	ff 4f       	sbci	r31, 0xFF	; 255
    2778:	80 81       	ld	r24, Z
    277a:	91 81       	ldd	r25, Z+1	; 0x01
    277c:	8d 93       	st	X+, r24
    277e:	9c 93       	st	X, r25
    2780:	fe 01       	movw	r30, r28
    2782:	e5 56       	subi	r30, 0x65	; 101
    2784:	ff 4f       	sbci	r31, 0xFF	; 255
    2786:	80 81       	ld	r24, Z
    2788:	91 81       	ldd	r25, Z+1	; 0x01
    278a:	01 97       	sbiw	r24, 0x01	; 1
    278c:	f1 f7       	brne	.-4      	; 0x278a <main+0x894>
    278e:	fe 01       	movw	r30, r28
    2790:	e5 56       	subi	r30, 0x65	; 101
    2792:	ff 4f       	sbci	r31, 0xFF	; 255
    2794:	91 83       	std	Z+1, r25	; 0x01
    2796:	80 83       	st	Z, r24
				_delay_ms(10);
				EEPROM_readByte(0x0315, &confirmation_password[1]);
    2798:	ce 01       	movw	r24, r28
    279a:	8b 52       	subi	r24, 0x2B	; 43
    279c:	9f 4f       	sbci	r25, 0xFF	; 255
    279e:	9c 01       	movw	r18, r24
    27a0:	2f 5f       	subi	r18, 0xFF	; 255
    27a2:	3f 4f       	sbci	r19, 0xFF	; 255
    27a4:	85 e1       	ldi	r24, 0x15	; 21
    27a6:	93 e0       	ldi	r25, 0x03	; 3
    27a8:	b9 01       	movw	r22, r18
    27aa:	0e 94 65 0e 	call	0x1cca	; 0x1cca <EEPROM_readByte>
    27ae:	fe 01       	movw	r30, r28
    27b0:	e9 56       	subi	r30, 0x69	; 105
    27b2:	ff 4f       	sbci	r31, 0xFF	; 255
    27b4:	80 e0       	ldi	r24, 0x00	; 0
    27b6:	90 e0       	ldi	r25, 0x00	; 0
    27b8:	a0 e2       	ldi	r26, 0x20	; 32
    27ba:	b1 e4       	ldi	r27, 0x41	; 65
    27bc:	80 83       	st	Z, r24
    27be:	91 83       	std	Z+1, r25	; 0x01
    27c0:	a2 83       	std	Z+2, r26	; 0x02
    27c2:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    27c4:	8e 01       	movw	r16, r28
    27c6:	0d 56       	subi	r16, 0x6D	; 109
    27c8:	1f 4f       	sbci	r17, 0xFF	; 255
    27ca:	fe 01       	movw	r30, r28
    27cc:	e9 56       	subi	r30, 0x69	; 105
    27ce:	ff 4f       	sbci	r31, 0xFF	; 255
    27d0:	60 81       	ld	r22, Z
    27d2:	71 81       	ldd	r23, Z+1	; 0x01
    27d4:	82 81       	ldd	r24, Z+2	; 0x02
    27d6:	93 81       	ldd	r25, Z+3	; 0x03
    27d8:	20 e0       	ldi	r18, 0x00	; 0
    27da:	30 e0       	ldi	r19, 0x00	; 0
    27dc:	4a ef       	ldi	r20, 0xFA	; 250
    27de:	54 e4       	ldi	r21, 0x44	; 68
    27e0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    27e4:	dc 01       	movw	r26, r24
    27e6:	cb 01       	movw	r24, r22
    27e8:	f8 01       	movw	r30, r16
    27ea:	80 83       	st	Z, r24
    27ec:	91 83       	std	Z+1, r25	; 0x01
    27ee:	a2 83       	std	Z+2, r26	; 0x02
    27f0:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    27f2:	fe 01       	movw	r30, r28
    27f4:	ed 56       	subi	r30, 0x6D	; 109
    27f6:	ff 4f       	sbci	r31, 0xFF	; 255
    27f8:	60 81       	ld	r22, Z
    27fa:	71 81       	ldd	r23, Z+1	; 0x01
    27fc:	82 81       	ldd	r24, Z+2	; 0x02
    27fe:	93 81       	ldd	r25, Z+3	; 0x03
    2800:	20 e0       	ldi	r18, 0x00	; 0
    2802:	30 e0       	ldi	r19, 0x00	; 0
    2804:	40 e8       	ldi	r20, 0x80	; 128
    2806:	5f e3       	ldi	r21, 0x3F	; 63
    2808:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    280c:	88 23       	and	r24, r24
    280e:	44 f4       	brge	.+16     	; 0x2820 <main+0x92a>
		__ticks = 1;
    2810:	fe 01       	movw	r30, r28
    2812:	ef 56       	subi	r30, 0x6F	; 111
    2814:	ff 4f       	sbci	r31, 0xFF	; 255
    2816:	81 e0       	ldi	r24, 0x01	; 1
    2818:	90 e0       	ldi	r25, 0x00	; 0
    281a:	91 83       	std	Z+1, r25	; 0x01
    281c:	80 83       	st	Z, r24
    281e:	64 c0       	rjmp	.+200    	; 0x28e8 <main+0x9f2>
	else if (__tmp > 65535)
    2820:	fe 01       	movw	r30, r28
    2822:	ed 56       	subi	r30, 0x6D	; 109
    2824:	ff 4f       	sbci	r31, 0xFF	; 255
    2826:	60 81       	ld	r22, Z
    2828:	71 81       	ldd	r23, Z+1	; 0x01
    282a:	82 81       	ldd	r24, Z+2	; 0x02
    282c:	93 81       	ldd	r25, Z+3	; 0x03
    282e:	20 e0       	ldi	r18, 0x00	; 0
    2830:	3f ef       	ldi	r19, 0xFF	; 255
    2832:	4f e7       	ldi	r20, 0x7F	; 127
    2834:	57 e4       	ldi	r21, 0x47	; 71
    2836:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    283a:	18 16       	cp	r1, r24
    283c:	0c f0       	brlt	.+2      	; 0x2840 <main+0x94a>
    283e:	43 c0       	rjmp	.+134    	; 0x28c6 <main+0x9d0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2840:	fe 01       	movw	r30, r28
    2842:	e9 56       	subi	r30, 0x69	; 105
    2844:	ff 4f       	sbci	r31, 0xFF	; 255
    2846:	60 81       	ld	r22, Z
    2848:	71 81       	ldd	r23, Z+1	; 0x01
    284a:	82 81       	ldd	r24, Z+2	; 0x02
    284c:	93 81       	ldd	r25, Z+3	; 0x03
    284e:	20 e0       	ldi	r18, 0x00	; 0
    2850:	30 e0       	ldi	r19, 0x00	; 0
    2852:	40 e2       	ldi	r20, 0x20	; 32
    2854:	51 e4       	ldi	r21, 0x41	; 65
    2856:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    285a:	dc 01       	movw	r26, r24
    285c:	cb 01       	movw	r24, r22
    285e:	8e 01       	movw	r16, r28
    2860:	0f 56       	subi	r16, 0x6F	; 111
    2862:	1f 4f       	sbci	r17, 0xFF	; 255
    2864:	bc 01       	movw	r22, r24
    2866:	cd 01       	movw	r24, r26
    2868:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    286c:	dc 01       	movw	r26, r24
    286e:	cb 01       	movw	r24, r22
    2870:	f8 01       	movw	r30, r16
    2872:	91 83       	std	Z+1, r25	; 0x01
    2874:	80 83       	st	Z, r24
    2876:	1f c0       	rjmp	.+62     	; 0x28b6 <main+0x9c0>
    2878:	fe 01       	movw	r30, r28
    287a:	e1 57       	subi	r30, 0x71	; 113
    287c:	ff 4f       	sbci	r31, 0xFF	; 255
    287e:	88 ec       	ldi	r24, 0xC8	; 200
    2880:	90 e0       	ldi	r25, 0x00	; 0
    2882:	91 83       	std	Z+1, r25	; 0x01
    2884:	80 83       	st	Z, r24
    2886:	fe 01       	movw	r30, r28
    2888:	e1 57       	subi	r30, 0x71	; 113
    288a:	ff 4f       	sbci	r31, 0xFF	; 255
    288c:	80 81       	ld	r24, Z
    288e:	91 81       	ldd	r25, Z+1	; 0x01
    2890:	01 97       	sbiw	r24, 0x01	; 1
    2892:	f1 f7       	brne	.-4      	; 0x2890 <main+0x99a>
    2894:	fe 01       	movw	r30, r28
    2896:	e1 57       	subi	r30, 0x71	; 113
    2898:	ff 4f       	sbci	r31, 0xFF	; 255
    289a:	91 83       	std	Z+1, r25	; 0x01
    289c:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    289e:	de 01       	movw	r26, r28
    28a0:	af 56       	subi	r26, 0x6F	; 111
    28a2:	bf 4f       	sbci	r27, 0xFF	; 255
    28a4:	fe 01       	movw	r30, r28
    28a6:	ef 56       	subi	r30, 0x6F	; 111
    28a8:	ff 4f       	sbci	r31, 0xFF	; 255
    28aa:	80 81       	ld	r24, Z
    28ac:	91 81       	ldd	r25, Z+1	; 0x01
    28ae:	01 97       	sbiw	r24, 0x01	; 1
    28b0:	11 96       	adiw	r26, 0x01	; 1
    28b2:	9c 93       	st	X, r25
    28b4:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    28b6:	fe 01       	movw	r30, r28
    28b8:	ef 56       	subi	r30, 0x6F	; 111
    28ba:	ff 4f       	sbci	r31, 0xFF	; 255
    28bc:	80 81       	ld	r24, Z
    28be:	91 81       	ldd	r25, Z+1	; 0x01
    28c0:	00 97       	sbiw	r24, 0x00	; 0
    28c2:	d1 f6       	brne	.-76     	; 0x2878 <main+0x982>
    28c4:	27 c0       	rjmp	.+78     	; 0x2914 <main+0xa1e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    28c6:	8e 01       	movw	r16, r28
    28c8:	0f 56       	subi	r16, 0x6F	; 111
    28ca:	1f 4f       	sbci	r17, 0xFF	; 255
    28cc:	fe 01       	movw	r30, r28
    28ce:	ed 56       	subi	r30, 0x6D	; 109
    28d0:	ff 4f       	sbci	r31, 0xFF	; 255
    28d2:	60 81       	ld	r22, Z
    28d4:	71 81       	ldd	r23, Z+1	; 0x01
    28d6:	82 81       	ldd	r24, Z+2	; 0x02
    28d8:	93 81       	ldd	r25, Z+3	; 0x03
    28da:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    28de:	dc 01       	movw	r26, r24
    28e0:	cb 01       	movw	r24, r22
    28e2:	f8 01       	movw	r30, r16
    28e4:	91 83       	std	Z+1, r25	; 0x01
    28e6:	80 83       	st	Z, r24
    28e8:	de 01       	movw	r26, r28
    28ea:	a3 57       	subi	r26, 0x73	; 115
    28ec:	bf 4f       	sbci	r27, 0xFF	; 255
    28ee:	fe 01       	movw	r30, r28
    28f0:	ef 56       	subi	r30, 0x6F	; 111
    28f2:	ff 4f       	sbci	r31, 0xFF	; 255
    28f4:	80 81       	ld	r24, Z
    28f6:	91 81       	ldd	r25, Z+1	; 0x01
    28f8:	8d 93       	st	X+, r24
    28fa:	9c 93       	st	X, r25
    28fc:	fe 01       	movw	r30, r28
    28fe:	e3 57       	subi	r30, 0x73	; 115
    2900:	ff 4f       	sbci	r31, 0xFF	; 255
    2902:	80 81       	ld	r24, Z
    2904:	91 81       	ldd	r25, Z+1	; 0x01
    2906:	01 97       	sbiw	r24, 0x01	; 1
    2908:	f1 f7       	brne	.-4      	; 0x2906 <main+0xa10>
    290a:	fe 01       	movw	r30, r28
    290c:	e3 57       	subi	r30, 0x73	; 115
    290e:	ff 4f       	sbci	r31, 0xFF	; 255
    2910:	91 83       	std	Z+1, r25	; 0x01
    2912:	80 83       	st	Z, r24
				_delay_ms(10);
				EEPROM_writeByte(0x0320, confirmation_password[2]);
    2914:	fe 01       	movw	r30, r28
    2916:	eb 52       	subi	r30, 0x2B	; 43
    2918:	ff 4f       	sbci	r31, 0xFF	; 255
    291a:	22 81       	ldd	r18, Z+2	; 0x02
    291c:	80 e2       	ldi	r24, 0x20	; 32
    291e:	93 e0       	ldi	r25, 0x03	; 3
    2920:	62 2f       	mov	r22, r18
    2922:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <EEPROM_writeByte>
    2926:	fe 01       	movw	r30, r28
    2928:	e7 57       	subi	r30, 0x77	; 119
    292a:	ff 4f       	sbci	r31, 0xFF	; 255
    292c:	80 e0       	ldi	r24, 0x00	; 0
    292e:	90 e0       	ldi	r25, 0x00	; 0
    2930:	a0 e2       	ldi	r26, 0x20	; 32
    2932:	b1 e4       	ldi	r27, 0x41	; 65
    2934:	80 83       	st	Z, r24
    2936:	91 83       	std	Z+1, r25	; 0x01
    2938:	a2 83       	std	Z+2, r26	; 0x02
    293a:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    293c:	8e 01       	movw	r16, r28
    293e:	0b 57       	subi	r16, 0x7B	; 123
    2940:	1f 4f       	sbci	r17, 0xFF	; 255
    2942:	fe 01       	movw	r30, r28
    2944:	e7 57       	subi	r30, 0x77	; 119
    2946:	ff 4f       	sbci	r31, 0xFF	; 255
    2948:	60 81       	ld	r22, Z
    294a:	71 81       	ldd	r23, Z+1	; 0x01
    294c:	82 81       	ldd	r24, Z+2	; 0x02
    294e:	93 81       	ldd	r25, Z+3	; 0x03
    2950:	20 e0       	ldi	r18, 0x00	; 0
    2952:	30 e0       	ldi	r19, 0x00	; 0
    2954:	4a ef       	ldi	r20, 0xFA	; 250
    2956:	54 e4       	ldi	r21, 0x44	; 68
    2958:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    295c:	dc 01       	movw	r26, r24
    295e:	cb 01       	movw	r24, r22
    2960:	f8 01       	movw	r30, r16
    2962:	80 83       	st	Z, r24
    2964:	91 83       	std	Z+1, r25	; 0x01
    2966:	a2 83       	std	Z+2, r26	; 0x02
    2968:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    296a:	fe 01       	movw	r30, r28
    296c:	eb 57       	subi	r30, 0x7B	; 123
    296e:	ff 4f       	sbci	r31, 0xFF	; 255
    2970:	60 81       	ld	r22, Z
    2972:	71 81       	ldd	r23, Z+1	; 0x01
    2974:	82 81       	ldd	r24, Z+2	; 0x02
    2976:	93 81       	ldd	r25, Z+3	; 0x03
    2978:	20 e0       	ldi	r18, 0x00	; 0
    297a:	30 e0       	ldi	r19, 0x00	; 0
    297c:	40 e8       	ldi	r20, 0x80	; 128
    297e:	5f e3       	ldi	r21, 0x3F	; 63
    2980:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2984:	88 23       	and	r24, r24
    2986:	44 f4       	brge	.+16     	; 0x2998 <main+0xaa2>
		__ticks = 1;
    2988:	fe 01       	movw	r30, r28
    298a:	ed 57       	subi	r30, 0x7D	; 125
    298c:	ff 4f       	sbci	r31, 0xFF	; 255
    298e:	81 e0       	ldi	r24, 0x01	; 1
    2990:	90 e0       	ldi	r25, 0x00	; 0
    2992:	91 83       	std	Z+1, r25	; 0x01
    2994:	80 83       	st	Z, r24
    2996:	64 c0       	rjmp	.+200    	; 0x2a60 <main+0xb6a>
	else if (__tmp > 65535)
    2998:	fe 01       	movw	r30, r28
    299a:	eb 57       	subi	r30, 0x7B	; 123
    299c:	ff 4f       	sbci	r31, 0xFF	; 255
    299e:	60 81       	ld	r22, Z
    29a0:	71 81       	ldd	r23, Z+1	; 0x01
    29a2:	82 81       	ldd	r24, Z+2	; 0x02
    29a4:	93 81       	ldd	r25, Z+3	; 0x03
    29a6:	20 e0       	ldi	r18, 0x00	; 0
    29a8:	3f ef       	ldi	r19, 0xFF	; 255
    29aa:	4f e7       	ldi	r20, 0x7F	; 127
    29ac:	57 e4       	ldi	r21, 0x47	; 71
    29ae:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    29b2:	18 16       	cp	r1, r24
    29b4:	0c f0       	brlt	.+2      	; 0x29b8 <main+0xac2>
    29b6:	43 c0       	rjmp	.+134    	; 0x2a3e <main+0xb48>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    29b8:	fe 01       	movw	r30, r28
    29ba:	e7 57       	subi	r30, 0x77	; 119
    29bc:	ff 4f       	sbci	r31, 0xFF	; 255
    29be:	60 81       	ld	r22, Z
    29c0:	71 81       	ldd	r23, Z+1	; 0x01
    29c2:	82 81       	ldd	r24, Z+2	; 0x02
    29c4:	93 81       	ldd	r25, Z+3	; 0x03
    29c6:	20 e0       	ldi	r18, 0x00	; 0
    29c8:	30 e0       	ldi	r19, 0x00	; 0
    29ca:	40 e2       	ldi	r20, 0x20	; 32
    29cc:	51 e4       	ldi	r21, 0x41	; 65
    29ce:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    29d2:	dc 01       	movw	r26, r24
    29d4:	cb 01       	movw	r24, r22
    29d6:	8e 01       	movw	r16, r28
    29d8:	0d 57       	subi	r16, 0x7D	; 125
    29da:	1f 4f       	sbci	r17, 0xFF	; 255
    29dc:	bc 01       	movw	r22, r24
    29de:	cd 01       	movw	r24, r26
    29e0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    29e4:	dc 01       	movw	r26, r24
    29e6:	cb 01       	movw	r24, r22
    29e8:	f8 01       	movw	r30, r16
    29ea:	91 83       	std	Z+1, r25	; 0x01
    29ec:	80 83       	st	Z, r24
    29ee:	1f c0       	rjmp	.+62     	; 0x2a2e <main+0xb38>
    29f0:	fe 01       	movw	r30, r28
    29f2:	ef 57       	subi	r30, 0x7F	; 127
    29f4:	ff 4f       	sbci	r31, 0xFF	; 255
    29f6:	88 ec       	ldi	r24, 0xC8	; 200
    29f8:	90 e0       	ldi	r25, 0x00	; 0
    29fa:	91 83       	std	Z+1, r25	; 0x01
    29fc:	80 83       	st	Z, r24
    29fe:	fe 01       	movw	r30, r28
    2a00:	ef 57       	subi	r30, 0x7F	; 127
    2a02:	ff 4f       	sbci	r31, 0xFF	; 255
    2a04:	80 81       	ld	r24, Z
    2a06:	91 81       	ldd	r25, Z+1	; 0x01
    2a08:	01 97       	sbiw	r24, 0x01	; 1
    2a0a:	f1 f7       	brne	.-4      	; 0x2a08 <main+0xb12>
    2a0c:	fe 01       	movw	r30, r28
    2a0e:	ef 57       	subi	r30, 0x7F	; 127
    2a10:	ff 4f       	sbci	r31, 0xFF	; 255
    2a12:	91 83       	std	Z+1, r25	; 0x01
    2a14:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2a16:	de 01       	movw	r26, r28
    2a18:	ad 57       	subi	r26, 0x7D	; 125
    2a1a:	bf 4f       	sbci	r27, 0xFF	; 255
    2a1c:	fe 01       	movw	r30, r28
    2a1e:	ed 57       	subi	r30, 0x7D	; 125
    2a20:	ff 4f       	sbci	r31, 0xFF	; 255
    2a22:	80 81       	ld	r24, Z
    2a24:	91 81       	ldd	r25, Z+1	; 0x01
    2a26:	01 97       	sbiw	r24, 0x01	; 1
    2a28:	11 96       	adiw	r26, 0x01	; 1
    2a2a:	9c 93       	st	X, r25
    2a2c:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2a2e:	fe 01       	movw	r30, r28
    2a30:	ed 57       	subi	r30, 0x7D	; 125
    2a32:	ff 4f       	sbci	r31, 0xFF	; 255
    2a34:	80 81       	ld	r24, Z
    2a36:	91 81       	ldd	r25, Z+1	; 0x01
    2a38:	00 97       	sbiw	r24, 0x00	; 0
    2a3a:	d1 f6       	brne	.-76     	; 0x29f0 <main+0xafa>
    2a3c:	27 c0       	rjmp	.+78     	; 0x2a8c <main+0xb96>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2a3e:	8e 01       	movw	r16, r28
    2a40:	0d 57       	subi	r16, 0x7D	; 125
    2a42:	1f 4f       	sbci	r17, 0xFF	; 255
    2a44:	fe 01       	movw	r30, r28
    2a46:	eb 57       	subi	r30, 0x7B	; 123
    2a48:	ff 4f       	sbci	r31, 0xFF	; 255
    2a4a:	60 81       	ld	r22, Z
    2a4c:	71 81       	ldd	r23, Z+1	; 0x01
    2a4e:	82 81       	ldd	r24, Z+2	; 0x02
    2a50:	93 81       	ldd	r25, Z+3	; 0x03
    2a52:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2a56:	dc 01       	movw	r26, r24
    2a58:	cb 01       	movw	r24, r22
    2a5a:	f8 01       	movw	r30, r16
    2a5c:	91 83       	std	Z+1, r25	; 0x01
    2a5e:	80 83       	st	Z, r24
    2a60:	de 01       	movw	r26, r28
    2a62:	a1 58       	subi	r26, 0x81	; 129
    2a64:	bf 4f       	sbci	r27, 0xFF	; 255
    2a66:	fe 01       	movw	r30, r28
    2a68:	ed 57       	subi	r30, 0x7D	; 125
    2a6a:	ff 4f       	sbci	r31, 0xFF	; 255
    2a6c:	80 81       	ld	r24, Z
    2a6e:	91 81       	ldd	r25, Z+1	; 0x01
    2a70:	8d 93       	st	X+, r24
    2a72:	9c 93       	st	X, r25
    2a74:	fe 01       	movw	r30, r28
    2a76:	e1 58       	subi	r30, 0x81	; 129
    2a78:	ff 4f       	sbci	r31, 0xFF	; 255
    2a7a:	80 81       	ld	r24, Z
    2a7c:	91 81       	ldd	r25, Z+1	; 0x01
    2a7e:	01 97       	sbiw	r24, 0x01	; 1
    2a80:	f1 f7       	brne	.-4      	; 0x2a7e <main+0xb88>
    2a82:	fe 01       	movw	r30, r28
    2a84:	e1 58       	subi	r30, 0x81	; 129
    2a86:	ff 4f       	sbci	r31, 0xFF	; 255
    2a88:	91 83       	std	Z+1, r25	; 0x01
    2a8a:	80 83       	st	Z, r24
				_delay_ms(10);
				EEPROM_readByte(0x0320, &confirmation_password[2]);
    2a8c:	ce 01       	movw	r24, r28
    2a8e:	8b 52       	subi	r24, 0x2B	; 43
    2a90:	9f 4f       	sbci	r25, 0xFF	; 255
    2a92:	9c 01       	movw	r18, r24
    2a94:	2e 5f       	subi	r18, 0xFE	; 254
    2a96:	3f 4f       	sbci	r19, 0xFF	; 255
    2a98:	80 e2       	ldi	r24, 0x20	; 32
    2a9a:	93 e0       	ldi	r25, 0x03	; 3
    2a9c:	b9 01       	movw	r22, r18
    2a9e:	0e 94 65 0e 	call	0x1cca	; 0x1cca <EEPROM_readByte>
    2aa2:	fe 01       	movw	r30, r28
    2aa4:	e5 58       	subi	r30, 0x85	; 133
    2aa6:	ff 4f       	sbci	r31, 0xFF	; 255
    2aa8:	80 e0       	ldi	r24, 0x00	; 0
    2aaa:	90 e0       	ldi	r25, 0x00	; 0
    2aac:	a0 e2       	ldi	r26, 0x20	; 32
    2aae:	b1 e4       	ldi	r27, 0x41	; 65
    2ab0:	80 83       	st	Z, r24
    2ab2:	91 83       	std	Z+1, r25	; 0x01
    2ab4:	a2 83       	std	Z+2, r26	; 0x02
    2ab6:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2ab8:	8e 01       	movw	r16, r28
    2aba:	09 58       	subi	r16, 0x89	; 137
    2abc:	1f 4f       	sbci	r17, 0xFF	; 255
    2abe:	fe 01       	movw	r30, r28
    2ac0:	e5 58       	subi	r30, 0x85	; 133
    2ac2:	ff 4f       	sbci	r31, 0xFF	; 255
    2ac4:	60 81       	ld	r22, Z
    2ac6:	71 81       	ldd	r23, Z+1	; 0x01
    2ac8:	82 81       	ldd	r24, Z+2	; 0x02
    2aca:	93 81       	ldd	r25, Z+3	; 0x03
    2acc:	20 e0       	ldi	r18, 0x00	; 0
    2ace:	30 e0       	ldi	r19, 0x00	; 0
    2ad0:	4a ef       	ldi	r20, 0xFA	; 250
    2ad2:	54 e4       	ldi	r21, 0x44	; 68
    2ad4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2ad8:	dc 01       	movw	r26, r24
    2ada:	cb 01       	movw	r24, r22
    2adc:	f8 01       	movw	r30, r16
    2ade:	80 83       	st	Z, r24
    2ae0:	91 83       	std	Z+1, r25	; 0x01
    2ae2:	a2 83       	std	Z+2, r26	; 0x02
    2ae4:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    2ae6:	fe 01       	movw	r30, r28
    2ae8:	e9 58       	subi	r30, 0x89	; 137
    2aea:	ff 4f       	sbci	r31, 0xFF	; 255
    2aec:	60 81       	ld	r22, Z
    2aee:	71 81       	ldd	r23, Z+1	; 0x01
    2af0:	82 81       	ldd	r24, Z+2	; 0x02
    2af2:	93 81       	ldd	r25, Z+3	; 0x03
    2af4:	20 e0       	ldi	r18, 0x00	; 0
    2af6:	30 e0       	ldi	r19, 0x00	; 0
    2af8:	40 e8       	ldi	r20, 0x80	; 128
    2afa:	5f e3       	ldi	r21, 0x3F	; 63
    2afc:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2b00:	88 23       	and	r24, r24
    2b02:	44 f4       	brge	.+16     	; 0x2b14 <main+0xc1e>
		__ticks = 1;
    2b04:	fe 01       	movw	r30, r28
    2b06:	eb 58       	subi	r30, 0x8B	; 139
    2b08:	ff 4f       	sbci	r31, 0xFF	; 255
    2b0a:	81 e0       	ldi	r24, 0x01	; 1
    2b0c:	90 e0       	ldi	r25, 0x00	; 0
    2b0e:	91 83       	std	Z+1, r25	; 0x01
    2b10:	80 83       	st	Z, r24
    2b12:	64 c0       	rjmp	.+200    	; 0x2bdc <main+0xce6>
	else if (__tmp > 65535)
    2b14:	fe 01       	movw	r30, r28
    2b16:	e9 58       	subi	r30, 0x89	; 137
    2b18:	ff 4f       	sbci	r31, 0xFF	; 255
    2b1a:	60 81       	ld	r22, Z
    2b1c:	71 81       	ldd	r23, Z+1	; 0x01
    2b1e:	82 81       	ldd	r24, Z+2	; 0x02
    2b20:	93 81       	ldd	r25, Z+3	; 0x03
    2b22:	20 e0       	ldi	r18, 0x00	; 0
    2b24:	3f ef       	ldi	r19, 0xFF	; 255
    2b26:	4f e7       	ldi	r20, 0x7F	; 127
    2b28:	57 e4       	ldi	r21, 0x47	; 71
    2b2a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2b2e:	18 16       	cp	r1, r24
    2b30:	0c f0       	brlt	.+2      	; 0x2b34 <main+0xc3e>
    2b32:	43 c0       	rjmp	.+134    	; 0x2bba <main+0xcc4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2b34:	fe 01       	movw	r30, r28
    2b36:	e5 58       	subi	r30, 0x85	; 133
    2b38:	ff 4f       	sbci	r31, 0xFF	; 255
    2b3a:	60 81       	ld	r22, Z
    2b3c:	71 81       	ldd	r23, Z+1	; 0x01
    2b3e:	82 81       	ldd	r24, Z+2	; 0x02
    2b40:	93 81       	ldd	r25, Z+3	; 0x03
    2b42:	20 e0       	ldi	r18, 0x00	; 0
    2b44:	30 e0       	ldi	r19, 0x00	; 0
    2b46:	40 e2       	ldi	r20, 0x20	; 32
    2b48:	51 e4       	ldi	r21, 0x41	; 65
    2b4a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2b4e:	dc 01       	movw	r26, r24
    2b50:	cb 01       	movw	r24, r22
    2b52:	8e 01       	movw	r16, r28
    2b54:	0b 58       	subi	r16, 0x8B	; 139
    2b56:	1f 4f       	sbci	r17, 0xFF	; 255
    2b58:	bc 01       	movw	r22, r24
    2b5a:	cd 01       	movw	r24, r26
    2b5c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2b60:	dc 01       	movw	r26, r24
    2b62:	cb 01       	movw	r24, r22
    2b64:	f8 01       	movw	r30, r16
    2b66:	91 83       	std	Z+1, r25	; 0x01
    2b68:	80 83       	st	Z, r24
    2b6a:	1f c0       	rjmp	.+62     	; 0x2baa <main+0xcb4>
    2b6c:	fe 01       	movw	r30, r28
    2b6e:	ed 58       	subi	r30, 0x8D	; 141
    2b70:	ff 4f       	sbci	r31, 0xFF	; 255
    2b72:	88 ec       	ldi	r24, 0xC8	; 200
    2b74:	90 e0       	ldi	r25, 0x00	; 0
    2b76:	91 83       	std	Z+1, r25	; 0x01
    2b78:	80 83       	st	Z, r24
    2b7a:	fe 01       	movw	r30, r28
    2b7c:	ed 58       	subi	r30, 0x8D	; 141
    2b7e:	ff 4f       	sbci	r31, 0xFF	; 255
    2b80:	80 81       	ld	r24, Z
    2b82:	91 81       	ldd	r25, Z+1	; 0x01
    2b84:	01 97       	sbiw	r24, 0x01	; 1
    2b86:	f1 f7       	brne	.-4      	; 0x2b84 <main+0xc8e>
    2b88:	fe 01       	movw	r30, r28
    2b8a:	ed 58       	subi	r30, 0x8D	; 141
    2b8c:	ff 4f       	sbci	r31, 0xFF	; 255
    2b8e:	91 83       	std	Z+1, r25	; 0x01
    2b90:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2b92:	de 01       	movw	r26, r28
    2b94:	ab 58       	subi	r26, 0x8B	; 139
    2b96:	bf 4f       	sbci	r27, 0xFF	; 255
    2b98:	fe 01       	movw	r30, r28
    2b9a:	eb 58       	subi	r30, 0x8B	; 139
    2b9c:	ff 4f       	sbci	r31, 0xFF	; 255
    2b9e:	80 81       	ld	r24, Z
    2ba0:	91 81       	ldd	r25, Z+1	; 0x01
    2ba2:	01 97       	sbiw	r24, 0x01	; 1
    2ba4:	11 96       	adiw	r26, 0x01	; 1
    2ba6:	9c 93       	st	X, r25
    2ba8:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2baa:	fe 01       	movw	r30, r28
    2bac:	eb 58       	subi	r30, 0x8B	; 139
    2bae:	ff 4f       	sbci	r31, 0xFF	; 255
    2bb0:	80 81       	ld	r24, Z
    2bb2:	91 81       	ldd	r25, Z+1	; 0x01
    2bb4:	00 97       	sbiw	r24, 0x00	; 0
    2bb6:	d1 f6       	brne	.-76     	; 0x2b6c <main+0xc76>
    2bb8:	27 c0       	rjmp	.+78     	; 0x2c08 <main+0xd12>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2bba:	8e 01       	movw	r16, r28
    2bbc:	0b 58       	subi	r16, 0x8B	; 139
    2bbe:	1f 4f       	sbci	r17, 0xFF	; 255
    2bc0:	fe 01       	movw	r30, r28
    2bc2:	e9 58       	subi	r30, 0x89	; 137
    2bc4:	ff 4f       	sbci	r31, 0xFF	; 255
    2bc6:	60 81       	ld	r22, Z
    2bc8:	71 81       	ldd	r23, Z+1	; 0x01
    2bca:	82 81       	ldd	r24, Z+2	; 0x02
    2bcc:	93 81       	ldd	r25, Z+3	; 0x03
    2bce:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2bd2:	dc 01       	movw	r26, r24
    2bd4:	cb 01       	movw	r24, r22
    2bd6:	f8 01       	movw	r30, r16
    2bd8:	91 83       	std	Z+1, r25	; 0x01
    2bda:	80 83       	st	Z, r24
    2bdc:	de 01       	movw	r26, r28
    2bde:	af 58       	subi	r26, 0x8F	; 143
    2be0:	bf 4f       	sbci	r27, 0xFF	; 255
    2be2:	fe 01       	movw	r30, r28
    2be4:	eb 58       	subi	r30, 0x8B	; 139
    2be6:	ff 4f       	sbci	r31, 0xFF	; 255
    2be8:	80 81       	ld	r24, Z
    2bea:	91 81       	ldd	r25, Z+1	; 0x01
    2bec:	8d 93       	st	X+, r24
    2bee:	9c 93       	st	X, r25
    2bf0:	fe 01       	movw	r30, r28
    2bf2:	ef 58       	subi	r30, 0x8F	; 143
    2bf4:	ff 4f       	sbci	r31, 0xFF	; 255
    2bf6:	80 81       	ld	r24, Z
    2bf8:	91 81       	ldd	r25, Z+1	; 0x01
    2bfa:	01 97       	sbiw	r24, 0x01	; 1
    2bfc:	f1 f7       	brne	.-4      	; 0x2bfa <main+0xd04>
    2bfe:	fe 01       	movw	r30, r28
    2c00:	ef 58       	subi	r30, 0x8F	; 143
    2c02:	ff 4f       	sbci	r31, 0xFF	; 255
    2c04:	91 83       	std	Z+1, r25	; 0x01
    2c06:	80 83       	st	Z, r24
				_delay_ms(10);
				EEPROM_writeByte(0x0325, confirmation_password[3]);
    2c08:	fe 01       	movw	r30, r28
    2c0a:	eb 52       	subi	r30, 0x2B	; 43
    2c0c:	ff 4f       	sbci	r31, 0xFF	; 255
    2c0e:	23 81       	ldd	r18, Z+3	; 0x03
    2c10:	85 e2       	ldi	r24, 0x25	; 37
    2c12:	93 e0       	ldi	r25, 0x03	; 3
    2c14:	62 2f       	mov	r22, r18
    2c16:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <EEPROM_writeByte>
    2c1a:	fe 01       	movw	r30, r28
    2c1c:	e3 59       	subi	r30, 0x93	; 147
    2c1e:	ff 4f       	sbci	r31, 0xFF	; 255
    2c20:	80 e0       	ldi	r24, 0x00	; 0
    2c22:	90 e0       	ldi	r25, 0x00	; 0
    2c24:	a0 e2       	ldi	r26, 0x20	; 32
    2c26:	b1 e4       	ldi	r27, 0x41	; 65
    2c28:	80 83       	st	Z, r24
    2c2a:	91 83       	std	Z+1, r25	; 0x01
    2c2c:	a2 83       	std	Z+2, r26	; 0x02
    2c2e:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2c30:	8e 01       	movw	r16, r28
    2c32:	07 59       	subi	r16, 0x97	; 151
    2c34:	1f 4f       	sbci	r17, 0xFF	; 255
    2c36:	fe 01       	movw	r30, r28
    2c38:	e3 59       	subi	r30, 0x93	; 147
    2c3a:	ff 4f       	sbci	r31, 0xFF	; 255
    2c3c:	60 81       	ld	r22, Z
    2c3e:	71 81       	ldd	r23, Z+1	; 0x01
    2c40:	82 81       	ldd	r24, Z+2	; 0x02
    2c42:	93 81       	ldd	r25, Z+3	; 0x03
    2c44:	20 e0       	ldi	r18, 0x00	; 0
    2c46:	30 e0       	ldi	r19, 0x00	; 0
    2c48:	4a ef       	ldi	r20, 0xFA	; 250
    2c4a:	54 e4       	ldi	r21, 0x44	; 68
    2c4c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2c50:	dc 01       	movw	r26, r24
    2c52:	cb 01       	movw	r24, r22
    2c54:	f8 01       	movw	r30, r16
    2c56:	80 83       	st	Z, r24
    2c58:	91 83       	std	Z+1, r25	; 0x01
    2c5a:	a2 83       	std	Z+2, r26	; 0x02
    2c5c:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    2c5e:	fe 01       	movw	r30, r28
    2c60:	e7 59       	subi	r30, 0x97	; 151
    2c62:	ff 4f       	sbci	r31, 0xFF	; 255
    2c64:	60 81       	ld	r22, Z
    2c66:	71 81       	ldd	r23, Z+1	; 0x01
    2c68:	82 81       	ldd	r24, Z+2	; 0x02
    2c6a:	93 81       	ldd	r25, Z+3	; 0x03
    2c6c:	20 e0       	ldi	r18, 0x00	; 0
    2c6e:	30 e0       	ldi	r19, 0x00	; 0
    2c70:	40 e8       	ldi	r20, 0x80	; 128
    2c72:	5f e3       	ldi	r21, 0x3F	; 63
    2c74:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2c78:	88 23       	and	r24, r24
    2c7a:	44 f4       	brge	.+16     	; 0x2c8c <main+0xd96>
		__ticks = 1;
    2c7c:	fe 01       	movw	r30, r28
    2c7e:	e9 59       	subi	r30, 0x99	; 153
    2c80:	ff 4f       	sbci	r31, 0xFF	; 255
    2c82:	81 e0       	ldi	r24, 0x01	; 1
    2c84:	90 e0       	ldi	r25, 0x00	; 0
    2c86:	91 83       	std	Z+1, r25	; 0x01
    2c88:	80 83       	st	Z, r24
    2c8a:	64 c0       	rjmp	.+200    	; 0x2d54 <main+0xe5e>
	else if (__tmp > 65535)
    2c8c:	fe 01       	movw	r30, r28
    2c8e:	e7 59       	subi	r30, 0x97	; 151
    2c90:	ff 4f       	sbci	r31, 0xFF	; 255
    2c92:	60 81       	ld	r22, Z
    2c94:	71 81       	ldd	r23, Z+1	; 0x01
    2c96:	82 81       	ldd	r24, Z+2	; 0x02
    2c98:	93 81       	ldd	r25, Z+3	; 0x03
    2c9a:	20 e0       	ldi	r18, 0x00	; 0
    2c9c:	3f ef       	ldi	r19, 0xFF	; 255
    2c9e:	4f e7       	ldi	r20, 0x7F	; 127
    2ca0:	57 e4       	ldi	r21, 0x47	; 71
    2ca2:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2ca6:	18 16       	cp	r1, r24
    2ca8:	0c f0       	brlt	.+2      	; 0x2cac <main+0xdb6>
    2caa:	43 c0       	rjmp	.+134    	; 0x2d32 <main+0xe3c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2cac:	fe 01       	movw	r30, r28
    2cae:	e3 59       	subi	r30, 0x93	; 147
    2cb0:	ff 4f       	sbci	r31, 0xFF	; 255
    2cb2:	60 81       	ld	r22, Z
    2cb4:	71 81       	ldd	r23, Z+1	; 0x01
    2cb6:	82 81       	ldd	r24, Z+2	; 0x02
    2cb8:	93 81       	ldd	r25, Z+3	; 0x03
    2cba:	20 e0       	ldi	r18, 0x00	; 0
    2cbc:	30 e0       	ldi	r19, 0x00	; 0
    2cbe:	40 e2       	ldi	r20, 0x20	; 32
    2cc0:	51 e4       	ldi	r21, 0x41	; 65
    2cc2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2cc6:	dc 01       	movw	r26, r24
    2cc8:	cb 01       	movw	r24, r22
    2cca:	8e 01       	movw	r16, r28
    2ccc:	09 59       	subi	r16, 0x99	; 153
    2cce:	1f 4f       	sbci	r17, 0xFF	; 255
    2cd0:	bc 01       	movw	r22, r24
    2cd2:	cd 01       	movw	r24, r26
    2cd4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2cd8:	dc 01       	movw	r26, r24
    2cda:	cb 01       	movw	r24, r22
    2cdc:	f8 01       	movw	r30, r16
    2cde:	91 83       	std	Z+1, r25	; 0x01
    2ce0:	80 83       	st	Z, r24
    2ce2:	1f c0       	rjmp	.+62     	; 0x2d22 <main+0xe2c>
    2ce4:	fe 01       	movw	r30, r28
    2ce6:	eb 59       	subi	r30, 0x9B	; 155
    2ce8:	ff 4f       	sbci	r31, 0xFF	; 255
    2cea:	88 ec       	ldi	r24, 0xC8	; 200
    2cec:	90 e0       	ldi	r25, 0x00	; 0
    2cee:	91 83       	std	Z+1, r25	; 0x01
    2cf0:	80 83       	st	Z, r24
    2cf2:	fe 01       	movw	r30, r28
    2cf4:	eb 59       	subi	r30, 0x9B	; 155
    2cf6:	ff 4f       	sbci	r31, 0xFF	; 255
    2cf8:	80 81       	ld	r24, Z
    2cfa:	91 81       	ldd	r25, Z+1	; 0x01
    2cfc:	01 97       	sbiw	r24, 0x01	; 1
    2cfe:	f1 f7       	brne	.-4      	; 0x2cfc <main+0xe06>
    2d00:	fe 01       	movw	r30, r28
    2d02:	eb 59       	subi	r30, 0x9B	; 155
    2d04:	ff 4f       	sbci	r31, 0xFF	; 255
    2d06:	91 83       	std	Z+1, r25	; 0x01
    2d08:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2d0a:	de 01       	movw	r26, r28
    2d0c:	a9 59       	subi	r26, 0x99	; 153
    2d0e:	bf 4f       	sbci	r27, 0xFF	; 255
    2d10:	fe 01       	movw	r30, r28
    2d12:	e9 59       	subi	r30, 0x99	; 153
    2d14:	ff 4f       	sbci	r31, 0xFF	; 255
    2d16:	80 81       	ld	r24, Z
    2d18:	91 81       	ldd	r25, Z+1	; 0x01
    2d1a:	01 97       	sbiw	r24, 0x01	; 1
    2d1c:	11 96       	adiw	r26, 0x01	; 1
    2d1e:	9c 93       	st	X, r25
    2d20:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2d22:	fe 01       	movw	r30, r28
    2d24:	e9 59       	subi	r30, 0x99	; 153
    2d26:	ff 4f       	sbci	r31, 0xFF	; 255
    2d28:	80 81       	ld	r24, Z
    2d2a:	91 81       	ldd	r25, Z+1	; 0x01
    2d2c:	00 97       	sbiw	r24, 0x00	; 0
    2d2e:	d1 f6       	brne	.-76     	; 0x2ce4 <main+0xdee>
    2d30:	27 c0       	rjmp	.+78     	; 0x2d80 <main+0xe8a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2d32:	8e 01       	movw	r16, r28
    2d34:	09 59       	subi	r16, 0x99	; 153
    2d36:	1f 4f       	sbci	r17, 0xFF	; 255
    2d38:	fe 01       	movw	r30, r28
    2d3a:	e7 59       	subi	r30, 0x97	; 151
    2d3c:	ff 4f       	sbci	r31, 0xFF	; 255
    2d3e:	60 81       	ld	r22, Z
    2d40:	71 81       	ldd	r23, Z+1	; 0x01
    2d42:	82 81       	ldd	r24, Z+2	; 0x02
    2d44:	93 81       	ldd	r25, Z+3	; 0x03
    2d46:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2d4a:	dc 01       	movw	r26, r24
    2d4c:	cb 01       	movw	r24, r22
    2d4e:	f8 01       	movw	r30, r16
    2d50:	91 83       	std	Z+1, r25	; 0x01
    2d52:	80 83       	st	Z, r24
    2d54:	de 01       	movw	r26, r28
    2d56:	ad 59       	subi	r26, 0x9D	; 157
    2d58:	bf 4f       	sbci	r27, 0xFF	; 255
    2d5a:	fe 01       	movw	r30, r28
    2d5c:	e9 59       	subi	r30, 0x99	; 153
    2d5e:	ff 4f       	sbci	r31, 0xFF	; 255
    2d60:	80 81       	ld	r24, Z
    2d62:	91 81       	ldd	r25, Z+1	; 0x01
    2d64:	8d 93       	st	X+, r24
    2d66:	9c 93       	st	X, r25
    2d68:	fe 01       	movw	r30, r28
    2d6a:	ed 59       	subi	r30, 0x9D	; 157
    2d6c:	ff 4f       	sbci	r31, 0xFF	; 255
    2d6e:	80 81       	ld	r24, Z
    2d70:	91 81       	ldd	r25, Z+1	; 0x01
    2d72:	01 97       	sbiw	r24, 0x01	; 1
    2d74:	f1 f7       	brne	.-4      	; 0x2d72 <main+0xe7c>
    2d76:	fe 01       	movw	r30, r28
    2d78:	ed 59       	subi	r30, 0x9D	; 157
    2d7a:	ff 4f       	sbci	r31, 0xFF	; 255
    2d7c:	91 83       	std	Z+1, r25	; 0x01
    2d7e:	80 83       	st	Z, r24
				_delay_ms(10);
				EEPROM_readByte(0x0325, &confirmation_password[3]);
    2d80:	ce 01       	movw	r24, r28
    2d82:	8b 52       	subi	r24, 0x2B	; 43
    2d84:	9f 4f       	sbci	r25, 0xFF	; 255
    2d86:	9c 01       	movw	r18, r24
    2d88:	2d 5f       	subi	r18, 0xFD	; 253
    2d8a:	3f 4f       	sbci	r19, 0xFF	; 255
    2d8c:	85 e2       	ldi	r24, 0x25	; 37
    2d8e:	93 e0       	ldi	r25, 0x03	; 3
    2d90:	b9 01       	movw	r22, r18
    2d92:	0e 94 65 0e 	call	0x1cca	; 0x1cca <EEPROM_readByte>
    2d96:	fe 01       	movw	r30, r28
    2d98:	e1 5a       	subi	r30, 0xA1	; 161
    2d9a:	ff 4f       	sbci	r31, 0xFF	; 255
    2d9c:	80 e0       	ldi	r24, 0x00	; 0
    2d9e:	90 e0       	ldi	r25, 0x00	; 0
    2da0:	a0 e2       	ldi	r26, 0x20	; 32
    2da2:	b1 e4       	ldi	r27, 0x41	; 65
    2da4:	80 83       	st	Z, r24
    2da6:	91 83       	std	Z+1, r25	; 0x01
    2da8:	a2 83       	std	Z+2, r26	; 0x02
    2daa:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2dac:	8e 01       	movw	r16, r28
    2dae:	05 5a       	subi	r16, 0xA5	; 165
    2db0:	1f 4f       	sbci	r17, 0xFF	; 255
    2db2:	fe 01       	movw	r30, r28
    2db4:	e1 5a       	subi	r30, 0xA1	; 161
    2db6:	ff 4f       	sbci	r31, 0xFF	; 255
    2db8:	60 81       	ld	r22, Z
    2dba:	71 81       	ldd	r23, Z+1	; 0x01
    2dbc:	82 81       	ldd	r24, Z+2	; 0x02
    2dbe:	93 81       	ldd	r25, Z+3	; 0x03
    2dc0:	20 e0       	ldi	r18, 0x00	; 0
    2dc2:	30 e0       	ldi	r19, 0x00	; 0
    2dc4:	4a ef       	ldi	r20, 0xFA	; 250
    2dc6:	54 e4       	ldi	r21, 0x44	; 68
    2dc8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2dcc:	dc 01       	movw	r26, r24
    2dce:	cb 01       	movw	r24, r22
    2dd0:	f8 01       	movw	r30, r16
    2dd2:	80 83       	st	Z, r24
    2dd4:	91 83       	std	Z+1, r25	; 0x01
    2dd6:	a2 83       	std	Z+2, r26	; 0x02
    2dd8:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    2dda:	fe 01       	movw	r30, r28
    2ddc:	e5 5a       	subi	r30, 0xA5	; 165
    2dde:	ff 4f       	sbci	r31, 0xFF	; 255
    2de0:	60 81       	ld	r22, Z
    2de2:	71 81       	ldd	r23, Z+1	; 0x01
    2de4:	82 81       	ldd	r24, Z+2	; 0x02
    2de6:	93 81       	ldd	r25, Z+3	; 0x03
    2de8:	20 e0       	ldi	r18, 0x00	; 0
    2dea:	30 e0       	ldi	r19, 0x00	; 0
    2dec:	40 e8       	ldi	r20, 0x80	; 128
    2dee:	5f e3       	ldi	r21, 0x3F	; 63
    2df0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2df4:	88 23       	and	r24, r24
    2df6:	44 f4       	brge	.+16     	; 0x2e08 <main+0xf12>
		__ticks = 1;
    2df8:	fe 01       	movw	r30, r28
    2dfa:	e7 5a       	subi	r30, 0xA7	; 167
    2dfc:	ff 4f       	sbci	r31, 0xFF	; 255
    2dfe:	81 e0       	ldi	r24, 0x01	; 1
    2e00:	90 e0       	ldi	r25, 0x00	; 0
    2e02:	91 83       	std	Z+1, r25	; 0x01
    2e04:	80 83       	st	Z, r24
    2e06:	64 c0       	rjmp	.+200    	; 0x2ed0 <main+0xfda>
	else if (__tmp > 65535)
    2e08:	fe 01       	movw	r30, r28
    2e0a:	e5 5a       	subi	r30, 0xA5	; 165
    2e0c:	ff 4f       	sbci	r31, 0xFF	; 255
    2e0e:	60 81       	ld	r22, Z
    2e10:	71 81       	ldd	r23, Z+1	; 0x01
    2e12:	82 81       	ldd	r24, Z+2	; 0x02
    2e14:	93 81       	ldd	r25, Z+3	; 0x03
    2e16:	20 e0       	ldi	r18, 0x00	; 0
    2e18:	3f ef       	ldi	r19, 0xFF	; 255
    2e1a:	4f e7       	ldi	r20, 0x7F	; 127
    2e1c:	57 e4       	ldi	r21, 0x47	; 71
    2e1e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2e22:	18 16       	cp	r1, r24
    2e24:	0c f0       	brlt	.+2      	; 0x2e28 <main+0xf32>
    2e26:	43 c0       	rjmp	.+134    	; 0x2eae <main+0xfb8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2e28:	fe 01       	movw	r30, r28
    2e2a:	e1 5a       	subi	r30, 0xA1	; 161
    2e2c:	ff 4f       	sbci	r31, 0xFF	; 255
    2e2e:	60 81       	ld	r22, Z
    2e30:	71 81       	ldd	r23, Z+1	; 0x01
    2e32:	82 81       	ldd	r24, Z+2	; 0x02
    2e34:	93 81       	ldd	r25, Z+3	; 0x03
    2e36:	20 e0       	ldi	r18, 0x00	; 0
    2e38:	30 e0       	ldi	r19, 0x00	; 0
    2e3a:	40 e2       	ldi	r20, 0x20	; 32
    2e3c:	51 e4       	ldi	r21, 0x41	; 65
    2e3e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2e42:	dc 01       	movw	r26, r24
    2e44:	cb 01       	movw	r24, r22
    2e46:	8e 01       	movw	r16, r28
    2e48:	07 5a       	subi	r16, 0xA7	; 167
    2e4a:	1f 4f       	sbci	r17, 0xFF	; 255
    2e4c:	bc 01       	movw	r22, r24
    2e4e:	cd 01       	movw	r24, r26
    2e50:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2e54:	dc 01       	movw	r26, r24
    2e56:	cb 01       	movw	r24, r22
    2e58:	f8 01       	movw	r30, r16
    2e5a:	91 83       	std	Z+1, r25	; 0x01
    2e5c:	80 83       	st	Z, r24
    2e5e:	1f c0       	rjmp	.+62     	; 0x2e9e <main+0xfa8>
    2e60:	fe 01       	movw	r30, r28
    2e62:	e9 5a       	subi	r30, 0xA9	; 169
    2e64:	ff 4f       	sbci	r31, 0xFF	; 255
    2e66:	88 ec       	ldi	r24, 0xC8	; 200
    2e68:	90 e0       	ldi	r25, 0x00	; 0
    2e6a:	91 83       	std	Z+1, r25	; 0x01
    2e6c:	80 83       	st	Z, r24
    2e6e:	fe 01       	movw	r30, r28
    2e70:	e9 5a       	subi	r30, 0xA9	; 169
    2e72:	ff 4f       	sbci	r31, 0xFF	; 255
    2e74:	80 81       	ld	r24, Z
    2e76:	91 81       	ldd	r25, Z+1	; 0x01
    2e78:	01 97       	sbiw	r24, 0x01	; 1
    2e7a:	f1 f7       	brne	.-4      	; 0x2e78 <main+0xf82>
    2e7c:	fe 01       	movw	r30, r28
    2e7e:	e9 5a       	subi	r30, 0xA9	; 169
    2e80:	ff 4f       	sbci	r31, 0xFF	; 255
    2e82:	91 83       	std	Z+1, r25	; 0x01
    2e84:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2e86:	de 01       	movw	r26, r28
    2e88:	a7 5a       	subi	r26, 0xA7	; 167
    2e8a:	bf 4f       	sbci	r27, 0xFF	; 255
    2e8c:	fe 01       	movw	r30, r28
    2e8e:	e7 5a       	subi	r30, 0xA7	; 167
    2e90:	ff 4f       	sbci	r31, 0xFF	; 255
    2e92:	80 81       	ld	r24, Z
    2e94:	91 81       	ldd	r25, Z+1	; 0x01
    2e96:	01 97       	sbiw	r24, 0x01	; 1
    2e98:	11 96       	adiw	r26, 0x01	; 1
    2e9a:	9c 93       	st	X, r25
    2e9c:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2e9e:	fe 01       	movw	r30, r28
    2ea0:	e7 5a       	subi	r30, 0xA7	; 167
    2ea2:	ff 4f       	sbci	r31, 0xFF	; 255
    2ea4:	80 81       	ld	r24, Z
    2ea6:	91 81       	ldd	r25, Z+1	; 0x01
    2ea8:	00 97       	sbiw	r24, 0x00	; 0
    2eaa:	d1 f6       	brne	.-76     	; 0x2e60 <main+0xf6a>
    2eac:	27 c0       	rjmp	.+78     	; 0x2efc <main+0x1006>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2eae:	8e 01       	movw	r16, r28
    2eb0:	07 5a       	subi	r16, 0xA7	; 167
    2eb2:	1f 4f       	sbci	r17, 0xFF	; 255
    2eb4:	fe 01       	movw	r30, r28
    2eb6:	e5 5a       	subi	r30, 0xA5	; 165
    2eb8:	ff 4f       	sbci	r31, 0xFF	; 255
    2eba:	60 81       	ld	r22, Z
    2ebc:	71 81       	ldd	r23, Z+1	; 0x01
    2ebe:	82 81       	ldd	r24, Z+2	; 0x02
    2ec0:	93 81       	ldd	r25, Z+3	; 0x03
    2ec2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2ec6:	dc 01       	movw	r26, r24
    2ec8:	cb 01       	movw	r24, r22
    2eca:	f8 01       	movw	r30, r16
    2ecc:	91 83       	std	Z+1, r25	; 0x01
    2ece:	80 83       	st	Z, r24
    2ed0:	de 01       	movw	r26, r28
    2ed2:	ab 5a       	subi	r26, 0xAB	; 171
    2ed4:	bf 4f       	sbci	r27, 0xFF	; 255
    2ed6:	fe 01       	movw	r30, r28
    2ed8:	e7 5a       	subi	r30, 0xA7	; 167
    2eda:	ff 4f       	sbci	r31, 0xFF	; 255
    2edc:	80 81       	ld	r24, Z
    2ede:	91 81       	ldd	r25, Z+1	; 0x01
    2ee0:	8d 93       	st	X+, r24
    2ee2:	9c 93       	st	X, r25
    2ee4:	fe 01       	movw	r30, r28
    2ee6:	eb 5a       	subi	r30, 0xAB	; 171
    2ee8:	ff 4f       	sbci	r31, 0xFF	; 255
    2eea:	80 81       	ld	r24, Z
    2eec:	91 81       	ldd	r25, Z+1	; 0x01
    2eee:	01 97       	sbiw	r24, 0x01	; 1
    2ef0:	f1 f7       	brne	.-4      	; 0x2eee <main+0xff8>
    2ef2:	fe 01       	movw	r30, r28
    2ef4:	eb 5a       	subi	r30, 0xAB	; 171
    2ef6:	ff 4f       	sbci	r31, 0xFF	; 255
    2ef8:	91 83       	std	Z+1, r25	; 0x01
    2efa:	80 83       	st	Z, r24
				_delay_ms(10);
				EEPROM_writeByte(0x0330, confirmation_password[4]);
    2efc:	fe 01       	movw	r30, r28
    2efe:	eb 52       	subi	r30, 0x2B	; 43
    2f00:	ff 4f       	sbci	r31, 0xFF	; 255
    2f02:	24 81       	ldd	r18, Z+4	; 0x04
    2f04:	80 e3       	ldi	r24, 0x30	; 48
    2f06:	93 e0       	ldi	r25, 0x03	; 3
    2f08:	62 2f       	mov	r22, r18
    2f0a:	0e 94 24 0e 	call	0x1c48	; 0x1c48 <EEPROM_writeByte>
    2f0e:	fe 01       	movw	r30, r28
    2f10:	ef 5a       	subi	r30, 0xAF	; 175
    2f12:	ff 4f       	sbci	r31, 0xFF	; 255
    2f14:	80 e0       	ldi	r24, 0x00	; 0
    2f16:	90 e0       	ldi	r25, 0x00	; 0
    2f18:	a0 e2       	ldi	r26, 0x20	; 32
    2f1a:	b1 e4       	ldi	r27, 0x41	; 65
    2f1c:	80 83       	st	Z, r24
    2f1e:	91 83       	std	Z+1, r25	; 0x01
    2f20:	a2 83       	std	Z+2, r26	; 0x02
    2f22:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2f24:	8e 01       	movw	r16, r28
    2f26:	03 5b       	subi	r16, 0xB3	; 179
    2f28:	1f 4f       	sbci	r17, 0xFF	; 255
    2f2a:	fe 01       	movw	r30, r28
    2f2c:	ef 5a       	subi	r30, 0xAF	; 175
    2f2e:	ff 4f       	sbci	r31, 0xFF	; 255
    2f30:	60 81       	ld	r22, Z
    2f32:	71 81       	ldd	r23, Z+1	; 0x01
    2f34:	82 81       	ldd	r24, Z+2	; 0x02
    2f36:	93 81       	ldd	r25, Z+3	; 0x03
    2f38:	20 e0       	ldi	r18, 0x00	; 0
    2f3a:	30 e0       	ldi	r19, 0x00	; 0
    2f3c:	4a ef       	ldi	r20, 0xFA	; 250
    2f3e:	54 e4       	ldi	r21, 0x44	; 68
    2f40:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2f44:	dc 01       	movw	r26, r24
    2f46:	cb 01       	movw	r24, r22
    2f48:	f8 01       	movw	r30, r16
    2f4a:	80 83       	st	Z, r24
    2f4c:	91 83       	std	Z+1, r25	; 0x01
    2f4e:	a2 83       	std	Z+2, r26	; 0x02
    2f50:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    2f52:	fe 01       	movw	r30, r28
    2f54:	e3 5b       	subi	r30, 0xB3	; 179
    2f56:	ff 4f       	sbci	r31, 0xFF	; 255
    2f58:	60 81       	ld	r22, Z
    2f5a:	71 81       	ldd	r23, Z+1	; 0x01
    2f5c:	82 81       	ldd	r24, Z+2	; 0x02
    2f5e:	93 81       	ldd	r25, Z+3	; 0x03
    2f60:	20 e0       	ldi	r18, 0x00	; 0
    2f62:	30 e0       	ldi	r19, 0x00	; 0
    2f64:	40 e8       	ldi	r20, 0x80	; 128
    2f66:	5f e3       	ldi	r21, 0x3F	; 63
    2f68:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2f6c:	88 23       	and	r24, r24
    2f6e:	44 f4       	brge	.+16     	; 0x2f80 <main+0x108a>
		__ticks = 1;
    2f70:	fe 01       	movw	r30, r28
    2f72:	e5 5b       	subi	r30, 0xB5	; 181
    2f74:	ff 4f       	sbci	r31, 0xFF	; 255
    2f76:	81 e0       	ldi	r24, 0x01	; 1
    2f78:	90 e0       	ldi	r25, 0x00	; 0
    2f7a:	91 83       	std	Z+1, r25	; 0x01
    2f7c:	80 83       	st	Z, r24
    2f7e:	64 c0       	rjmp	.+200    	; 0x3048 <main+0x1152>
	else if (__tmp > 65535)
    2f80:	fe 01       	movw	r30, r28
    2f82:	e3 5b       	subi	r30, 0xB3	; 179
    2f84:	ff 4f       	sbci	r31, 0xFF	; 255
    2f86:	60 81       	ld	r22, Z
    2f88:	71 81       	ldd	r23, Z+1	; 0x01
    2f8a:	82 81       	ldd	r24, Z+2	; 0x02
    2f8c:	93 81       	ldd	r25, Z+3	; 0x03
    2f8e:	20 e0       	ldi	r18, 0x00	; 0
    2f90:	3f ef       	ldi	r19, 0xFF	; 255
    2f92:	4f e7       	ldi	r20, 0x7F	; 127
    2f94:	57 e4       	ldi	r21, 0x47	; 71
    2f96:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2f9a:	18 16       	cp	r1, r24
    2f9c:	0c f0       	brlt	.+2      	; 0x2fa0 <main+0x10aa>
    2f9e:	43 c0       	rjmp	.+134    	; 0x3026 <main+0x1130>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2fa0:	fe 01       	movw	r30, r28
    2fa2:	ef 5a       	subi	r30, 0xAF	; 175
    2fa4:	ff 4f       	sbci	r31, 0xFF	; 255
    2fa6:	60 81       	ld	r22, Z
    2fa8:	71 81       	ldd	r23, Z+1	; 0x01
    2faa:	82 81       	ldd	r24, Z+2	; 0x02
    2fac:	93 81       	ldd	r25, Z+3	; 0x03
    2fae:	20 e0       	ldi	r18, 0x00	; 0
    2fb0:	30 e0       	ldi	r19, 0x00	; 0
    2fb2:	40 e2       	ldi	r20, 0x20	; 32
    2fb4:	51 e4       	ldi	r21, 0x41	; 65
    2fb6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2fba:	dc 01       	movw	r26, r24
    2fbc:	cb 01       	movw	r24, r22
    2fbe:	8e 01       	movw	r16, r28
    2fc0:	05 5b       	subi	r16, 0xB5	; 181
    2fc2:	1f 4f       	sbci	r17, 0xFF	; 255
    2fc4:	bc 01       	movw	r22, r24
    2fc6:	cd 01       	movw	r24, r26
    2fc8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2fcc:	dc 01       	movw	r26, r24
    2fce:	cb 01       	movw	r24, r22
    2fd0:	f8 01       	movw	r30, r16
    2fd2:	91 83       	std	Z+1, r25	; 0x01
    2fd4:	80 83       	st	Z, r24
    2fd6:	1f c0       	rjmp	.+62     	; 0x3016 <main+0x1120>
    2fd8:	fe 01       	movw	r30, r28
    2fda:	e7 5b       	subi	r30, 0xB7	; 183
    2fdc:	ff 4f       	sbci	r31, 0xFF	; 255
    2fde:	88 ec       	ldi	r24, 0xC8	; 200
    2fe0:	90 e0       	ldi	r25, 0x00	; 0
    2fe2:	91 83       	std	Z+1, r25	; 0x01
    2fe4:	80 83       	st	Z, r24
    2fe6:	fe 01       	movw	r30, r28
    2fe8:	e7 5b       	subi	r30, 0xB7	; 183
    2fea:	ff 4f       	sbci	r31, 0xFF	; 255
    2fec:	80 81       	ld	r24, Z
    2fee:	91 81       	ldd	r25, Z+1	; 0x01
    2ff0:	01 97       	sbiw	r24, 0x01	; 1
    2ff2:	f1 f7       	brne	.-4      	; 0x2ff0 <main+0x10fa>
    2ff4:	fe 01       	movw	r30, r28
    2ff6:	e7 5b       	subi	r30, 0xB7	; 183
    2ff8:	ff 4f       	sbci	r31, 0xFF	; 255
    2ffa:	91 83       	std	Z+1, r25	; 0x01
    2ffc:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2ffe:	de 01       	movw	r26, r28
    3000:	a5 5b       	subi	r26, 0xB5	; 181
    3002:	bf 4f       	sbci	r27, 0xFF	; 255
    3004:	fe 01       	movw	r30, r28
    3006:	e5 5b       	subi	r30, 0xB5	; 181
    3008:	ff 4f       	sbci	r31, 0xFF	; 255
    300a:	80 81       	ld	r24, Z
    300c:	91 81       	ldd	r25, Z+1	; 0x01
    300e:	01 97       	sbiw	r24, 0x01	; 1
    3010:	11 96       	adiw	r26, 0x01	; 1
    3012:	9c 93       	st	X, r25
    3014:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3016:	fe 01       	movw	r30, r28
    3018:	e5 5b       	subi	r30, 0xB5	; 181
    301a:	ff 4f       	sbci	r31, 0xFF	; 255
    301c:	80 81       	ld	r24, Z
    301e:	91 81       	ldd	r25, Z+1	; 0x01
    3020:	00 97       	sbiw	r24, 0x00	; 0
    3022:	d1 f6       	brne	.-76     	; 0x2fd8 <main+0x10e2>
    3024:	27 c0       	rjmp	.+78     	; 0x3074 <main+0x117e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3026:	8e 01       	movw	r16, r28
    3028:	05 5b       	subi	r16, 0xB5	; 181
    302a:	1f 4f       	sbci	r17, 0xFF	; 255
    302c:	fe 01       	movw	r30, r28
    302e:	e3 5b       	subi	r30, 0xB3	; 179
    3030:	ff 4f       	sbci	r31, 0xFF	; 255
    3032:	60 81       	ld	r22, Z
    3034:	71 81       	ldd	r23, Z+1	; 0x01
    3036:	82 81       	ldd	r24, Z+2	; 0x02
    3038:	93 81       	ldd	r25, Z+3	; 0x03
    303a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    303e:	dc 01       	movw	r26, r24
    3040:	cb 01       	movw	r24, r22
    3042:	f8 01       	movw	r30, r16
    3044:	91 83       	std	Z+1, r25	; 0x01
    3046:	80 83       	st	Z, r24
    3048:	de 01       	movw	r26, r28
    304a:	a9 5b       	subi	r26, 0xB9	; 185
    304c:	bf 4f       	sbci	r27, 0xFF	; 255
    304e:	fe 01       	movw	r30, r28
    3050:	e5 5b       	subi	r30, 0xB5	; 181
    3052:	ff 4f       	sbci	r31, 0xFF	; 255
    3054:	80 81       	ld	r24, Z
    3056:	91 81       	ldd	r25, Z+1	; 0x01
    3058:	8d 93       	st	X+, r24
    305a:	9c 93       	st	X, r25
    305c:	fe 01       	movw	r30, r28
    305e:	e9 5b       	subi	r30, 0xB9	; 185
    3060:	ff 4f       	sbci	r31, 0xFF	; 255
    3062:	80 81       	ld	r24, Z
    3064:	91 81       	ldd	r25, Z+1	; 0x01
    3066:	01 97       	sbiw	r24, 0x01	; 1
    3068:	f1 f7       	brne	.-4      	; 0x3066 <main+0x1170>
    306a:	fe 01       	movw	r30, r28
    306c:	e9 5b       	subi	r30, 0xB9	; 185
    306e:	ff 4f       	sbci	r31, 0xFF	; 255
    3070:	91 83       	std	Z+1, r25	; 0x01
    3072:	80 83       	st	Z, r24
				_delay_ms(10);
				EEPROM_readByte(0x0330, &confirmation_password[4]);
    3074:	ce 01       	movw	r24, r28
    3076:	8b 52       	subi	r24, 0x2B	; 43
    3078:	9f 4f       	sbci	r25, 0xFF	; 255
    307a:	9c 01       	movw	r18, r24
    307c:	2c 5f       	subi	r18, 0xFC	; 252
    307e:	3f 4f       	sbci	r19, 0xFF	; 255
    3080:	80 e3       	ldi	r24, 0x30	; 48
    3082:	93 e0       	ldi	r25, 0x03	; 3
    3084:	b9 01       	movw	r22, r18
    3086:	0e 94 65 0e 	call	0x1cca	; 0x1cca <EEPROM_readByte>
    308a:	fe 01       	movw	r30, r28
    308c:	ed 5b       	subi	r30, 0xBD	; 189
    308e:	ff 4f       	sbci	r31, 0xFF	; 255
    3090:	80 e0       	ldi	r24, 0x00	; 0
    3092:	90 e0       	ldi	r25, 0x00	; 0
    3094:	a0 e2       	ldi	r26, 0x20	; 32
    3096:	b1 e4       	ldi	r27, 0x41	; 65
    3098:	80 83       	st	Z, r24
    309a:	91 83       	std	Z+1, r25	; 0x01
    309c:	a2 83       	std	Z+2, r26	; 0x02
    309e:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    30a0:	8e 01       	movw	r16, r28
    30a2:	01 5c       	subi	r16, 0xC1	; 193
    30a4:	1f 4f       	sbci	r17, 0xFF	; 255
    30a6:	fe 01       	movw	r30, r28
    30a8:	ed 5b       	subi	r30, 0xBD	; 189
    30aa:	ff 4f       	sbci	r31, 0xFF	; 255
    30ac:	60 81       	ld	r22, Z
    30ae:	71 81       	ldd	r23, Z+1	; 0x01
    30b0:	82 81       	ldd	r24, Z+2	; 0x02
    30b2:	93 81       	ldd	r25, Z+3	; 0x03
    30b4:	20 e0       	ldi	r18, 0x00	; 0
    30b6:	30 e0       	ldi	r19, 0x00	; 0
    30b8:	4a ef       	ldi	r20, 0xFA	; 250
    30ba:	54 e4       	ldi	r21, 0x44	; 68
    30bc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    30c0:	dc 01       	movw	r26, r24
    30c2:	cb 01       	movw	r24, r22
    30c4:	f8 01       	movw	r30, r16
    30c6:	80 83       	st	Z, r24
    30c8:	91 83       	std	Z+1, r25	; 0x01
    30ca:	a2 83       	std	Z+2, r26	; 0x02
    30cc:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    30ce:	fe 01       	movw	r30, r28
    30d0:	ff 96       	adiw	r30, 0x3f	; 63
    30d2:	60 81       	ld	r22, Z
    30d4:	71 81       	ldd	r23, Z+1	; 0x01
    30d6:	82 81       	ldd	r24, Z+2	; 0x02
    30d8:	93 81       	ldd	r25, Z+3	; 0x03
    30da:	20 e0       	ldi	r18, 0x00	; 0
    30dc:	30 e0       	ldi	r19, 0x00	; 0
    30de:	40 e8       	ldi	r20, 0x80	; 128
    30e0:	5f e3       	ldi	r21, 0x3F	; 63
    30e2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    30e6:	88 23       	and	r24, r24
    30e8:	2c f4       	brge	.+10     	; 0x30f4 <main+0x11fe>
		__ticks = 1;
    30ea:	81 e0       	ldi	r24, 0x01	; 1
    30ec:	90 e0       	ldi	r25, 0x00	; 0
    30ee:	9e af       	std	Y+62, r25	; 0x3e
    30f0:	8d af       	std	Y+61, r24	; 0x3d
    30f2:	46 c0       	rjmp	.+140    	; 0x3180 <main+0x128a>
	else if (__tmp > 65535)
    30f4:	fe 01       	movw	r30, r28
    30f6:	ff 96       	adiw	r30, 0x3f	; 63
    30f8:	60 81       	ld	r22, Z
    30fa:	71 81       	ldd	r23, Z+1	; 0x01
    30fc:	82 81       	ldd	r24, Z+2	; 0x02
    30fe:	93 81       	ldd	r25, Z+3	; 0x03
    3100:	20 e0       	ldi	r18, 0x00	; 0
    3102:	3f ef       	ldi	r19, 0xFF	; 255
    3104:	4f e7       	ldi	r20, 0x7F	; 127
    3106:	57 e4       	ldi	r21, 0x47	; 71
    3108:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    310c:	18 16       	cp	r1, r24
    310e:	64 f5       	brge	.+88     	; 0x3168 <main+0x1272>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3110:	fe 01       	movw	r30, r28
    3112:	ed 5b       	subi	r30, 0xBD	; 189
    3114:	ff 4f       	sbci	r31, 0xFF	; 255
    3116:	60 81       	ld	r22, Z
    3118:	71 81       	ldd	r23, Z+1	; 0x01
    311a:	82 81       	ldd	r24, Z+2	; 0x02
    311c:	93 81       	ldd	r25, Z+3	; 0x03
    311e:	20 e0       	ldi	r18, 0x00	; 0
    3120:	30 e0       	ldi	r19, 0x00	; 0
    3122:	40 e2       	ldi	r20, 0x20	; 32
    3124:	51 e4       	ldi	r21, 0x41	; 65
    3126:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    312a:	dc 01       	movw	r26, r24
    312c:	cb 01       	movw	r24, r22
    312e:	bc 01       	movw	r22, r24
    3130:	cd 01       	movw	r24, r26
    3132:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3136:	dc 01       	movw	r26, r24
    3138:	cb 01       	movw	r24, r22
    313a:	9e af       	std	Y+62, r25	; 0x3e
    313c:	8d af       	std	Y+61, r24	; 0x3d
    313e:	0f c0       	rjmp	.+30     	; 0x315e <main+0x1268>
    3140:	88 ec       	ldi	r24, 0xC8	; 200
    3142:	90 e0       	ldi	r25, 0x00	; 0
    3144:	9c af       	std	Y+60, r25	; 0x3c
    3146:	8b af       	std	Y+59, r24	; 0x3b
    3148:	8b ad       	ldd	r24, Y+59	; 0x3b
    314a:	9c ad       	ldd	r25, Y+60	; 0x3c
    314c:	01 97       	sbiw	r24, 0x01	; 1
    314e:	f1 f7       	brne	.-4      	; 0x314c <main+0x1256>
    3150:	9c af       	std	Y+60, r25	; 0x3c
    3152:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3154:	8d ad       	ldd	r24, Y+61	; 0x3d
    3156:	9e ad       	ldd	r25, Y+62	; 0x3e
    3158:	01 97       	sbiw	r24, 0x01	; 1
    315a:	9e af       	std	Y+62, r25	; 0x3e
    315c:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    315e:	8d ad       	ldd	r24, Y+61	; 0x3d
    3160:	9e ad       	ldd	r25, Y+62	; 0x3e
    3162:	00 97       	sbiw	r24, 0x00	; 0
    3164:	69 f7       	brne	.-38     	; 0x3140 <main+0x124a>
    3166:	63 c0       	rjmp	.+198    	; 0x322e <main+0x1338>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3168:	fe 01       	movw	r30, r28
    316a:	ff 96       	adiw	r30, 0x3f	; 63
    316c:	60 81       	ld	r22, Z
    316e:	71 81       	ldd	r23, Z+1	; 0x01
    3170:	82 81       	ldd	r24, Z+2	; 0x02
    3172:	93 81       	ldd	r25, Z+3	; 0x03
    3174:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3178:	dc 01       	movw	r26, r24
    317a:	cb 01       	movw	r24, r22
    317c:	9e af       	std	Y+62, r25	; 0x3e
    317e:	8d af       	std	Y+61, r24	; 0x3d
    3180:	8d ad       	ldd	r24, Y+61	; 0x3d
    3182:	9e ad       	ldd	r25, Y+62	; 0x3e
    3184:	9a af       	std	Y+58, r25	; 0x3a
    3186:	89 af       	std	Y+57, r24	; 0x39
    3188:	89 ad       	ldd	r24, Y+57	; 0x39
    318a:	9a ad       	ldd	r25, Y+58	; 0x3a
    318c:	01 97       	sbiw	r24, 0x01	; 1
    318e:	f1 f7       	brne	.-4      	; 0x318c <main+0x1296>
    3190:	9a af       	std	Y+58, r25	; 0x3a
    3192:	89 af       	std	Y+57, r24	; 0x39
    3194:	4c c0       	rjmp	.+152    	; 0x322e <main+0x1338>
				_delay_ms(10);
				break;
			} else {
				UART_sendByte(UART_PASS_MISMATCH);
    3196:	8f e0       	ldi	r24, 0x0F	; 15
    3198:	0e 94 ab 07 	call	0xf56	; 0xf56 <UART_sendByte>
				state = CREATE_PASS;/*a Pass Mismatch and go to state 1*/
    319c:	fe 01       	movw	r30, r28
    319e:	e2 53       	subi	r30, 0x32	; 50
    31a0:	ff 4f       	sbci	r31, 0xFF	; 255
    31a2:	10 82       	st	Z, r1
    31a4:	44 c0       	rjmp	.+136    	; 0x322e <main+0x1338>
		}
		/*******************************************************************************
		 *                                    MAIN_State                               *
		 *******************************************************************************/
		while (state == MAIN) {
			uint8 local_state2 = 0;/*to receive uart state */
    31a6:	fe 01       	movw	r30, r28
    31a8:	e7 53       	subi	r30, 0x37	; 55
    31aa:	ff 4f       	sbci	r31, 0xFF	; 255
    31ac:	10 82       	st	Z, r1
			uint8 local_state = UART_recieveByte();/*to receive uart state */
    31ae:	0e 94 bf 07 	call	0xf7e	; 0xf7e <UART_recieveByte>
    31b2:	fe 01       	movw	r30, r28
    31b4:	e8 53       	subi	r30, 0x38	; 56
    31b6:	ff 4f       	sbci	r31, 0xFF	; 255
    31b8:	80 83       	st	Z, r24
			g_try = 0;/*to recount try when enter wrong pass for 3 times*/
    31ba:	10 92 81 01 	sts	0x0181, r1
			if (local_state == UART_MAIN_READY) {
    31be:	fe 01       	movw	r30, r28
    31c0:	e8 53       	subi	r30, 0x38	; 56
    31c2:	ff 4f       	sbci	r31, 0xFF	; 255
    31c4:	80 81       	ld	r24, Z
    31c6:	84 31       	cpi	r24, 0x14	; 20
    31c8:	91 f5       	brne	.+100    	; 0x322e <main+0x1338>
				UART_sendByte(UART_MAIN_YES_READY);
    31ca:	85 e1       	ldi	r24, 0x15	; 21
    31cc:	0e 94 ab 07 	call	0xf56	; 0xf56 <UART_sendByte>
				local_state2 = UART_recieveByte();
    31d0:	0e 94 bf 07 	call	0xf7e	; 0xf7e <UART_recieveByte>
    31d4:	fe 01       	movw	r30, r28
    31d6:	e7 53       	subi	r30, 0x37	; 55
    31d8:	ff 4f       	sbci	r31, 0xFF	; 255
    31da:	80 83       	st	Z, r24
				if (local_state2 == UART_MOTOR_READY) {
    31dc:	fe 01       	movw	r30, r28
    31de:	e7 53       	subi	r30, 0x37	; 55
    31e0:	ff 4f       	sbci	r31, 0xFF	; 255
    31e2:	80 81       	ld	r24, Z
    31e4:	80 31       	cpi	r24, 0x10	; 16
    31e6:	61 f4       	brne	.+24     	; 0x3200 <main+0x130a>
					UART_sendByte(UART_MOTOR_YES_READY);
    31e8:	81 e1       	ldi	r24, 0x11	; 17
    31ea:	0e 94 ab 07 	call	0xf56	; 0xf56 <UART_sendByte>
					/*to save a opration and back to it after checking pass*/
					g_main = MOTOR_STATE;
    31ee:	83 e0       	ldi	r24, 0x03	; 3
    31f0:	80 93 82 01 	sts	0x0182, r24
					/*go to checking pass*/
					state = CHECK_PASS;
    31f4:	fe 01       	movw	r30, r28
    31f6:	e2 53       	subi	r30, 0x32	; 50
    31f8:	ff 4f       	sbci	r31, 0xFF	; 255
    31fa:	82 e0       	ldi	r24, 0x02	; 2
    31fc:	80 83       	st	Z, r24
    31fe:	55 c0       	rjmp	.+170    	; 0x32aa <main+0x13b4>

					break;
				} else if (local_state2 == UART_CHECK_PASS_READY) {
    3200:	fe 01       	movw	r30, r28
    3202:	e7 53       	subi	r30, 0x37	; 55
    3204:	ff 4f       	sbci	r31, 0xFF	; 255
    3206:	80 81       	ld	r24, Z
    3208:	8e 31       	cpi	r24, 0x1E	; 30
    320a:	61 f4       	brne	.+24     	; 0x3224 <main+0x132e>
					UART_sendByte(UART_CHECK_PASS_YES_READY);
    320c:	8f e1       	ldi	r24, 0x1F	; 31
    320e:	0e 94 ab 07 	call	0xf56	; 0xf56 <UART_sendByte>
					/*to save a opration and back to it after checking pass*/
					g_main = CHANGE_PASS;
    3212:	84 e0       	ldi	r24, 0x04	; 4
    3214:	80 93 82 01 	sts	0x0182, r24
					/*go to checking pass*/
					state = CHECK_PASS;
    3218:	fe 01       	movw	r30, r28
    321a:	e2 53       	subi	r30, 0x32	; 50
    321c:	ff 4f       	sbci	r31, 0xFF	; 255
    321e:	82 e0       	ldi	r24, 0x02	; 2
    3220:	80 83       	st	Z, r24
    3222:	43 c0       	rjmp	.+134    	; 0x32aa <main+0x13b4>

					break;
				} else {
					state = MAIN;/*a problem occurred and go to state 1*/
    3224:	fe 01       	movw	r30, r28
    3226:	e2 53       	subi	r30, 0x32	; 50
    3228:	ff 4f       	sbci	r31, 0xFF	; 255
    322a:	85 e0       	ldi	r24, 0x05	; 5
    322c:	80 83       	st	Z, r24
			}
		}
		/*******************************************************************************
		 *                                    MAIN_State                               *
		 *******************************************************************************/
		while (state == MAIN) {
    322e:	fe 01       	movw	r30, r28
    3230:	e2 53       	subi	r30, 0x32	; 50
    3232:	ff 4f       	sbci	r31, 0xFF	; 255
    3234:	80 81       	ld	r24, Z
    3236:	85 30       	cpi	r24, 0x05	; 5
    3238:	09 f4       	brne	.+2      	; 0x323c <main+0x1346>
    323a:	b5 cf       	rjmp	.-150    	; 0x31a6 <main+0x12b0>
    323c:	36 c0       	rjmp	.+108    	; 0x32aa <main+0x13b4>
		}
		/*******************************************************************************
		 *                                    MOTOR_STATE                              *
		 *******************************************************************************/
		while (state == MOTOR_STATE) {
			uint8 local_state = UART_recieveByte();/*to receive uart state */
    323e:	0e 94 bf 07 	call	0xf7e	; 0xf7e <UART_recieveByte>
    3242:	fe 01       	movw	r30, r28
    3244:	e9 53       	subi	r30, 0x39	; 57
    3246:	ff 4f       	sbci	r31, 0xFF	; 255
    3248:	80 83       	st	Z, r24
			if (local_state == UART_MOTOR_READY) {
    324a:	fe 01       	movw	r30, r28
    324c:	e9 53       	subi	r30, 0x39	; 57
    324e:	ff 4f       	sbci	r31, 0xFF	; 255
    3250:	80 81       	ld	r24, Z
    3252:	80 31       	cpi	r24, 0x10	; 16
    3254:	29 f5       	brne	.+74     	; 0x32a0 <main+0x13aa>
				UART_sendByte(UART_MOTOR_YES_READY);
    3256:	81 e1       	ldi	r24, 0x11	; 17
    3258:	0e 94 ab 07 	call	0xf56	; 0xf56 <UART_sendByte>
				DcMotor_Rotate(CW, 100);
    325c:	81 e0       	ldi	r24, 0x01	; 1
    325e:	64 e6       	ldi	r22, 0x64	; 100
    3260:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DcMotor_Rotate>
				/*rotates motor for 15-seconds CW*/
				Delay_By_Uing_Timer1_Using_interput(15);
    3264:	8f e0       	ldi	r24, 0x0F	; 15
    3266:	90 e0       	ldi	r25, 0x00	; 0
    3268:	0e 94 5f 1c 	call	0x38be	; 0x38be <Delay_By_Uing_Timer1_Using_interput>
				DcMotor_Rotate(off, 0);
    326c:	80 e0       	ldi	r24, 0x00	; 0
    326e:	60 e0       	ldi	r22, 0x00	; 0
    3270:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DcMotor_Rotate>
				/*hold the motor for 3-seconds.*/
				Delay_By_Uing_Timer1_Using_interput(3);
    3274:	83 e0       	ldi	r24, 0x03	; 3
    3276:	90 e0       	ldi	r25, 0x00	; 0
    3278:	0e 94 5f 1c 	call	0x38be	; 0x38be <Delay_By_Uing_Timer1_Using_interput>
				DcMotor_Rotate(A_CW, 100);
    327c:	82 e0       	ldi	r24, 0x02	; 2
    327e:	64 e6       	ldi	r22, 0x64	; 100
    3280:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DcMotor_Rotate>
				/*rotates motor for 15-seconds A-CW*/
				Delay_By_Uing_Timer1_Using_interput(15);
    3284:	8f e0       	ldi	r24, 0x0F	; 15
    3286:	90 e0       	ldi	r25, 0x00	; 0
    3288:	0e 94 5f 1c 	call	0x38be	; 0x38be <Delay_By_Uing_Timer1_Using_interput>
				DcMotor_Rotate(off, 0);
    328c:	80 e0       	ldi	r24, 0x00	; 0
    328e:	60 e0       	ldi	r22, 0x00	; 0
    3290:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DcMotor_Rotate>
				state = MAIN;/*back to main func*/
    3294:	fe 01       	movw	r30, r28
    3296:	e2 53       	subi	r30, 0x32	; 50
    3298:	ff 4f       	sbci	r31, 0xFF	; 255
    329a:	85 e0       	ldi	r24, 0x05	; 5
    329c:	80 83       	st	Z, r24
    329e:	d9 c2       	rjmp	.+1458   	; 0x3852 <main+0x195c>
				break;
			} else {
				state = MOTOR_STATE;
    32a0:	fe 01       	movw	r30, r28
    32a2:	e2 53       	subi	r30, 0x32	; 50
    32a4:	ff 4f       	sbci	r31, 0xFF	; 255
    32a6:	83 e0       	ldi	r24, 0x03	; 3
    32a8:	80 83       	st	Z, r24
			}
		}
		/*******************************************************************************
		 *                                    MOTOR_STATE                              *
		 *******************************************************************************/
		while (state == MOTOR_STATE) {
    32aa:	fe 01       	movw	r30, r28
    32ac:	e2 53       	subi	r30, 0x32	; 50
    32ae:	ff 4f       	sbci	r31, 0xFF	; 255
    32b0:	80 81       	ld	r24, Z
    32b2:	83 30       	cpi	r24, 0x03	; 3
    32b4:	21 f2       	breq	.-120    	; 0x323e <main+0x1348>
    32b6:	cd c2       	rjmp	.+1434   	; 0x3852 <main+0x195c>
		//if one passed call state of g_MAIN[done]
		while (state == CHECK_PASS) {
			/*to checking how many times that the pass enter
			 *and if enter more than 3 times breaking loop and
			 *and active buzzer for min and go to main*/
			if (g_try == 3) {
    32b8:	80 91 81 01 	lds	r24, 0x0181
    32bc:	83 30       	cpi	r24, 0x03	; 3
    32be:	71 f4       	brne	.+28     	; 0x32dc <main+0x13e6>
				Buzzer_on();
    32c0:	0e 94 63 0f 	call	0x1ec6	; 0x1ec6 <Buzzer_on>
				Delay_By_Uing_Timer1_Using_interput(60);
    32c4:	8c e3       	ldi	r24, 0x3C	; 60
    32c6:	90 e0       	ldi	r25, 0x00	; 0
    32c8:	0e 94 5f 1c 	call	0x38be	; 0x38be <Delay_By_Uing_Timer1_Using_interput>
				Buzzer_off();
    32cc:	0e 94 6f 0f 	call	0x1ede	; 0x1ede <Buzzer_off>
				state = MAIN;
    32d0:	fe 01       	movw	r30, r28
    32d2:	e2 53       	subi	r30, 0x32	; 50
    32d4:	ff 4f       	sbci	r31, 0xFF	; 255
    32d6:	85 e0       	ldi	r24, 0x05	; 5
    32d8:	80 83       	st	Z, r24
    32da:	dd c2       	rjmp	.+1466   	; 0x3896 <main+0x19a0>
				break;
			}
			uint8 local_state = UART_recieveByte();/*to receive uart state */
    32dc:	0e 94 bf 07 	call	0xf7e	; 0xf7e <UART_recieveByte>
    32e0:	fe 01       	movw	r30, r28
    32e2:	ea 53       	subi	r30, 0x3A	; 58
    32e4:	ff 4f       	sbci	r31, 0xFF	; 255
    32e6:	80 83       	st	Z, r24
			if (local_state == UART_CHECK_PASS_READY) {
    32e8:	fe 01       	movw	r30, r28
    32ea:	ea 53       	subi	r30, 0x3A	; 58
    32ec:	ff 4f       	sbci	r31, 0xFF	; 255
    32ee:	80 81       	ld	r24, Z
    32f0:	8e 31       	cpi	r24, 0x1E	; 30
    32f2:	09 f0       	breq	.+2      	; 0x32f6 <main+0x1400>
    32f4:	a9 c2       	rjmp	.+1362   	; 0x3848 <main+0x1952>
				UART_sendByte(UART_CHECK_PASS_YES_READY);
    32f6:	8f e1       	ldi	r24, 0x1F	; 31
    32f8:	0e 94 ab 07 	call	0xf56	; 0xf56 <UART_sendByte>

				/*to receive pass*/
				for (password_counter_digit = 0; password_counter_digit < 5;
    32fc:	fe 01       	movw	r30, r28
    32fe:	e1 53       	subi	r30, 0x31	; 49
    3300:	ff 4f       	sbci	r31, 0xFF	; 255
    3302:	10 82       	st	Z, r1
    3304:	19 c0       	rjmp	.+50     	; 0x3338 <main+0x1442>
						++password_counter_digit) {
					password[password_counter_digit] = UART_recieveByte();
    3306:	fe 01       	movw	r30, r28
    3308:	e1 53       	subi	r30, 0x31	; 49
    330a:	ff 4f       	sbci	r31, 0xFF	; 255
    330c:	80 81       	ld	r24, Z
    330e:	08 2f       	mov	r16, r24
    3310:	10 e0       	ldi	r17, 0x00	; 0
    3312:	0e 94 bf 07 	call	0xf7e	; 0xf7e <UART_recieveByte>
    3316:	28 2f       	mov	r18, r24
    3318:	ce 01       	movw	r24, r28
    331a:	80 53       	subi	r24, 0x30	; 48
    331c:	9f 4f       	sbci	r25, 0xFF	; 255
    331e:	fc 01       	movw	r30, r24
    3320:	e0 0f       	add	r30, r16
    3322:	f1 1f       	adc	r31, r17
    3324:	20 83       	st	Z, r18
			if (local_state == UART_CHECK_PASS_READY) {
				UART_sendByte(UART_CHECK_PASS_YES_READY);

				/*to receive pass*/
				for (password_counter_digit = 0; password_counter_digit < 5;
						++password_counter_digit) {
    3326:	de 01       	movw	r26, r28
    3328:	a1 53       	subi	r26, 0x31	; 49
    332a:	bf 4f       	sbci	r27, 0xFF	; 255
    332c:	fe 01       	movw	r30, r28
    332e:	e1 53       	subi	r30, 0x31	; 49
    3330:	ff 4f       	sbci	r31, 0xFF	; 255
    3332:	80 81       	ld	r24, Z
    3334:	8f 5f       	subi	r24, 0xFF	; 255
    3336:	8c 93       	st	X, r24
			uint8 local_state = UART_recieveByte();/*to receive uart state */
			if (local_state == UART_CHECK_PASS_READY) {
				UART_sendByte(UART_CHECK_PASS_YES_READY);

				/*to receive pass*/
				for (password_counter_digit = 0; password_counter_digit < 5;
    3338:	fe 01       	movw	r30, r28
    333a:	e1 53       	subi	r30, 0x31	; 49
    333c:	ff 4f       	sbci	r31, 0xFF	; 255
    333e:	80 81       	ld	r24, Z
    3340:	85 30       	cpi	r24, 0x05	; 5
    3342:	08 f3       	brcs	.-62     	; 0x3306 <main+0x1410>
						++password_counter_digit) {
					password[password_counter_digit] = UART_recieveByte();

				}
				/*compere it with that in eeprom*/
				EEPROM_readByte(0x0310, &confirmation_password[0]);
    3344:	9e 01       	movw	r18, r28
    3346:	2b 52       	subi	r18, 0x2B	; 43
    3348:	3f 4f       	sbci	r19, 0xFF	; 255
    334a:	80 e1       	ldi	r24, 0x10	; 16
    334c:	93 e0       	ldi	r25, 0x03	; 3
    334e:	b9 01       	movw	r22, r18
    3350:	0e 94 65 0e 	call	0x1cca	; 0x1cca <EEPROM_readByte>
				if (password[0] == confirmation_password[0]) {
    3354:	fe 01       	movw	r30, r28
    3356:	e0 53       	subi	r30, 0x30	; 48
    3358:	ff 4f       	sbci	r31, 0xFF	; 255
    335a:	90 81       	ld	r25, Z
    335c:	fe 01       	movw	r30, r28
    335e:	eb 52       	subi	r30, 0x2B	; 43
    3360:	ff 4f       	sbci	r31, 0xFF	; 255
    3362:	80 81       	ld	r24, Z
    3364:	98 17       	cp	r25, r24
    3366:	09 f0       	breq	.+2      	; 0x336a <main+0x1474>
    3368:	61 c2       	rjmp	.+1218   	; 0x382c <main+0x1936>
    336a:	80 e0       	ldi	r24, 0x00	; 0
    336c:	90 e0       	ldi	r25, 0x00	; 0
    336e:	a0 e2       	ldi	r26, 0x20	; 32
    3370:	b1 e4       	ldi	r27, 0x41	; 65
    3372:	8d ab       	std	Y+53, r24	; 0x35
    3374:	9e ab       	std	Y+54, r25	; 0x36
    3376:	af ab       	std	Y+55, r26	; 0x37
    3378:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    337a:	6d a9       	ldd	r22, Y+53	; 0x35
    337c:	7e a9       	ldd	r23, Y+54	; 0x36
    337e:	8f a9       	ldd	r24, Y+55	; 0x37
    3380:	98 ad       	ldd	r25, Y+56	; 0x38
    3382:	20 e0       	ldi	r18, 0x00	; 0
    3384:	30 e0       	ldi	r19, 0x00	; 0
    3386:	4a ef       	ldi	r20, 0xFA	; 250
    3388:	54 e4       	ldi	r21, 0x44	; 68
    338a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    338e:	dc 01       	movw	r26, r24
    3390:	cb 01       	movw	r24, r22
    3392:	89 ab       	std	Y+49, r24	; 0x31
    3394:	9a ab       	std	Y+50, r25	; 0x32
    3396:	ab ab       	std	Y+51, r26	; 0x33
    3398:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    339a:	69 a9       	ldd	r22, Y+49	; 0x31
    339c:	7a a9       	ldd	r23, Y+50	; 0x32
    339e:	8b a9       	ldd	r24, Y+51	; 0x33
    33a0:	9c a9       	ldd	r25, Y+52	; 0x34
    33a2:	20 e0       	ldi	r18, 0x00	; 0
    33a4:	30 e0       	ldi	r19, 0x00	; 0
    33a6:	40 e8       	ldi	r20, 0x80	; 128
    33a8:	5f e3       	ldi	r21, 0x3F	; 63
    33aa:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    33ae:	88 23       	and	r24, r24
    33b0:	2c f4       	brge	.+10     	; 0x33bc <main+0x14c6>
		__ticks = 1;
    33b2:	81 e0       	ldi	r24, 0x01	; 1
    33b4:	90 e0       	ldi	r25, 0x00	; 0
    33b6:	98 ab       	std	Y+48, r25	; 0x30
    33b8:	8f a7       	std	Y+47, r24	; 0x2f
    33ba:	3f c0       	rjmp	.+126    	; 0x343a <main+0x1544>
	else if (__tmp > 65535)
    33bc:	69 a9       	ldd	r22, Y+49	; 0x31
    33be:	7a a9       	ldd	r23, Y+50	; 0x32
    33c0:	8b a9       	ldd	r24, Y+51	; 0x33
    33c2:	9c a9       	ldd	r25, Y+52	; 0x34
    33c4:	20 e0       	ldi	r18, 0x00	; 0
    33c6:	3f ef       	ldi	r19, 0xFF	; 255
    33c8:	4f e7       	ldi	r20, 0x7F	; 127
    33ca:	57 e4       	ldi	r21, 0x47	; 71
    33cc:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    33d0:	18 16       	cp	r1, r24
    33d2:	4c f5       	brge	.+82     	; 0x3426 <main+0x1530>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    33d4:	6d a9       	ldd	r22, Y+53	; 0x35
    33d6:	7e a9       	ldd	r23, Y+54	; 0x36
    33d8:	8f a9       	ldd	r24, Y+55	; 0x37
    33da:	98 ad       	ldd	r25, Y+56	; 0x38
    33dc:	20 e0       	ldi	r18, 0x00	; 0
    33de:	30 e0       	ldi	r19, 0x00	; 0
    33e0:	40 e2       	ldi	r20, 0x20	; 32
    33e2:	51 e4       	ldi	r21, 0x41	; 65
    33e4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    33e8:	dc 01       	movw	r26, r24
    33ea:	cb 01       	movw	r24, r22
    33ec:	bc 01       	movw	r22, r24
    33ee:	cd 01       	movw	r24, r26
    33f0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    33f4:	dc 01       	movw	r26, r24
    33f6:	cb 01       	movw	r24, r22
    33f8:	98 ab       	std	Y+48, r25	; 0x30
    33fa:	8f a7       	std	Y+47, r24	; 0x2f
    33fc:	0f c0       	rjmp	.+30     	; 0x341c <main+0x1526>
    33fe:	88 ec       	ldi	r24, 0xC8	; 200
    3400:	90 e0       	ldi	r25, 0x00	; 0
    3402:	9e a7       	std	Y+46, r25	; 0x2e
    3404:	8d a7       	std	Y+45, r24	; 0x2d
    3406:	8d a5       	ldd	r24, Y+45	; 0x2d
    3408:	9e a5       	ldd	r25, Y+46	; 0x2e
    340a:	01 97       	sbiw	r24, 0x01	; 1
    340c:	f1 f7       	brne	.-4      	; 0x340a <main+0x1514>
    340e:	9e a7       	std	Y+46, r25	; 0x2e
    3410:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3412:	8f a5       	ldd	r24, Y+47	; 0x2f
    3414:	98 a9       	ldd	r25, Y+48	; 0x30
    3416:	01 97       	sbiw	r24, 0x01	; 1
    3418:	98 ab       	std	Y+48, r25	; 0x30
    341a:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    341c:	8f a5       	ldd	r24, Y+47	; 0x2f
    341e:	98 a9       	ldd	r25, Y+48	; 0x30
    3420:	00 97       	sbiw	r24, 0x00	; 0
    3422:	69 f7       	brne	.-38     	; 0x33fe <main+0x1508>
    3424:	14 c0       	rjmp	.+40     	; 0x344e <main+0x1558>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3426:	69 a9       	ldd	r22, Y+49	; 0x31
    3428:	7a a9       	ldd	r23, Y+50	; 0x32
    342a:	8b a9       	ldd	r24, Y+51	; 0x33
    342c:	9c a9       	ldd	r25, Y+52	; 0x34
    342e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3432:	dc 01       	movw	r26, r24
    3434:	cb 01       	movw	r24, r22
    3436:	98 ab       	std	Y+48, r25	; 0x30
    3438:	8f a7       	std	Y+47, r24	; 0x2f
    343a:	8f a5       	ldd	r24, Y+47	; 0x2f
    343c:	98 a9       	ldd	r25, Y+48	; 0x30
    343e:	9c a7       	std	Y+44, r25	; 0x2c
    3440:	8b a7       	std	Y+43, r24	; 0x2b
    3442:	8b a5       	ldd	r24, Y+43	; 0x2b
    3444:	9c a5       	ldd	r25, Y+44	; 0x2c
    3446:	01 97       	sbiw	r24, 0x01	; 1
    3448:	f1 f7       	brne	.-4      	; 0x3446 <main+0x1550>
    344a:	9c a7       	std	Y+44, r25	; 0x2c
    344c:	8b a7       	std	Y+43, r24	; 0x2b
					_delay_ms(10);
					EEPROM_readByte(0x0315, &confirmation_password[1]);
    344e:	ce 01       	movw	r24, r28
    3450:	8b 52       	subi	r24, 0x2B	; 43
    3452:	9f 4f       	sbci	r25, 0xFF	; 255
    3454:	9c 01       	movw	r18, r24
    3456:	2f 5f       	subi	r18, 0xFF	; 255
    3458:	3f 4f       	sbci	r19, 0xFF	; 255
    345a:	85 e1       	ldi	r24, 0x15	; 21
    345c:	93 e0       	ldi	r25, 0x03	; 3
    345e:	b9 01       	movw	r22, r18
    3460:	0e 94 65 0e 	call	0x1cca	; 0x1cca <EEPROM_readByte>
					if (password[1] == confirmation_password[1]) {
    3464:	fe 01       	movw	r30, r28
    3466:	e0 53       	subi	r30, 0x30	; 48
    3468:	ff 4f       	sbci	r31, 0xFF	; 255
    346a:	91 81       	ldd	r25, Z+1	; 0x01
    346c:	fe 01       	movw	r30, r28
    346e:	eb 52       	subi	r30, 0x2B	; 43
    3470:	ff 4f       	sbci	r31, 0xFF	; 255
    3472:	81 81       	ldd	r24, Z+1	; 0x01
    3474:	98 17       	cp	r25, r24
    3476:	09 f0       	breq	.+2      	; 0x347a <main+0x1584>
    3478:	cb c1       	rjmp	.+918    	; 0x3810 <main+0x191a>
    347a:	80 e0       	ldi	r24, 0x00	; 0
    347c:	90 e0       	ldi	r25, 0x00	; 0
    347e:	a0 e2       	ldi	r26, 0x20	; 32
    3480:	b1 e4       	ldi	r27, 0x41	; 65
    3482:	8f a3       	std	Y+39, r24	; 0x27
    3484:	98 a7       	std	Y+40, r25	; 0x28
    3486:	a9 a7       	std	Y+41, r26	; 0x29
    3488:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    348a:	6f a1       	ldd	r22, Y+39	; 0x27
    348c:	78 a5       	ldd	r23, Y+40	; 0x28
    348e:	89 a5       	ldd	r24, Y+41	; 0x29
    3490:	9a a5       	ldd	r25, Y+42	; 0x2a
    3492:	20 e0       	ldi	r18, 0x00	; 0
    3494:	30 e0       	ldi	r19, 0x00	; 0
    3496:	4a ef       	ldi	r20, 0xFA	; 250
    3498:	54 e4       	ldi	r21, 0x44	; 68
    349a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    349e:	dc 01       	movw	r26, r24
    34a0:	cb 01       	movw	r24, r22
    34a2:	8b a3       	std	Y+35, r24	; 0x23
    34a4:	9c a3       	std	Y+36, r25	; 0x24
    34a6:	ad a3       	std	Y+37, r26	; 0x25
    34a8:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    34aa:	6b a1       	ldd	r22, Y+35	; 0x23
    34ac:	7c a1       	ldd	r23, Y+36	; 0x24
    34ae:	8d a1       	ldd	r24, Y+37	; 0x25
    34b0:	9e a1       	ldd	r25, Y+38	; 0x26
    34b2:	20 e0       	ldi	r18, 0x00	; 0
    34b4:	30 e0       	ldi	r19, 0x00	; 0
    34b6:	40 e8       	ldi	r20, 0x80	; 128
    34b8:	5f e3       	ldi	r21, 0x3F	; 63
    34ba:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    34be:	88 23       	and	r24, r24
    34c0:	2c f4       	brge	.+10     	; 0x34cc <main+0x15d6>
		__ticks = 1;
    34c2:	81 e0       	ldi	r24, 0x01	; 1
    34c4:	90 e0       	ldi	r25, 0x00	; 0
    34c6:	9a a3       	std	Y+34, r25	; 0x22
    34c8:	89 a3       	std	Y+33, r24	; 0x21
    34ca:	3f c0       	rjmp	.+126    	; 0x354a <main+0x1654>
	else if (__tmp > 65535)
    34cc:	6b a1       	ldd	r22, Y+35	; 0x23
    34ce:	7c a1       	ldd	r23, Y+36	; 0x24
    34d0:	8d a1       	ldd	r24, Y+37	; 0x25
    34d2:	9e a1       	ldd	r25, Y+38	; 0x26
    34d4:	20 e0       	ldi	r18, 0x00	; 0
    34d6:	3f ef       	ldi	r19, 0xFF	; 255
    34d8:	4f e7       	ldi	r20, 0x7F	; 127
    34da:	57 e4       	ldi	r21, 0x47	; 71
    34dc:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    34e0:	18 16       	cp	r1, r24
    34e2:	4c f5       	brge	.+82     	; 0x3536 <main+0x1640>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    34e4:	6f a1       	ldd	r22, Y+39	; 0x27
    34e6:	78 a5       	ldd	r23, Y+40	; 0x28
    34e8:	89 a5       	ldd	r24, Y+41	; 0x29
    34ea:	9a a5       	ldd	r25, Y+42	; 0x2a
    34ec:	20 e0       	ldi	r18, 0x00	; 0
    34ee:	30 e0       	ldi	r19, 0x00	; 0
    34f0:	40 e2       	ldi	r20, 0x20	; 32
    34f2:	51 e4       	ldi	r21, 0x41	; 65
    34f4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    34f8:	dc 01       	movw	r26, r24
    34fa:	cb 01       	movw	r24, r22
    34fc:	bc 01       	movw	r22, r24
    34fe:	cd 01       	movw	r24, r26
    3500:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3504:	dc 01       	movw	r26, r24
    3506:	cb 01       	movw	r24, r22
    3508:	9a a3       	std	Y+34, r25	; 0x22
    350a:	89 a3       	std	Y+33, r24	; 0x21
    350c:	0f c0       	rjmp	.+30     	; 0x352c <main+0x1636>
    350e:	88 ec       	ldi	r24, 0xC8	; 200
    3510:	90 e0       	ldi	r25, 0x00	; 0
    3512:	98 a3       	std	Y+32, r25	; 0x20
    3514:	8f 8f       	std	Y+31, r24	; 0x1f
    3516:	8f 8d       	ldd	r24, Y+31	; 0x1f
    3518:	98 a1       	ldd	r25, Y+32	; 0x20
    351a:	01 97       	sbiw	r24, 0x01	; 1
    351c:	f1 f7       	brne	.-4      	; 0x351a <main+0x1624>
    351e:	98 a3       	std	Y+32, r25	; 0x20
    3520:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3522:	89 a1       	ldd	r24, Y+33	; 0x21
    3524:	9a a1       	ldd	r25, Y+34	; 0x22
    3526:	01 97       	sbiw	r24, 0x01	; 1
    3528:	9a a3       	std	Y+34, r25	; 0x22
    352a:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    352c:	89 a1       	ldd	r24, Y+33	; 0x21
    352e:	9a a1       	ldd	r25, Y+34	; 0x22
    3530:	00 97       	sbiw	r24, 0x00	; 0
    3532:	69 f7       	brne	.-38     	; 0x350e <main+0x1618>
    3534:	14 c0       	rjmp	.+40     	; 0x355e <main+0x1668>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3536:	6b a1       	ldd	r22, Y+35	; 0x23
    3538:	7c a1       	ldd	r23, Y+36	; 0x24
    353a:	8d a1       	ldd	r24, Y+37	; 0x25
    353c:	9e a1       	ldd	r25, Y+38	; 0x26
    353e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3542:	dc 01       	movw	r26, r24
    3544:	cb 01       	movw	r24, r22
    3546:	9a a3       	std	Y+34, r25	; 0x22
    3548:	89 a3       	std	Y+33, r24	; 0x21
    354a:	89 a1       	ldd	r24, Y+33	; 0x21
    354c:	9a a1       	ldd	r25, Y+34	; 0x22
    354e:	9e 8f       	std	Y+30, r25	; 0x1e
    3550:	8d 8f       	std	Y+29, r24	; 0x1d
    3552:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3554:	9e 8d       	ldd	r25, Y+30	; 0x1e
    3556:	01 97       	sbiw	r24, 0x01	; 1
    3558:	f1 f7       	brne	.-4      	; 0x3556 <main+0x1660>
    355a:	9e 8f       	std	Y+30, r25	; 0x1e
    355c:	8d 8f       	std	Y+29, r24	; 0x1d
						_delay_ms(10);
						EEPROM_readByte(0x0320, &confirmation_password[2]);
    355e:	ce 01       	movw	r24, r28
    3560:	8b 52       	subi	r24, 0x2B	; 43
    3562:	9f 4f       	sbci	r25, 0xFF	; 255
    3564:	9c 01       	movw	r18, r24
    3566:	2e 5f       	subi	r18, 0xFE	; 254
    3568:	3f 4f       	sbci	r19, 0xFF	; 255
    356a:	80 e2       	ldi	r24, 0x20	; 32
    356c:	93 e0       	ldi	r25, 0x03	; 3
    356e:	b9 01       	movw	r22, r18
    3570:	0e 94 65 0e 	call	0x1cca	; 0x1cca <EEPROM_readByte>
						if (password[2] == confirmation_password[2]) {
    3574:	fe 01       	movw	r30, r28
    3576:	e0 53       	subi	r30, 0x30	; 48
    3578:	ff 4f       	sbci	r31, 0xFF	; 255
    357a:	92 81       	ldd	r25, Z+2	; 0x02
    357c:	fe 01       	movw	r30, r28
    357e:	eb 52       	subi	r30, 0x2B	; 43
    3580:	ff 4f       	sbci	r31, 0xFF	; 255
    3582:	82 81       	ldd	r24, Z+2	; 0x02
    3584:	98 17       	cp	r25, r24
    3586:	09 f0       	breq	.+2      	; 0x358a <main+0x1694>
    3588:	35 c1       	rjmp	.+618    	; 0x37f4 <main+0x18fe>
    358a:	80 e0       	ldi	r24, 0x00	; 0
    358c:	90 e0       	ldi	r25, 0x00	; 0
    358e:	a0 e2       	ldi	r26, 0x20	; 32
    3590:	b1 e4       	ldi	r27, 0x41	; 65
    3592:	89 8f       	std	Y+25, r24	; 0x19
    3594:	9a 8f       	std	Y+26, r25	; 0x1a
    3596:	ab 8f       	std	Y+27, r26	; 0x1b
    3598:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    359a:	69 8d       	ldd	r22, Y+25	; 0x19
    359c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    359e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    35a0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    35a2:	20 e0       	ldi	r18, 0x00	; 0
    35a4:	30 e0       	ldi	r19, 0x00	; 0
    35a6:	4a ef       	ldi	r20, 0xFA	; 250
    35a8:	54 e4       	ldi	r21, 0x44	; 68
    35aa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    35ae:	dc 01       	movw	r26, r24
    35b0:	cb 01       	movw	r24, r22
    35b2:	8d 8b       	std	Y+21, r24	; 0x15
    35b4:	9e 8b       	std	Y+22, r25	; 0x16
    35b6:	af 8b       	std	Y+23, r26	; 0x17
    35b8:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    35ba:	6d 89       	ldd	r22, Y+21	; 0x15
    35bc:	7e 89       	ldd	r23, Y+22	; 0x16
    35be:	8f 89       	ldd	r24, Y+23	; 0x17
    35c0:	98 8d       	ldd	r25, Y+24	; 0x18
    35c2:	20 e0       	ldi	r18, 0x00	; 0
    35c4:	30 e0       	ldi	r19, 0x00	; 0
    35c6:	40 e8       	ldi	r20, 0x80	; 128
    35c8:	5f e3       	ldi	r21, 0x3F	; 63
    35ca:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    35ce:	88 23       	and	r24, r24
    35d0:	2c f4       	brge	.+10     	; 0x35dc <main+0x16e6>
		__ticks = 1;
    35d2:	81 e0       	ldi	r24, 0x01	; 1
    35d4:	90 e0       	ldi	r25, 0x00	; 0
    35d6:	9c 8b       	std	Y+20, r25	; 0x14
    35d8:	8b 8b       	std	Y+19, r24	; 0x13
    35da:	3f c0       	rjmp	.+126    	; 0x365a <main+0x1764>
	else if (__tmp > 65535)
    35dc:	6d 89       	ldd	r22, Y+21	; 0x15
    35de:	7e 89       	ldd	r23, Y+22	; 0x16
    35e0:	8f 89       	ldd	r24, Y+23	; 0x17
    35e2:	98 8d       	ldd	r25, Y+24	; 0x18
    35e4:	20 e0       	ldi	r18, 0x00	; 0
    35e6:	3f ef       	ldi	r19, 0xFF	; 255
    35e8:	4f e7       	ldi	r20, 0x7F	; 127
    35ea:	57 e4       	ldi	r21, 0x47	; 71
    35ec:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    35f0:	18 16       	cp	r1, r24
    35f2:	4c f5       	brge	.+82     	; 0x3646 <main+0x1750>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    35f4:	69 8d       	ldd	r22, Y+25	; 0x19
    35f6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    35f8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    35fa:	9c 8d       	ldd	r25, Y+28	; 0x1c
    35fc:	20 e0       	ldi	r18, 0x00	; 0
    35fe:	30 e0       	ldi	r19, 0x00	; 0
    3600:	40 e2       	ldi	r20, 0x20	; 32
    3602:	51 e4       	ldi	r21, 0x41	; 65
    3604:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3608:	dc 01       	movw	r26, r24
    360a:	cb 01       	movw	r24, r22
    360c:	bc 01       	movw	r22, r24
    360e:	cd 01       	movw	r24, r26
    3610:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3614:	dc 01       	movw	r26, r24
    3616:	cb 01       	movw	r24, r22
    3618:	9c 8b       	std	Y+20, r25	; 0x14
    361a:	8b 8b       	std	Y+19, r24	; 0x13
    361c:	0f c0       	rjmp	.+30     	; 0x363c <main+0x1746>
    361e:	88 ec       	ldi	r24, 0xC8	; 200
    3620:	90 e0       	ldi	r25, 0x00	; 0
    3622:	9a 8b       	std	Y+18, r25	; 0x12
    3624:	89 8b       	std	Y+17, r24	; 0x11
    3626:	89 89       	ldd	r24, Y+17	; 0x11
    3628:	9a 89       	ldd	r25, Y+18	; 0x12
    362a:	01 97       	sbiw	r24, 0x01	; 1
    362c:	f1 f7       	brne	.-4      	; 0x362a <main+0x1734>
    362e:	9a 8b       	std	Y+18, r25	; 0x12
    3630:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3632:	8b 89       	ldd	r24, Y+19	; 0x13
    3634:	9c 89       	ldd	r25, Y+20	; 0x14
    3636:	01 97       	sbiw	r24, 0x01	; 1
    3638:	9c 8b       	std	Y+20, r25	; 0x14
    363a:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    363c:	8b 89       	ldd	r24, Y+19	; 0x13
    363e:	9c 89       	ldd	r25, Y+20	; 0x14
    3640:	00 97       	sbiw	r24, 0x00	; 0
    3642:	69 f7       	brne	.-38     	; 0x361e <main+0x1728>
    3644:	14 c0       	rjmp	.+40     	; 0x366e <main+0x1778>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3646:	6d 89       	ldd	r22, Y+21	; 0x15
    3648:	7e 89       	ldd	r23, Y+22	; 0x16
    364a:	8f 89       	ldd	r24, Y+23	; 0x17
    364c:	98 8d       	ldd	r25, Y+24	; 0x18
    364e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3652:	dc 01       	movw	r26, r24
    3654:	cb 01       	movw	r24, r22
    3656:	9c 8b       	std	Y+20, r25	; 0x14
    3658:	8b 8b       	std	Y+19, r24	; 0x13
    365a:	8b 89       	ldd	r24, Y+19	; 0x13
    365c:	9c 89       	ldd	r25, Y+20	; 0x14
    365e:	98 8b       	std	Y+16, r25	; 0x10
    3660:	8f 87       	std	Y+15, r24	; 0x0f
    3662:	8f 85       	ldd	r24, Y+15	; 0x0f
    3664:	98 89       	ldd	r25, Y+16	; 0x10
    3666:	01 97       	sbiw	r24, 0x01	; 1
    3668:	f1 f7       	brne	.-4      	; 0x3666 <main+0x1770>
    366a:	98 8b       	std	Y+16, r25	; 0x10
    366c:	8f 87       	std	Y+15, r24	; 0x0f
							_delay_ms(10);
							EEPROM_readByte(0x0325, &confirmation_password[3]);
    366e:	ce 01       	movw	r24, r28
    3670:	8b 52       	subi	r24, 0x2B	; 43
    3672:	9f 4f       	sbci	r25, 0xFF	; 255
    3674:	9c 01       	movw	r18, r24
    3676:	2d 5f       	subi	r18, 0xFD	; 253
    3678:	3f 4f       	sbci	r19, 0xFF	; 255
    367a:	85 e2       	ldi	r24, 0x25	; 37
    367c:	93 e0       	ldi	r25, 0x03	; 3
    367e:	b9 01       	movw	r22, r18
    3680:	0e 94 65 0e 	call	0x1cca	; 0x1cca <EEPROM_readByte>
							if (password[3] == confirmation_password[3]) {
    3684:	fe 01       	movw	r30, r28
    3686:	e0 53       	subi	r30, 0x30	; 48
    3688:	ff 4f       	sbci	r31, 0xFF	; 255
    368a:	93 81       	ldd	r25, Z+3	; 0x03
    368c:	fe 01       	movw	r30, r28
    368e:	eb 52       	subi	r30, 0x2B	; 43
    3690:	ff 4f       	sbci	r31, 0xFF	; 255
    3692:	83 81       	ldd	r24, Z+3	; 0x03
    3694:	98 17       	cp	r25, r24
    3696:	09 f0       	breq	.+2      	; 0x369a <main+0x17a4>
    3698:	9f c0       	rjmp	.+318    	; 0x37d8 <main+0x18e2>
    369a:	80 e0       	ldi	r24, 0x00	; 0
    369c:	90 e0       	ldi	r25, 0x00	; 0
    369e:	a0 e2       	ldi	r26, 0x20	; 32
    36a0:	b1 e4       	ldi	r27, 0x41	; 65
    36a2:	8b 87       	std	Y+11, r24	; 0x0b
    36a4:	9c 87       	std	Y+12, r25	; 0x0c
    36a6:	ad 87       	std	Y+13, r26	; 0x0d
    36a8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    36aa:	6b 85       	ldd	r22, Y+11	; 0x0b
    36ac:	7c 85       	ldd	r23, Y+12	; 0x0c
    36ae:	8d 85       	ldd	r24, Y+13	; 0x0d
    36b0:	9e 85       	ldd	r25, Y+14	; 0x0e
    36b2:	20 e0       	ldi	r18, 0x00	; 0
    36b4:	30 e0       	ldi	r19, 0x00	; 0
    36b6:	4a ef       	ldi	r20, 0xFA	; 250
    36b8:	54 e4       	ldi	r21, 0x44	; 68
    36ba:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    36be:	dc 01       	movw	r26, r24
    36c0:	cb 01       	movw	r24, r22
    36c2:	8f 83       	std	Y+7, r24	; 0x07
    36c4:	98 87       	std	Y+8, r25	; 0x08
    36c6:	a9 87       	std	Y+9, r26	; 0x09
    36c8:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    36ca:	6f 81       	ldd	r22, Y+7	; 0x07
    36cc:	78 85       	ldd	r23, Y+8	; 0x08
    36ce:	89 85       	ldd	r24, Y+9	; 0x09
    36d0:	9a 85       	ldd	r25, Y+10	; 0x0a
    36d2:	20 e0       	ldi	r18, 0x00	; 0
    36d4:	30 e0       	ldi	r19, 0x00	; 0
    36d6:	40 e8       	ldi	r20, 0x80	; 128
    36d8:	5f e3       	ldi	r21, 0x3F	; 63
    36da:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    36de:	88 23       	and	r24, r24
    36e0:	2c f4       	brge	.+10     	; 0x36ec <main+0x17f6>
		__ticks = 1;
    36e2:	81 e0       	ldi	r24, 0x01	; 1
    36e4:	90 e0       	ldi	r25, 0x00	; 0
    36e6:	9e 83       	std	Y+6, r25	; 0x06
    36e8:	8d 83       	std	Y+5, r24	; 0x05
    36ea:	3f c0       	rjmp	.+126    	; 0x376a <main+0x1874>
	else if (__tmp > 65535)
    36ec:	6f 81       	ldd	r22, Y+7	; 0x07
    36ee:	78 85       	ldd	r23, Y+8	; 0x08
    36f0:	89 85       	ldd	r24, Y+9	; 0x09
    36f2:	9a 85       	ldd	r25, Y+10	; 0x0a
    36f4:	20 e0       	ldi	r18, 0x00	; 0
    36f6:	3f ef       	ldi	r19, 0xFF	; 255
    36f8:	4f e7       	ldi	r20, 0x7F	; 127
    36fa:	57 e4       	ldi	r21, 0x47	; 71
    36fc:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3700:	18 16       	cp	r1, r24
    3702:	4c f5       	brge	.+82     	; 0x3756 <main+0x1860>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3704:	6b 85       	ldd	r22, Y+11	; 0x0b
    3706:	7c 85       	ldd	r23, Y+12	; 0x0c
    3708:	8d 85       	ldd	r24, Y+13	; 0x0d
    370a:	9e 85       	ldd	r25, Y+14	; 0x0e
    370c:	20 e0       	ldi	r18, 0x00	; 0
    370e:	30 e0       	ldi	r19, 0x00	; 0
    3710:	40 e2       	ldi	r20, 0x20	; 32
    3712:	51 e4       	ldi	r21, 0x41	; 65
    3714:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3718:	dc 01       	movw	r26, r24
    371a:	cb 01       	movw	r24, r22
    371c:	bc 01       	movw	r22, r24
    371e:	cd 01       	movw	r24, r26
    3720:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3724:	dc 01       	movw	r26, r24
    3726:	cb 01       	movw	r24, r22
    3728:	9e 83       	std	Y+6, r25	; 0x06
    372a:	8d 83       	std	Y+5, r24	; 0x05
    372c:	0f c0       	rjmp	.+30     	; 0x374c <main+0x1856>
    372e:	88 ec       	ldi	r24, 0xC8	; 200
    3730:	90 e0       	ldi	r25, 0x00	; 0
    3732:	9c 83       	std	Y+4, r25	; 0x04
    3734:	8b 83       	std	Y+3, r24	; 0x03
    3736:	8b 81       	ldd	r24, Y+3	; 0x03
    3738:	9c 81       	ldd	r25, Y+4	; 0x04
    373a:	01 97       	sbiw	r24, 0x01	; 1
    373c:	f1 f7       	brne	.-4      	; 0x373a <main+0x1844>
    373e:	9c 83       	std	Y+4, r25	; 0x04
    3740:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3742:	8d 81       	ldd	r24, Y+5	; 0x05
    3744:	9e 81       	ldd	r25, Y+6	; 0x06
    3746:	01 97       	sbiw	r24, 0x01	; 1
    3748:	9e 83       	std	Y+6, r25	; 0x06
    374a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    374c:	8d 81       	ldd	r24, Y+5	; 0x05
    374e:	9e 81       	ldd	r25, Y+6	; 0x06
    3750:	00 97       	sbiw	r24, 0x00	; 0
    3752:	69 f7       	brne	.-38     	; 0x372e <main+0x1838>
    3754:	14 c0       	rjmp	.+40     	; 0x377e <main+0x1888>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3756:	6f 81       	ldd	r22, Y+7	; 0x07
    3758:	78 85       	ldd	r23, Y+8	; 0x08
    375a:	89 85       	ldd	r24, Y+9	; 0x09
    375c:	9a 85       	ldd	r25, Y+10	; 0x0a
    375e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3762:	dc 01       	movw	r26, r24
    3764:	cb 01       	movw	r24, r22
    3766:	9e 83       	std	Y+6, r25	; 0x06
    3768:	8d 83       	std	Y+5, r24	; 0x05
    376a:	8d 81       	ldd	r24, Y+5	; 0x05
    376c:	9e 81       	ldd	r25, Y+6	; 0x06
    376e:	9a 83       	std	Y+2, r25	; 0x02
    3770:	89 83       	std	Y+1, r24	; 0x01
    3772:	89 81       	ldd	r24, Y+1	; 0x01
    3774:	9a 81       	ldd	r25, Y+2	; 0x02
    3776:	01 97       	sbiw	r24, 0x01	; 1
    3778:	f1 f7       	brne	.-4      	; 0x3776 <main+0x1880>
    377a:	9a 83       	std	Y+2, r25	; 0x02
    377c:	89 83       	std	Y+1, r24	; 0x01
								_delay_ms(10);
								EEPROM_readByte(0x0330,
    377e:	ce 01       	movw	r24, r28
    3780:	8b 52       	subi	r24, 0x2B	; 43
    3782:	9f 4f       	sbci	r25, 0xFF	; 255
    3784:	9c 01       	movw	r18, r24
    3786:	2c 5f       	subi	r18, 0xFC	; 252
    3788:	3f 4f       	sbci	r19, 0xFF	; 255
    378a:	80 e3       	ldi	r24, 0x30	; 48
    378c:	93 e0       	ldi	r25, 0x03	; 3
    378e:	b9 01       	movw	r22, r18
    3790:	0e 94 65 0e 	call	0x1cca	; 0x1cca <EEPROM_readByte>
										&confirmation_password[4]);
								if (password[4] == confirmation_password[4]) {
    3794:	fe 01       	movw	r30, r28
    3796:	e0 53       	subi	r30, 0x30	; 48
    3798:	ff 4f       	sbci	r31, 0xFF	; 255
    379a:	94 81       	ldd	r25, Z+4	; 0x04
    379c:	fe 01       	movw	r30, r28
    379e:	eb 52       	subi	r30, 0x2B	; 43
    37a0:	ff 4f       	sbci	r31, 0xFF	; 255
    37a2:	84 81       	ldd	r24, Z+4	; 0x04
    37a4:	98 17       	cp	r25, r24
    37a6:	51 f4       	brne	.+20     	; 0x37bc <main+0x18c6>
									//that the pass match
									UART_sendByte(UART_PASS_MATCH);
    37a8:	8e e0       	ldi	r24, 0x0E	; 14
    37aa:	0e 94 ab 07 	call	0xf56	; 0xf56 <UART_sendByte>

									state = g_main;
    37ae:	fe 01       	movw	r30, r28
    37b0:	e2 53       	subi	r30, 0x32	; 50
    37b2:	ff 4f       	sbci	r31, 0xFF	; 255
    37b4:	80 91 82 01 	lds	r24, 0x0182
    37b8:	80 83       	st	Z, r24
    37ba:	4b c0       	rjmp	.+150    	; 0x3852 <main+0x195c>
								} else {
									//not match
									UART_sendByte(UART_PASS_MISMATCH);
    37bc:	8f e0       	ldi	r24, 0x0F	; 15
    37be:	0e 94 ab 07 	call	0xf56	; 0xf56 <UART_sendByte>
									state = CHECK_PASS;
    37c2:	fe 01       	movw	r30, r28
    37c4:	e2 53       	subi	r30, 0x32	; 50
    37c6:	ff 4f       	sbci	r31, 0xFF	; 255
    37c8:	82 e0       	ldi	r24, 0x02	; 2
    37ca:	80 83       	st	Z, r24
									g_try++;
    37cc:	80 91 81 01 	lds	r24, 0x0181
    37d0:	8f 5f       	subi	r24, 0xFF	; 255
    37d2:	80 93 81 01 	sts	0x0181, r24
    37d6:	5f c0       	rjmp	.+190    	; 0x3896 <main+0x19a0>

									break;
								}
							} else {
								//not match
								UART_sendByte(UART_PASS_MISMATCH);
    37d8:	8f e0       	ldi	r24, 0x0F	; 15
    37da:	0e 94 ab 07 	call	0xf56	; 0xf56 <UART_sendByte>
								state = CHECK_PASS;
    37de:	fe 01       	movw	r30, r28
    37e0:	e2 53       	subi	r30, 0x32	; 50
    37e2:	ff 4f       	sbci	r31, 0xFF	; 255
    37e4:	82 e0       	ldi	r24, 0x02	; 2
    37e6:	80 83       	st	Z, r24
								g_try++;
    37e8:	80 91 81 01 	lds	r24, 0x0181
    37ec:	8f 5f       	subi	r24, 0xFF	; 255
    37ee:	80 93 81 01 	sts	0x0181, r24
    37f2:	51 c0       	rjmp	.+162    	; 0x3896 <main+0x19a0>

								break;
							}
						} else {
							//not match
							UART_sendByte(UART_PASS_MISMATCH);
    37f4:	8f e0       	ldi	r24, 0x0F	; 15
    37f6:	0e 94 ab 07 	call	0xf56	; 0xf56 <UART_sendByte>
							state = CHECK_PASS;
    37fa:	fe 01       	movw	r30, r28
    37fc:	e2 53       	subi	r30, 0x32	; 50
    37fe:	ff 4f       	sbci	r31, 0xFF	; 255
    3800:	82 e0       	ldi	r24, 0x02	; 2
    3802:	80 83       	st	Z, r24
							g_try++;
    3804:	80 91 81 01 	lds	r24, 0x0181
    3808:	8f 5f       	subi	r24, 0xFF	; 255
    380a:	80 93 81 01 	sts	0x0181, r24
    380e:	43 c0       	rjmp	.+134    	; 0x3896 <main+0x19a0>
							break;

						}
					} else {
						//not match
						UART_sendByte(UART_PASS_MISMATCH);
    3810:	8f e0       	ldi	r24, 0x0F	; 15
    3812:	0e 94 ab 07 	call	0xf56	; 0xf56 <UART_sendByte>
						state = CHECK_PASS;
    3816:	fe 01       	movw	r30, r28
    3818:	e2 53       	subi	r30, 0x32	; 50
    381a:	ff 4f       	sbci	r31, 0xFF	; 255
    381c:	82 e0       	ldi	r24, 0x02	; 2
    381e:	80 83       	st	Z, r24
						g_try++;
    3820:	80 91 81 01 	lds	r24, 0x0181
    3824:	8f 5f       	subi	r24, 0xFF	; 255
    3826:	80 93 81 01 	sts	0x0181, r24
    382a:	35 c0       	rjmp	.+106    	; 0x3896 <main+0x19a0>

						break;
					}
				} else {
					//not match
					UART_sendByte(UART_PASS_MISMATCH);
    382c:	8f e0       	ldi	r24, 0x0F	; 15
    382e:	0e 94 ab 07 	call	0xf56	; 0xf56 <UART_sendByte>
					state = CHECK_PASS;
    3832:	fe 01       	movw	r30, r28
    3834:	e2 53       	subi	r30, 0x32	; 50
    3836:	ff 4f       	sbci	r31, 0xFF	; 255
    3838:	82 e0       	ldi	r24, 0x02	; 2
    383a:	80 83       	st	Z, r24
					g_try++;
    383c:	80 91 81 01 	lds	r24, 0x0181
    3840:	8f 5f       	subi	r24, 0xFF	; 255
    3842:	80 93 81 01 	sts	0x0181, r24
    3846:	27 c0       	rjmp	.+78     	; 0x3896 <main+0x19a0>

					break;
				}
			} else {
				state = CHECK_PASS;
    3848:	fe 01       	movw	r30, r28
    384a:	e2 53       	subi	r30, 0x32	; 50
    384c:	ff 4f       	sbci	r31, 0xFF	; 255
    384e:	82 e0       	ldi	r24, 0x02	; 2
    3850:	80 83       	st	Z, r24
		/*******************************************************************************
		 *                                    CHECK_PASS                              *
		 *******************************************************************************/
		//check pass normal 3 times [done]
		//if one passed call state of g_MAIN[done]
		while (state == CHECK_PASS) {
    3852:	fe 01       	movw	r30, r28
    3854:	e2 53       	subi	r30, 0x32	; 50
    3856:	ff 4f       	sbci	r31, 0xFF	; 255
    3858:	80 81       	ld	r24, Z
    385a:	82 30       	cpi	r24, 0x02	; 2
    385c:	09 f4       	brne	.+2      	; 0x3860 <main+0x196a>
    385e:	2c cd       	rjmp	.-1448   	; 0x32b8 <main+0x13c2>
    3860:	1a c0       	rjmp	.+52     	; 0x3896 <main+0x19a0>
		}
		/*******************************************************************************
		 *                                    CHANGE_PASS                             *
		 *******************************************************************************/
		while (state == CHANGE_PASS) {
			uint8 local_state = UART_recieveByte();/*to receive uart state */
    3862:	0e 94 bf 07 	call	0xf7e	; 0xf7e <UART_recieveByte>
    3866:	fe 01       	movw	r30, r28
    3868:	eb 53       	subi	r30, 0x3B	; 59
    386a:	ff 4f       	sbci	r31, 0xFF	; 255
    386c:	80 83       	st	Z, r24
			if (local_state == UART_CHANGE_PASS_READY) {
    386e:	fe 01       	movw	r30, r28
    3870:	eb 53       	subi	r30, 0x3B	; 59
    3872:	ff 4f       	sbci	r31, 0xFF	; 255
    3874:	80 81       	ld	r24, Z
    3876:	80 32       	cpi	r24, 0x20	; 32
    3878:	49 f4       	brne	.+18     	; 0x388c <main+0x1996>
				UART_sendByte(UART_CHANGE_PASS_YES_READY);
    387a:	81 e2       	ldi	r24, 0x21	; 33
    387c:	0e 94 ab 07 	call	0xf56	; 0xf56 <UART_sendByte>
				state = CREATE_PASS;/*go to create pass*/
    3880:	fe 01       	movw	r30, r28
    3882:	e2 53       	subi	r30, 0x32	; 50
    3884:	ff 4f       	sbci	r31, 0xFF	; 255
    3886:	10 82       	st	Z, r1
    3888:	0c 94 ea 10 	jmp	0x21d4	; 0x21d4 <main+0x2de>
				break;
			} else {
				state = CHANGE_PASS;/*a problem occurred retry itself*/
    388c:	fe 01       	movw	r30, r28
    388e:	e2 53       	subi	r30, 0x32	; 50
    3890:	ff 4f       	sbci	r31, 0xFF	; 255
    3892:	84 e0       	ldi	r24, 0x04	; 4
    3894:	80 83       	st	Z, r24
			}
		}
		/*******************************************************************************
		 *                                    CHANGE_PASS                             *
		 *******************************************************************************/
		while (state == CHANGE_PASS) {
    3896:	fe 01       	movw	r30, r28
    3898:	e2 53       	subi	r30, 0x32	; 50
    389a:	ff 4f       	sbci	r31, 0xFF	; 255
    389c:	80 81       	ld	r24, Z
    389e:	84 30       	cpi	r24, 0x04	; 4
    38a0:	01 f3       	breq	.-64     	; 0x3862 <main+0x196c>
    38a2:	0c 94 ea 10 	jmp	0x21d4	; 0x21d4 <main+0x2de>

000038a6 <count_Seconds>:
	}
}
/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/
void count_Seconds(void) {
    38a6:	df 93       	push	r29
    38a8:	cf 93       	push	r28
    38aa:	cd b7       	in	r28, 0x3d	; 61
    38ac:	de b7       	in	r29, 0x3e	; 62
	g_sec = g_sec + 1;
    38ae:	80 91 80 01 	lds	r24, 0x0180
    38b2:	8f 5f       	subi	r24, 0xFF	; 255
    38b4:	80 93 80 01 	sts	0x0180, r24
}
    38b8:	cf 91       	pop	r28
    38ba:	df 91       	pop	r29
    38bc:	08 95       	ret

000038be <Delay_By_Uing_Timer1_Using_interput>:
void Delay_By_Uing_Timer1_Using_interput(uint16 SecDelay) {
    38be:	df 93       	push	r29
    38c0:	cf 93       	push	r28
    38c2:	cd b7       	in	r28, 0x3d	; 61
    38c4:	de b7       	in	r29, 0x3e	; 62
    38c6:	2d 97       	sbiw	r28, 0x0d	; 13
    38c8:	0f b6       	in	r0, 0x3f	; 63
    38ca:	f8 94       	cli
    38cc:	de bf       	out	0x3e, r29	; 62
    38ce:	0f be       	out	0x3f, r0	; 63
    38d0:	cd bf       	out	0x3d, r28	; 61
    38d2:	98 87       	std	Y+8, r25	; 0x08
    38d4:	8f 83       	std	Y+7, r24	; 0x07
	Timer1_setCallBack(count_Seconds);
    38d6:	83 e5       	ldi	r24, 0x53	; 83
    38d8:	9c e1       	ldi	r25, 0x1C	; 28
    38da:	0e 94 aa 0a 	call	0x1554	; 0x1554 <Timer1_setCallBack>
	/*Ttimer=256/8*1000000 = .000032sec
	 * ocra1 = 1sec/.000032 = 31250*/
	Timer1_ConfigType Local_timer1_Config = { 0, 31250, Timer1_Prescaler_F_256,
			Timer1_Mode_4_CTC };
    38de:	ce 01       	movw	r24, r28
    38e0:	01 96       	adiw	r24, 0x01	; 1
    38e2:	9a 87       	std	Y+10, r25	; 0x0a
    38e4:	89 87       	std	Y+9, r24	; 0x09
    38e6:	e8 e7       	ldi	r30, 0x78	; 120
    38e8:	f1 e0       	ldi	r31, 0x01	; 1
    38ea:	fc 87       	std	Y+12, r31	; 0x0c
    38ec:	eb 87       	std	Y+11, r30	; 0x0b
    38ee:	f6 e0       	ldi	r31, 0x06	; 6
    38f0:	fd 87       	std	Y+13, r31	; 0x0d
    38f2:	eb 85       	ldd	r30, Y+11	; 0x0b
    38f4:	fc 85       	ldd	r31, Y+12	; 0x0c
    38f6:	00 80       	ld	r0, Z
    38f8:	8b 85       	ldd	r24, Y+11	; 0x0b
    38fa:	9c 85       	ldd	r25, Y+12	; 0x0c
    38fc:	01 96       	adiw	r24, 0x01	; 1
    38fe:	9c 87       	std	Y+12, r25	; 0x0c
    3900:	8b 87       	std	Y+11, r24	; 0x0b
    3902:	e9 85       	ldd	r30, Y+9	; 0x09
    3904:	fa 85       	ldd	r31, Y+10	; 0x0a
    3906:	00 82       	st	Z, r0
    3908:	89 85       	ldd	r24, Y+9	; 0x09
    390a:	9a 85       	ldd	r25, Y+10	; 0x0a
    390c:	01 96       	adiw	r24, 0x01	; 1
    390e:	9a 87       	std	Y+10, r25	; 0x0a
    3910:	89 87       	std	Y+9, r24	; 0x09
    3912:	9d 85       	ldd	r25, Y+13	; 0x0d
    3914:	91 50       	subi	r25, 0x01	; 1
    3916:	9d 87       	std	Y+13, r25	; 0x0d
    3918:	ed 85       	ldd	r30, Y+13	; 0x0d
    391a:	ee 23       	and	r30, r30
    391c:	51 f7       	brne	.-44     	; 0x38f2 <Delay_By_Uing_Timer1_Using_interput+0x34>
	Timer1_init(&Local_timer1_Config);
    391e:	ce 01       	movw	r24, r28
    3920:	01 96       	adiw	r24, 0x01	; 1
    3922:	0e 94 24 0a 	call	0x1448	; 0x1448 <Timer1_init>

	while (g_sec < SecDelay) {
    3926:	80 91 80 01 	lds	r24, 0x0180
    392a:	28 2f       	mov	r18, r24
    392c:	30 e0       	ldi	r19, 0x00	; 0
    392e:	8f 81       	ldd	r24, Y+7	; 0x07
    3930:	98 85       	ldd	r25, Y+8	; 0x08
    3932:	28 17       	cp	r18, r24
    3934:	39 07       	cpc	r19, r25
    3936:	b8 f3       	brcs	.-18     	; 0x3926 <Delay_By_Uing_Timer1_Using_interput+0x68>

	}

	Timer1_deInit();
    3938:	0e 94 86 0a 	call	0x150c	; 0x150c <Timer1_deInit>
	g_sec = 0;
    393c:	10 92 80 01 	sts	0x0180, r1
}
    3940:	2d 96       	adiw	r28, 0x0d	; 13
    3942:	0f b6       	in	r0, 0x3f	; 63
    3944:	f8 94       	cli
    3946:	de bf       	out	0x3e, r29	; 62
    3948:	0f be       	out	0x3f, r0	; 63
    394a:	cd bf       	out	0x3d, r28	; 61
    394c:	cf 91       	pop	r28
    394e:	df 91       	pop	r29
    3950:	08 95       	ret

00003952 <__udivmodsi4>:
    3952:	a1 e2       	ldi	r26, 0x21	; 33
    3954:	1a 2e       	mov	r1, r26
    3956:	aa 1b       	sub	r26, r26
    3958:	bb 1b       	sub	r27, r27
    395a:	fd 01       	movw	r30, r26
    395c:	0d c0       	rjmp	.+26     	; 0x3978 <__udivmodsi4_ep>

0000395e <__udivmodsi4_loop>:
    395e:	aa 1f       	adc	r26, r26
    3960:	bb 1f       	adc	r27, r27
    3962:	ee 1f       	adc	r30, r30
    3964:	ff 1f       	adc	r31, r31
    3966:	a2 17       	cp	r26, r18
    3968:	b3 07       	cpc	r27, r19
    396a:	e4 07       	cpc	r30, r20
    396c:	f5 07       	cpc	r31, r21
    396e:	20 f0       	brcs	.+8      	; 0x3978 <__udivmodsi4_ep>
    3970:	a2 1b       	sub	r26, r18
    3972:	b3 0b       	sbc	r27, r19
    3974:	e4 0b       	sbc	r30, r20
    3976:	f5 0b       	sbc	r31, r21

00003978 <__udivmodsi4_ep>:
    3978:	66 1f       	adc	r22, r22
    397a:	77 1f       	adc	r23, r23
    397c:	88 1f       	adc	r24, r24
    397e:	99 1f       	adc	r25, r25
    3980:	1a 94       	dec	r1
    3982:	69 f7       	brne	.-38     	; 0x395e <__udivmodsi4_loop>
    3984:	60 95       	com	r22
    3986:	70 95       	com	r23
    3988:	80 95       	com	r24
    398a:	90 95       	com	r25
    398c:	9b 01       	movw	r18, r22
    398e:	ac 01       	movw	r20, r24
    3990:	bd 01       	movw	r22, r26
    3992:	cf 01       	movw	r24, r30
    3994:	08 95       	ret

00003996 <__prologue_saves__>:
    3996:	2f 92       	push	r2
    3998:	3f 92       	push	r3
    399a:	4f 92       	push	r4
    399c:	5f 92       	push	r5
    399e:	6f 92       	push	r6
    39a0:	7f 92       	push	r7
    39a2:	8f 92       	push	r8
    39a4:	9f 92       	push	r9
    39a6:	af 92       	push	r10
    39a8:	bf 92       	push	r11
    39aa:	cf 92       	push	r12
    39ac:	df 92       	push	r13
    39ae:	ef 92       	push	r14
    39b0:	ff 92       	push	r15
    39b2:	0f 93       	push	r16
    39b4:	1f 93       	push	r17
    39b6:	cf 93       	push	r28
    39b8:	df 93       	push	r29
    39ba:	cd b7       	in	r28, 0x3d	; 61
    39bc:	de b7       	in	r29, 0x3e	; 62
    39be:	ca 1b       	sub	r28, r26
    39c0:	db 0b       	sbc	r29, r27
    39c2:	0f b6       	in	r0, 0x3f	; 63
    39c4:	f8 94       	cli
    39c6:	de bf       	out	0x3e, r29	; 62
    39c8:	0f be       	out	0x3f, r0	; 63
    39ca:	cd bf       	out	0x3d, r28	; 61
    39cc:	09 94       	ijmp

000039ce <__epilogue_restores__>:
    39ce:	2a 88       	ldd	r2, Y+18	; 0x12
    39d0:	39 88       	ldd	r3, Y+17	; 0x11
    39d2:	48 88       	ldd	r4, Y+16	; 0x10
    39d4:	5f 84       	ldd	r5, Y+15	; 0x0f
    39d6:	6e 84       	ldd	r6, Y+14	; 0x0e
    39d8:	7d 84       	ldd	r7, Y+13	; 0x0d
    39da:	8c 84       	ldd	r8, Y+12	; 0x0c
    39dc:	9b 84       	ldd	r9, Y+11	; 0x0b
    39de:	aa 84       	ldd	r10, Y+10	; 0x0a
    39e0:	b9 84       	ldd	r11, Y+9	; 0x09
    39e2:	c8 84       	ldd	r12, Y+8	; 0x08
    39e4:	df 80       	ldd	r13, Y+7	; 0x07
    39e6:	ee 80       	ldd	r14, Y+6	; 0x06
    39e8:	fd 80       	ldd	r15, Y+5	; 0x05
    39ea:	0c 81       	ldd	r16, Y+4	; 0x04
    39ec:	1b 81       	ldd	r17, Y+3	; 0x03
    39ee:	aa 81       	ldd	r26, Y+2	; 0x02
    39f0:	b9 81       	ldd	r27, Y+1	; 0x01
    39f2:	ce 0f       	add	r28, r30
    39f4:	d1 1d       	adc	r29, r1
    39f6:	0f b6       	in	r0, 0x3f	; 63
    39f8:	f8 94       	cli
    39fa:	de bf       	out	0x3e, r29	; 62
    39fc:	0f be       	out	0x3f, r0	; 63
    39fe:	cd bf       	out	0x3d, r28	; 61
    3a00:	ed 01       	movw	r28, r26
    3a02:	08 95       	ret

00003a04 <_exit>:
    3a04:	f8 94       	cli

00003a06 <__stop_program>:
    3a06:	ff cf       	rjmp	.-2      	; 0x3a06 <__stop_program>
